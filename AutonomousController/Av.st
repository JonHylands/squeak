Object subclass: #SerialPort	instanceVariableNames: 'port baudRate stopBitsType parityType dataBits outputFlowControlType inputFlowControlType xOnByte xOffByte'	classVariableNames: ''	poolDictionaries: ''	category: 'System-Serial Port'!!SerialPort commentStamp: '<historical>' prior: 0!This class supports a simple interface to the serial ports of the underlying platform, if it supports serial ports. The mapping of port numbers to hardware ports is platform specific, but typically follows platform ordering conventions. For example, on the Macintosh, port 0 is the modem port and port 1 is the printer port, since in the programmers documentation these ports are referred to as ports A and B.!!SerialPort methodsFor: 'initialization' stamp: 'jm 5/5/1998 15:49'!initialize	"Default port settings."	port _ nil.					"set when opened"	baudRate _ 9600.			"9600 baud"	stopBitsType _ 1.				"one stop bit"	parityType _ 0.				"no parity"	dataBits _ 8.					"8 bits"	outputFlowControlType _ 0.	"none"	inputFlowControlType _ 0.	"none"	xOnByte _ 19.				"ctrl-S"	xOffByte _ 24.				"ctrl-X"! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:19'!baudRate	^ baudRate! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:29'!baudRate: anInteger	"Set the baud rate for this serial port."	baudRate _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:19'!dataBits	^ dataBits! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:29'!dataBits: anInteger	"Set the number of data bits for this serial port to 5, 6, 7, or 8."	dataBits _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:21'!inputFlowControlType	^ inputFlowControlType! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:38'!inputFlowControlType: anInteger	"Set the type of input flow control, where:		0 - none		1 - XOn/XOff		2 - hardware handshaking"	inputFlowControlType _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:19'!outputFlowControlType	^ outputFlowControlType! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:38'!outputFlowControlType: anInteger	"Set the type of output flow control, where:		0 - none		1 - XOn/XOff		2 - hardware handshaking"	outputFlowControlType _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:19'!parityType	^ parityType! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:29'!parityType: anInteger	"Set the parity type for this serial port, where:		0 - no parity		1 - odd parity		2 - even parity"	parityType _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:19'!stopBitsType	^ stopBitsType! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 18:02'!stopBitsType: anInteger	"Set the stop bits type for this serial port, where:		0 - 1.5 stop bits		1 - one stop bit		2 - two stop bits"	stopBitsType _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:20'!xOffByte	^ xOffByte! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:28'!xOffByte: anInteger	"Set the value of the XOff byte to be used if XOn/XOff flow control is enabled."	xOffByte _ anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:20'!xOnByte	^ xOnByte! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:28'!xOnByte: anInteger	"Set the value of the XOn byte to be used if XOn/XOff flow control is enabled."	xOnByte _ anInteger.! !!SerialPort methodsFor: 'open/close' stamp: 'jm 5/18/1998 15:40'!close	"Close the serial port. Do nothing if the port is not open."	port ifNotNil: [self primClosePort: port].	port _ nil.! !!SerialPort methodsFor: 'open/close' stamp: 'dns 6/27/2000 19:49'!openPort: portNumber	"Open the given serial port, using the settings specified by my instance variables. If the port cannot be opened, such as when it is alreay in use, answer nil."  "(DNS)"	self close.	(self primClosePort: portNumber) isNil ifTrue: [		^ nil ].	(self primOpenPort: portNumber		baudRate: baudRate		stopBitsType: stopBitsType		parityType: parityType		dataBits: dataBits		inFlowControlType: inputFlowControlType		outFlowControlType: outputFlowControlType		xOnByte: xOnByte		xOffByte: xOffByte) isNil ifTrue: [			^ nil ].	port _ portNumber! !!SerialPort methodsFor: 'input/output' stamp: 'yo 2/2/2001 15:13'!nextPutAll: aStringOrByteArray	"Send the given bytes out this serial port. The port must be open."	^ self primWritePort: port		from: aStringOrByteArray		startingAt: 1		count: aStringOrByteArray size.! !!SerialPort methodsFor: 'input/output' stamp: 'jm 5/18/1998 15:44'!readByteArray	"Answer a ByteArray read from this serial port. Answer an empty ByteArray if no data is available. The port must be open."	| buf count |	buf _ ByteArray new: 1000.	count _ self primReadPort: port into: buf startingAt: 1 count: buf size.	^ buf copyFrom: 1 to: count! !!SerialPort methodsFor: 'input/output' stamp: 'jm 5/18/1998 15:46'!readInto: aStringOrByteArray startingAt: index	"Read data into the given String or ByteArray object starting at the given index, and answer the number of bytes read. Does not go past the end of the given String or ByteArray."	^ self primReadPort: port		into: aStringOrByteArray		startingAt: index		count: (aStringOrByteArray size - index) + 1.! !!SerialPort methodsFor: 'input/output' stamp: 'jm 5/18/1998 15:43'!readString	"Answer a String read from this serial port. Answer the empty String if no data is available. The port must be open."	| buf count |	buf _ String new: 1000.	count _ self primReadPort: port into: buf startingAt: 1 count: buf size.	^ buf copyFrom: 1 to: count! !!SerialPort methodsFor: 'printing' stamp: 'jm 5/1/1998 18:02'!printOn: aStream	aStream		nextPutAll: 'SerialPort(';		nextPutAll:			(port ifNil: ['closed'] ifNotNil: ['#', port printString]);		nextPutAll: ', ';		print: baudRate; nextPutAll: ' baud, ';		print: dataBits; nextPutAll: ' bits, ';		nextPutAll: (#('1.5' '1' '2') at: stopBitsType + 1); nextPutAll: ' stopbits, ';		nextPutAll: (#('no' 'odd' 'even') at: parityType + 1); nextPutAll: ' parity)'.! !!SerialPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primClosePort: portNumber	<primitive: 'primitiveSerialPortClose' module: 'SerialPlugin'>	^ nil  "(DNS)"	"self primitiveFailed."! !!SerialPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primOpenPort: portNumber baudRate: baud stopBitsType: stop	parityType: parity dataBits: numDataBits	inFlowControlType: inFlowCtrl outFlowControlType: outFlowCtrl	xOnByte: xOn xOffByte: xOff	<primitive: 'primitiveSerialPortOpen' module: 'SerialPlugin'>	^ nil  "(DNS)"! !!SerialPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primReadPort: portNumber into: byteArray startingAt: startIndex count: count	<primitive: 'primitiveSerialPortRead' module: 'SerialPlugin'>	self primitiveFailed.! !!SerialPort methodsFor: 'primitives' stamp: 'ar 2/2/2001 15:09'!primWritePort: portNumber from: byteArray startingAt: startIndex count: count	<primitive: 'primitiveSerialPortWrite' module: 'SerialPlugin'>	self primitiveFailed.! !!SerialPort methodsFor: '*av' stamp: 'jon 10/10/2004 13:46'!isConnected	^port notNil! !!SerialPort methodsFor: '*av' stamp: 'Jon 10/27/2005 16:14'!readLargeByteArray	"Answer a ByteArray read from this serial port. Answer an empty ByteArray if no data is available. The port must be open."	| buf count |	buf _ ByteArray new: 4096.	count _ self primReadPort: port into: buf startingAt: 1 count: buf size.	^ buf copyFrom: 1 to: count! !Object subclass: #AvSystem	instanceVariableNames: 'mission vehicle logger'	classVariableNames: 'Current Runtime'	poolDictionaries: ''	category: 'Av-System'!!AvSystem commentStamp: '<historical>' prior: 0!An AvSystem is the root of the whole controller.Instance Variables:	mission:		<AvMission>	vehicle:			<AvVehicle>mission	- contains the current missionvehicle	- contains the vehicle the system is controlling!!AvSystem methodsFor: 'initializing' stamp: 'Jon 1/17/2006 14:19'!initialize	self initializeLogger.! !!AvSystem methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:22'!mission	^mission! !!AvSystem methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:22'!mission: avMission	mission := avMission! !!AvSystem methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:16'!missionElapsedTime	"Answer the number of milliseconds since the mission started."	^mission elapsedTime! !!AvSystem methodsFor: 'accessing' stamp: 'Jon 1/12/2006 13:21'!setSystemTimeAndDateFrom: aString	"First, we don't need to do this for anything but the target system, which is not X86."	self isEmbeddedSystem		ifFalse: [^self].	"Next, check if the date has been set by some other means."	Date today year >= 2006		ifTrue: [^self].! !!AvSystem methodsFor: 'accessing' stamp: 'Jon 1/27/2006 11:44'!setup	"Set up anything in the receiver to connect the mission and vehicle."	mission vehicle: vehicle.! !!AvSystem methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:26'!vehicle	^vehicle! !!AvSystem methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:26'!vehicle: avVehicle	vehicle := avVehicle! !!AvSystem methodsFor: 'testing' stamp: 'Jon 1/12/2006 12:50'!isEmbeddedSystem	^Smalltalk platformSubtype ~= 'IX86' ! !!AvSystem methodsFor: 'execution' stamp: 'Jon 1/27/2006 11:37'!runMission	"Run the receiver's mission."	self log: 'MISSION (Started mission: ', self mission name, ')'.	self mission runMission.	self log: 'MISSION (Done mission: ', self mission name, ')'.! !!AvSystem methodsFor: 'logging' stamp: 'Jon 1/17/2006 14:19'!initializeLogger	logger := AvLogger on: self class logDirectoryName, self logFilename.	logger initializeLog.! !!AvSystem methodsFor: 'logging' stamp: 'Jon 1/12/2006 11:51'!log: aString	logger log: aString! !!AvSystem methodsFor: 'logging' stamp: 'Jon 1/27/2006 15:45'!logCycle	"Log the stuff that gets logged every cycle."	| stream |	stream := WriteStream on: (String new: 100).	stream		nextPutAll: 'CYCLE (';		print: mission cycleTime;		nextPutAll: ' ms for cycle) '.	vehicle motionModel logCurrentInformationTo: stream.	self log: stream contents.	stream := WriteStream on: (String new: 100).	vehicle tracker logCurrentInformationTo: stream.	stream isEmpty		ifFalse: [self log: stream contents].! !!AvSystem methodsFor: 'logging' stamp: 'Jon 1/17/2006 15:13'!logFilename	| prefix matches matchNumbers newValue |	prefix := Date today yyyymmdd, '-av-'.	matches := (FileDirectory default directoryNamed: self class logDirectoryName) fileNames		select: [:eachName | eachName beginsWith: prefix].	matches isEmpty		ifTrue: [^prefix, '001.log'].	matchNumbers := matches collect: [:each |		((ReadStream on: each) upToAll: '-av-'; upToAll: '.log') asNumber].	newValue := matchNumbers max + 1.	^prefix, (newValue printPaddedWith: $0 to: 3), '.log'.! !!AvSystem methodsFor: 'logging' stamp: 'Jon 1/27/2006 12:11'!logNavigation	"Log the navigation stuff."	| stream |	stream := WriteStream on: (String new: 100).	mission currentNavigator logCurrentInformationTo: stream.	self log: stream contents.! !!AvSystem methodsFor: 'logging' stamp: 'Jon 1/27/2006 12:15'!logOldGoal: oldGoal newGoal: newGoal	"Log the fact we have completed oldGoal, and are starting newGoal."	| stream |	oldGoal notNil		ifTrue: [			stream := WriteStream on: (String new: 100).			oldGoal logFinishedTo: stream.			self log: stream contents].	newGoal notNil		ifTrue: [			stream := WriteStream on: (String new: 100).			newGoal logStartedTo: stream.			self log: stream contents].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvSystem class	instanceVariableNames: ''!!AvSystem class methodsFor: 'utility' stamp: 'Jon 11/28/2004 12:12'!exportMethodOrganization	"AvSystem exportMethodOrganization"	| organizations categoryNames file |	organizations := Dictionary new.	categoryNames := SystemOrganization categoriesMatching: 'Av*'.	categoryNames do: [:eachName |		(SystemOrganization superclassOrder: eachName) do: [:eachClass |			organizations at: eachClass put: (self extractOrganizationFrom: eachClass organization)]].	file := ReferenceStream newFileNamed: 'methodOrganization.obj'.	file nextPut: organizations.	file close.! !!AvSystem class methodsFor: 'utility' stamp: 'Jon 11/24/2004 12:16'!extractOrganizationFrom: organizer	| names |	names := organizer class allInstVarNames.	^Array		with: (organizer instVarAt: (names indexOf: 'categoryArray'))		with: (organizer instVarAt: (names indexOf: 'categoryStops'))		with: (organizer instVarAt: (names indexOf: 'elementArray'))! !!AvSystem class methodsFor: 'utility' stamp: 'Jon 1/16/2006 13:38'!fileoutGumstixAvSystem	"AvSystem fileoutGumstixAvSystem"	| file |	file := FileStream newFileNamed: 'Av-gumstix.st'.	SerialPort fileOutOn: file.	file cr; cr.	SystemOrganization		fileOutCategory: 'Av-System' on: file;		fileOutCategory: 'Av-Vehicle' on: file;		fileOutCategory: 'Av-Mission' on: file;		fileOutCategory: 'Av-Navigation' on: file;		fileOutCategory: 'Av-Tracker/Map' on: file;		fileOutCategory: 'Av-Motion' on: file;		fileOutCategory: 'Av-Sensors' on: file;		fileOutCategory: 'Av-Actuators' on: file;		fileOutCategory: 'Av-Hardware Interface' on: file;		fileOutCategory: 'Av-Device Interface' on: file;		fileOutCategory: 'Av-Exceptions' on: file;		fileOutCategory: 'Av-Support' on: file.	file cr; cr; close.! !!AvSystem class methodsFor: 'utility' stamp: 'Jon 11/24/2004 12:26'!importMethodOrganization	"AvSystem importMethodOrganization"	| organizations file names |	file := ReferenceStream fileNamed: 'methodOrganization.obj'.	organizations := file next.	file close.	names := AvSystem organization class allInstVarNames.	organizations keysAndValuesDo: [:eachClass :eachSet |		eachClass organization			instVarAt: (names indexOf: 'categoryArray') put: eachSet first;			instVarAt: (names indexOf: 'categoryStops') put: eachSet second;			instVarAt: (names indexOf: 'elementArray') put: eachSet third].! !!AvSystem class methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:50'!clearCurrent	"AvSystem clearCurrent"	Current := nil.! !!AvSystem class methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:11'!current	"AvSystem current"	^Current! !!AvSystem class methodsFor: 'accessing' stamp: 'Jon 1/16/2006 09:56'!deviceDirectoryName	^'devices', (String with: FileDirectory pathNameDelimiter)! !!AvSystem class methodsFor: 'accessing' stamp: 'Jon 1/17/2006 12:22'!isRuntime	^Runtime! !!AvSystem class methodsFor: 'accessing' stamp: 'Jon 1/16/2006 09:57'!logDirectoryName	^'logs', (String with: FileDirectory pathNameDelimiter)! !!AvSystem class methodsFor: 'accessing' stamp: 'Jon 1/16/2006 09:56'!missionDirectoryName	^'missions', (String with: FileDirectory pathNameDelimiter)! !!AvSystem class methodsFor: 'accessing' stamp: 'Jon 1/17/2006 12:25'!setRuntime: aBoolean	"AvSystem setRuntime: true"	"AvSystem setRuntime: false"	Runtime := aBoolean! !!AvSystem class methodsFor: 'accessing' stamp: 'Jon 1/25/2006 20:02'!showIncomingPacketsOnTranscript	^false! !!AvSystem class methodsFor: 'accessing' stamp: 'Jon 1/25/2006 20:02'!showOutgoingCommandsOnTranscript	^false! !!AvSystem class methodsFor: 'accessing' stamp: 'Jon 1/27/2006 11:40'!timePerCycle	"Answer the number of milliseconds a cycle should take."	^100! !!AvSystem class methodsFor: 'instance creation' stamp: 'Jon 1/16/2006 09:55'!on: vehicleFilename for: missionFilename	"Answer (and make current) a new instance of the receiver. Populate it from the	named vehicle and mission files."	Current := self new		mission: (AvMission fromFilename: self missionDirectoryName, missionFilename);		vehicle: (AvVehicle fromFilename: self deviceDirectoryName, vehicleFilename);		setup;		yourself.	^Current! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/16/2006 14:32'!fpBenchmark	"AvSystem fpBenchmark"	| c1 c2 time |	c1 := AvGpsCoordinate latitude: 47.620075 longitude: 122.351889.	c2 := AvGpsCoordinate latitude: 47.620644 longitude: 122.350684.	time := Time millisecondsToRun: [		10000 timesRepeat: [			c1 distanceTo: c2.			c1 bearingTo: c2]].	^time printString! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/16/2006 14:32'!initialize	Smalltalk addToStartUpList: self! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/16/2006 14:32'!reportBenchmark	| file |	FileDirectory default deleteFileNamed: 'benchmark.txt' ifAbsent: []. 	file := FileStream newFileNamed: 'benchmark.txt'.	file nextPutAll: 0 tinyBenchmarks.	file close ! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/16/2006 14:33'!reportFpBenchmark	| file |	FileDirectory default deleteFileNamed: 'fpbenchmark.txt' ifAbsent: []. 	file := FileStream newFileNamed: 'fpbenchmark.txt'.	10 timesRepeat: [		file nextPutAll: self fpBenchmark; nextPut: (Character value: 10)].	file close ! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/16/2006 14:33'!reportGeneral	| file lf |	lf := String lf.	FileDirectory default deleteFileNamed: 'general.txt' ifAbsent: []. 	file := FileStream newFileNamed: 'general.txt'.	file		nextPutAll: 'General Report';		nextPutAll: lf, lf, 'Smalltalk platformName - ', Smalltalk platformName;		nextPutAll: lf, 'Smalltalk platformSubtype - ', Smalltalk platformSubtype;		nextPutAll: lf, 'Smalltalk osVersion - ', Smalltalk osVersion;		nextPutAll: lf, lf, 'Date today - ', Date today printString;		nextPutAll: lf, 'Time now - ', Time now printString;		close.! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/16/2006 14:33'!reportHeadlessTest	| file |	FileDirectory default deleteFileNamed: 'imageReport.txt' ifAbsent: []. 	file := FileStream newFileNamed: 'imageReport.txt'.	file nextPutAll: 'If you can read this, Squeak is working!!'.	file close! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/25/2006 22:23'!runFloatReadTest	| file object |	file := FileStream readOnlyFileNamed: 'test.obj'.	object := file fileInObjectAndCode.	file close.	file := FileStream forceNewFileNamed: 'floatReadTest.log'.	object printOn: file.	file close.! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/25/2006 22:52'!runFloatTest	| file lf |	lf := String lf.	file := FileStream forceNewFileNamed: 'floatTest.log'.	file		nextPutAll: lf, 'Float Test';		nextPutAll: lf, '1.325 = ', 1.325 printString;		nextPutAll: lf, 'Float pi (3.141592653589793) = ', Float pi printString;		nextPutAll: lf, '1.0 / 3.0 (0.3333333333333333) = ', (1.0 / 3.0) printString;		nextPutAll: lf, 'Float pi + 2.0 * 1.3 / 30 degreesToRadians cos (7.71809974679502) = ', (Float pi + 2.0 * 1.3 / 30 degreesToRadians cos) printString.	file close.! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/23/2006 09:40'!runMission	| file text filenames |	[		(FileStream isAFileNamed: 'mission.txt')			ifFalse: [self handleMissionFailed: 'Missing mission specification file (mission.txt)...'].		file := FileStream readOnlyFileNamed: 'mission.txt'.		text := file contentsOfEntireFile.		file close.		filenames := (text subStrings: (String with: Character cr with: Character lf)) reject: [:each | each isEmpty].		filenames size = 2			ifFalse: [self handleMissionFailed: 'Bad mission specification file...'].		(self on: filenames first for: filenames last) runMission]	on: Error do: [:exception | self handleMissionFailed: 'Runtime error: ', exception description].! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/25/2006 21:45'!runMissionTest	| file mission |	file := FileStream forceNewFileNamed: 'missionTest.log'.	mission := AvMission fromFilename: 'missions/Straight Line Test 01.obj'.	mission describeOn: file.	file close.! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/19/2006 12:16'!runPatch	"Patch the image with whatever is in the patch.st file.	Return true if the patch was successful, false if not."	[		| file |		(FileStream isAFileNamed: 'patch.st')			ifFalse: [				self handlePatchFailed: 'Missing patch file (patch.st)...'.				^false].		file := FileStream readOnlyFileNamed: 'patch.st'.		file fileIn; close]	on: Error do: [:exception |		self handlePatchFailed: 'Runtime error: ', exception description.		^false].	^true! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/23/2006 09:39'!runSerialTest	| file text port |	(FileStream isAFileNamed: 'serialTest.txt')		ifFalse: [self handleMissionFailed: 'Missing serial test file (serialTest.txt)...'].	file := FileStream readOnlyFileNamed: 'serialTest.txt'.	text := file contentsOfEntireFile.	file close.	port := text asNumber.	self runSerialTest: port.! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/23/2006 11:07'!runSerialTest: portNumber	| port file done all |	port := SerialPort new		baudRate: 19200;		dataBits: 8;		stopBitsType: 1;		parityType: 0;		openPort: portNumber;		yourself.	file := FileStream forceNewFileNamed: 'serialTest.log'.	done := false.	all := OrderedCollection new.	[done] whileFalse: [		| bytes |		bytes := port readByteArray.		bytes notEmpty			ifTrue: [				port nextPutAll: bytes.				all addAll: bytes.				file nextPut: Character lf; nextPutAll: Time millisecondClockValue printString, ' - ', bytes asArray printString].		done := all size >= 20].	file close.	port close.! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/26/2006 08:54'!sdBenchmark	"AvSystem sdBenchmark"	| c1 c2 time |	c1 := AvGpsCoordinate latitude: 47.620075s6 longitude: 122.351889s6.	c2 := AvGpsCoordinate latitude: 47.620644s6 longitude: 122.350684s6.	time := Time millisecondsToRun: [		10000 timesRepeat: [			c1 distanceTo: c2.			c1 bearingTo: c2]].	^time printString! !!AvSystem class methodsFor: 'startup' stamp: 'Jon 1/27/2006 20:23'!startUp: resuming	| parameter |	AvSystem setRuntime: false.	resuming		ifFalse: [^self].	parameter := Smalltalk getSystemAttribute: 2.	parameter isNil		ifTrue: [^self]."	AvTrigonometryHelper		initializeCosTable;		initializeSinTable;		initializeTanTable."	parameter asLowercase = '-runmission'		ifTrue: [			AvSystem setRuntime: false.			self runMission.			Smalltalk quitPrimitive].	parameter asLowercase = '-patch'		ifTrue: [			AvSystem setRuntime: true.			self runPatch				ifTrue: [Smalltalk snapshot: true andQuit: true]				ifFalse: [Smalltalk quitPrimitive]].	parameter asLowercase = '-missiontest'		ifTrue: [			self runMissionTest.			Smalltalk quitPrimitive].	parameter asLowercase = '-floattest'		ifTrue: [			self runFloatTest.			Smalltalk quitPrimitive].	parameter asLowercase = '-serialtest'		ifTrue: [			self runSerialTest.			Smalltalk quitPrimitive].	parameter asLowercase = '-headlesstest'		ifTrue: [			self reportHeadlessTest.			Smalltalk quitPrimitive].	parameter asLowercase = '-benchmark'		ifTrue: [			self reportBenchmark.			Smalltalk quitPrimitive].	parameter asLowercase = '-report'		ifTrue: [			self reportGeneral.			Smalltalk quitPrimitive].	parameter asLowercase = '-fpbenchmark'		ifTrue: [			self reportFpBenchmark.			Smalltalk quitPrimitive].! !!AvSystem class methodsFor: 'error handling' stamp: 'Jon 1/17/2006 15:26'!handleMissionFailed: aString	self isRuntime		ifTrue: [			self reportMissionFailedError: aString.			self current notNil				ifTrue: [self current log: 'Mission Failed: ', aString].			Smalltalk quitPrimitive]		ifFalse: [self error: aString].! !!AvSystem class methodsFor: 'error handling' stamp: 'Jon 1/19/2006 12:11'!handlePatchFailed: aString	| file |	file := FileStream fileNamed: 'patchFailed.txt'.	file		setToEnd;		nextPutAll: Date today yyyymmdd;		nextPutAll: ' ';		nextPutAll: Time now print24;		nextPutAll: ' - Patch Failed: ', aString;		close.! !!AvSystem class methodsFor: 'error handling' stamp: 'Jon 1/17/2006 12:27'!reportMissionFailedError: aString	| file |	file := FileStream fileNamed: 'missionFailed.txt'.	file		setToEnd;		nextPutAll: Date today yyyymmdd;		nextPutAll: ' ';		nextPutAll: Time now print24;		nextPutAll: ' - Mission Failed: ', aString;		close.! !!AvSystem class methodsFor: 'gumstix accessing' stamp: 'Jon 1/25/2006 21:02'!copyPatchToGumstix	"AvSystem copyPatchToGumstix"	| file changeSet |	file := FileStream newFileNamed: 'c:\huv\gumstix\patch.st'.	changeSet := ChangeSorter changeSetNamed: 'Patch'.	changeSet isNil		ifTrue: [PopUpMenu inform: 'Couldn''t find "Patch" change set,,,']		ifFalse: [			changeSet fileOutOn: file.			file cr; cr].	file close.	OSProcess command: 'c:\huv\gumstix\pscp -p -l root -pw gumstix c:\huv\gumstix\patch.st 192.168.4.2:/mnt/mmc/av/'.! !!AvSystem class methodsFor: 'gumstix accessing' stamp: 'Jon 1/26/2006 13:27'!getDebugFileFromGumstix	"AvSystem getDebugFileFromGumstix"	| result file text |	result := OSProcess command: 'c:\huv\gumstix\pscp -batch -p -l root -pw gumstix 192.168.4.2:/mnt/mmc/av/SqueakDebug.log SqueakDebug.log'.	[result isComplete] whileFalse: [		(Delay forMilliseconds: 100) wait.		Processor yield].	result succeeded		ifFalse: [self error: 'Failed on copy...'].	file := FileStream fileNamed: 'SqueakDebug.log'.	text := file contentsOfEntireFile.	file close.	Workspace new		openLabel: 'Debug Log';		contents: text;		changed: #contents.! !!AvSystem class methodsFor: 'gumstix accessing' stamp: 'Jon 1/26/2006 13:09'!getDirListFor: fullPath	"AvSystem getDirListFor: '/mnt/mmc/av' "	| file items result |	result := OSProcess command: 'c:\huv\gumstix\plink -l root -pw gumstix 192.168.4.2 /bin/busybox ls -1 ', fullPath, ' > .dirList.txt'.	[result isComplete] whileFalse: [		(Delay forMilliseconds: 100) wait.		Processor yield].	result succeeded		ifFalse: [self error: 'Failed on list...'].	result := OSProcess command: 'c:\huv\gumstix\pscp -batch -p -l root -pw gumstix 192.168.4.2:.dirList.txt dirList.txt'.	[result isComplete] whileFalse: [		(Delay forMilliseconds: 100) wait.		Processor yield].	result succeeded		ifFalse: [self error: 'Failed on copy...'].	file := FileStream fileNamed: 'dirList.txt'.	items := OrderedCollection new.	[file atEnd] whileFalse: [		| line |		line := file upTo: Character lf.		items add: line].	file close.	^items! !!AvSystem class methodsFor: 'gumstix accessing' stamp: 'Jon 1/26/2006 13:24'!openLogFileFromGumstix	"AvSystem openLogFileFromGumstix"	| filenames index filename result file text |	filenames :=self getDirListFor: '/mnt/mmc/av/logs'.	filenames isEmpty		ifTrue: [^self inform: 'No log files.'].	index := PopUpMenu withCaption: 'Choose mission log file:' chooseFrom: filenames.	index = 0		ifTrue: [^self].	filename := filenames at: index.	result := OSProcess command: 'c:\huv\gumstix\pscp -batch -p -l root -pw gumstix 192.168.4.2:"/mnt/mmc/av/logs/', filename, '" mission.log'.	[result isComplete] whileFalse: [		(Delay forMilliseconds: 100) wait.		Processor yield].	result succeeded		ifFalse: [self error: 'Failed on copy...'].	file := FileStream fileNamed: 'mission.log'.	text := file contentsOfEntireFile.	file close.	Workspace new		openLabel: 'Mission Log: ', filename;		contents: text;		changed: #contents.! !AvSystem initialize!Object subclass: #AvVehicle	instanceVariableNames: 'name motionModel tracker'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Vehicle'!!AvVehicle commentStamp: '<historical>' prior: 0!An AvVehicle reprensents the actual vehicle we are controlling.Instance Variables:	name:				<String>	motionMode:		<AvMotionModel>	tracker:			<AvNavigationTracker>name	- contains the name of the vehiclemotionModel	- contains the motion model for this specific type of vehicle	- each type of vehicle has a subclass of AvMotionModeltracker	- contains the tracker, which keeps track of where the vehicle is!!AvVehicle methodsFor: 'initializing' stamp: 'Jon 12/23/2005 16:40'!initialize	tracker := AvNavigationTracker new.! !!AvVehicle methodsFor: 'accessing' stamp: 'jon 10/26/2004 22:35'!motionModel	^ motionModel! !!AvVehicle methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:48'!motionModel: anAvMotionModel	motionModel := anAvMotionModel.! !!AvVehicle methodsFor: 'accessing' stamp: 'jon 10/26/2004 22:36'!name	^name! !!AvVehicle methodsFor: 'accessing' stamp: 'Jon 12/29/2004 15:03'!name: aString	name := aString! !!AvVehicle methodsFor: 'accessing' stamp: 'jon 10/26/2004 22:36'!tracker	^ tracker! !!AvVehicle methodsFor: 'accessing' stamp: 'jon 10/26/2004 22:36'!tracker: anAvTracker	tracker := anAvTracker! !!AvVehicle methodsFor: 'accessing-derived' stamp: 'Jon 12/29/2004 15:03'!heading	"Answer the heading of the vehicle, in degrees."	^tracker heading! !!AvVehicle methodsFor: 'accessing-derived' stamp: 'Jon 12/29/2004 15:03'!position	"Answer the position of the vehicle. This is in map-local coordinates."	^tracker currentPosition! !!AvVehicle methodsFor: 'accessing-derived' stamp: 'Jon 12/29/2004 15:03'!sensorNamed: sensorName	"Return the sensor with the given name."	^motionModel sensorNamed: sensorName! !!AvVehicle methodsFor: 'printing' stamp: 'jon 10/28/2004 12:19'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self name;		nextPut: $)! !!AvVehicle methodsFor: 'private' stamp: 'jon 10/27/2004 12:20'!buildDeviceInterfaceMapFrom: deviceFilenames	| devices |	devices := deviceFilenames collect: [:each |		AvDevice fromFilename: each].	^devices		inject: Dictionary new		into: [:sum :eachDevice |			sum				at: eachDevice name put: eachDevice newInterface;				yourself].! !!AvVehicle methodsFor: 'private' stamp: 'Jon 12/29/2004 15:02'!buildFromVehicleFileMap: map	"Populate the receiver from the given map. See AvDeviceFileReader class >> #buildObjectMapFrom:	to see what the map contains."	self		name: (map at: #productName ifAbsent: [self errorDeviceFileMissingToken: 'ProductName']);		buildMotionModelFrom: map.! !!AvVehicle methodsFor: 'private' stamp: 'Jon 1/12/2006 11:48'!buildMotionModelFrom: map	"Populate the receiver's motion model from the given map. See AvDeviceFileReader class >> #buildObjectMapFrom:	to see what the map contains."	| deviceInterfaceMap |	motionModel := AvMotionModel forVehicleNamed: (map at: #productName).	deviceInterfaceMap := self buildDeviceInterfaceMapFrom: (map at: #deviceFilenames).	motionModel		sensorModel: (AvSensorModel new			hardwareInterfaces: deviceInterfaceMap;			buildSensorsFrom: (map at: #sensors);			yourself);		actuatorModel: (AvActuatorModel new			hardwareInterfaces: deviceInterfaceMap;			buildActuatorsFrom: (map at: #actuators);			yourself).	motionModel tracker: tracker.	tracker		sensorModel: motionModel sensorModel;		vehicleSpecification: motionModel vehicleSpecification.! !!AvVehicle methodsFor: 'logging' stamp: 'Jon 1/16/2006 09:23'!logCurrentInformationTo: stream	tracker logCurrentInformationTo: stream.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvVehicle class	instanceVariableNames: ''!!AvVehicle class methodsFor: 'file support' stamp: 'Jon 12/29/2004 15:00'!fromFileMap: map	"Answer a new instance of the receiver, built from the given map.	See AvDeviceFileReader class >> #buildObjectMapFrom: and subclass implementations	for more information on what the map contains."	^self new		buildFromVehicleFileMap: map;		yourself! !!AvVehicle class methodsFor: 'file support' stamp: 'Jon 12/29/2004 15:01'!fromFilename: filename	"Build a new instance ofthe receiver, and populate it from the data contained in the given file."	| file |	file := FileStream readOnlyFileNamed: filename.	^[self fromStream: file] ensure: [file close].! !!AvVehicle class methodsFor: 'file support' stamp: 'jon 10/26/2004 22:54'!fromStream: aStream	"Build a new instance ofthe receiver, and populate it from the data contained in aStream."	^AvVehicleFileReader readFromStream: aStream! !Object subclass: #AvGoal	instanceVariableNames: 'name navigator subGoals owner executionRule status'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Mission'!!AvGoal commentStamp: 'Jon 12/27/2005 20:49' prior: 0!An AvGoal is basically a wrapper for a navigator.Instance Variables	name:			<String>	navigator:		<AvNavigator>	subGoals:		<OrderedCollection of: <AvGoal>>	status:			<Symbol>	executionRule:	<Symbol>name	- the name of the goal	- does not have to be uniquenavigator	- the navigator that accomplishes the goalsubGoals	- a collection of sub goals that have to be complete in order for the receiver to be completestatus	- the current status of the goal. Can be #started, #running, #succeeded, #failedexecutionRule	- how the receiver handles internal failures	- must be one of the following values:		- #atomic - if the goal fails, the mission continues at the next sibling of the failed goal		- #required - if the goal fails, the parent goal is failed also!!AvGoal methodsFor: 'initializing' stamp: 'Jon 12/27/2005 21:37'!initialize	self		setStarted;		setRequired.! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/28/2005 21:20'!addGoal: aGoal	self subGoals add: aGoal.	aGoal owner: self.! !!AvGoal methodsFor: 'accessing' stamp: 'jon 11/21/2004 23:10'!allSubGoals	^self subGoals		inject: OrderedCollection new		into: [:sum :each |			sum				add: each;				addAll: each allSubGoals;				yourself].! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/26/2005 22:33'!executionRule	^executionRule! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 1/27/2006 11:47'!information	^self name, ' - ', status! !!AvGoal methodsFor: 'accessing' stamp: 'jon 11/12/2004 21:59'!name	^name! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/15/2004 13:51'!name: anObject	name := anObject! !!AvGoal methodsFor: 'accessing' stamp: 'jon 11/12/2004 21:59'!navigator	^ navigator! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/15/2004 13:51'!navigator: anObject	navigator := anObject! !!AvGoal methodsFor: 'accessing' stamp: 'jon 11/21/2004 22:45'!navigatorDescriptiveName	^navigator isNil		ifTrue: ['none']		ifFalse: [navigator class descriptiveName].! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/28/2005 07:47'!nextGoal	^owner nextGoalAfter: self! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/28/2005 07:49'!nextGoalAfter: avGoal	"Answer the next goal after the given one, which is one of my children.	If it is the last goal, recurse to my owner."	^subGoals after: avGoal ifAbsent: [owner nextGoalAfter: self].! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/28/2005 07:45'!owner	^owner! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/28/2005 07:45'!owner: anAvGoalOrMission	owner := anAvGoalOrMission! !!AvGoal methodsFor: 'accessing' stamp: 'jon 11/17/2004 18:43'!removeDeletedObjects	self navigator notNil		ifTrue: [self navigator removeDeletedObjects].! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/28/2005 21:20'!removeGoal: aGoal	self subGoals remove: aGoal.	aGoal owner: nil.! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/26/2005 22:42'!setAtomic	executionRule := #atomic! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/27/2005 21:50'!setExecutionRuleFrom: aString	executionRule := aString asSymbol! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/26/2005 22:39'!setFailed	status := #failed! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/26/2005 22:43'!setRequired	executionRule := #required! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/26/2005 22:38'!setRunning	status := #running! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/26/2005 22:39'!setStarted	status := #started! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/26/2005 22:39'!setSucceeded	status := #succeeded! !!AvGoal methodsFor: 'accessing' stamp: 'Jon 12/26/2005 22:37'!starting	status := #starting! !!AvGoal methodsFor: 'accessing' stamp: 'jon 11/21/2004 23:02'!subGoals	subGoals isNil		ifTrue: [subGoals := OrderedCollection new].	^subGoals.! !!AvGoal methodsFor: 'accessing' stamp: 'jon 11/21/2004 22:34'!subGoals: aCollection	subGoals := aCollection! !!AvGoal methodsFor: 'navigator' stamp: 'Jon 11/28/2004 09:45'!setNavigatorFrom: navigatorName for: mission	| navigatorClass |	navigatorClass := AvNavigator allSubclasses		detect: [:each | each descriptiveName = navigatorName]		ifNone: [^navigator := nil].	(navigator class == navigatorClass)		ifFalse: [navigator := navigatorClass newFor: mission].! !!AvGoal methodsFor: 'testing' stamp: 'jon 11/21/2004 23:04'!hasAllRequiredValues	"Answer whether or not all the receiver's attributes have been set. Forward to the navigator."	(navigator notNil and: [navigator hasAllRequiredValues not])		ifTrue: [^false].	self subGoals do: [:each |		each hasAllRequiredValues			ifFalse: [^false]].	^true! !!AvGoal methodsFor: 'testing' stamp: 'Jon 12/26/2005 22:40'!hasFailed	^status == #failed! !!AvGoal methodsFor: 'testing' stamp: 'jon 11/21/2004 23:27'!hasSubGoals	^self subGoals notEmpty! !!AvGoal methodsFor: 'testing' stamp: 'Jon 12/26/2005 22:39'!hasSucceeded	^status == #succeeded! !!AvGoal methodsFor: 'testing' stamp: 'Jon 12/27/2005 21:39'!isAtomic	^executionRule == #atomic! !!AvGoal methodsFor: 'testing' stamp: 'Jon 12/26/2005 22:40'!isComplete	^status == #succeeded or: [status == #failed]! !!AvGoal methodsFor: 'testing' stamp: 'Jon 12/27/2005 21:39'!isRequired	^executionRule == #required! !!AvGoal methodsFor: 'testing' stamp: 'Jon 12/26/2005 22:41'!isRunning	^status == #running! !!AvGoal methodsFor: 'testing' stamp: 'Jon 1/6/2006 09:13'!isShutdownGoal	^navigator isShutdownNavigator! !!AvGoal methodsFor: 'testing' stamp: 'Jon 1/6/2006 09:13'!isStartGoal	^navigator isStartupNavigator! !!AvGoal methodsFor: 'testing' stamp: 'Jon 12/28/2005 07:39'!needsExecution	"Answer true if the receiver needs execution, which means it has a navigator."	^navigator notNil! !!AvGoal methodsFor: 'execution' stamp: 'Jon 12/28/2005 08:06'!execute	"Execute the receiver. Answer the next goal to execute, which may be the receiver if it isn't done yet."	self needsExecution		ifFalse: [^self subGoals first execute].	navigator executeFor: self.	^self.! !!AvGoal methodsFor: 'printing' stamp: 'jon 11/13/2004 22:00'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self name.	navigator notNil		ifTrue: [aStream nextPutAll: ' - ', navigator class descriptiveName].	aStream nextPutAll: ')'! !!AvGoal methodsFor: 'logging' stamp: 'Jon 1/25/2006 21:41'!describeOn: aStream	aStream		nextPutAll: name;		nextPutAll: ' navigator: ('.	navigator describeOn: aStream.	subGoals notNil		ifTrue: [			aStream nextPutAll: ') subGoals: ('.			subGoals do: [:each | each describeOn: aStream].			aStream nextPut: $)].! !!AvGoal methodsFor: 'logging' stamp: 'Jon 1/27/2006 12:20'!logFinishedTo: stream	stream		nextPutAll: 'GOAL (finished ';		nextPutAll: self information;		nextPut: $).! !!AvGoal methodsFor: 'logging' stamp: 'Jon 1/27/2006 12:20'!logStartedTo: stream	stream		nextPutAll: 'GOAL (starting ';		nextPutAll: self information;		nextPut: $).! !Object subclass: #AvMission	instanceVariableNames: 'name currentNavigator vehicle map status startTime cycleTime'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Mission'!!AvMission commentStamp: 'Jon 12/29/2004 15:10' prior: 0!An AvMission is the abstract representation of a real-world mission. It has subclasses that decide how to accomplish the real world mission.Instance Variables	currentNavigator:		<AvNavigator>	map:					<AvMap>	name:					<String>	vehicle:				<AvVehicle>currentNavigator	- the navigator that is currently active in the missionmap	- the world mapname	- the name of the mission, which is also the main part of the file it is stored invehicle	- the vehicle that is accomplishing the mission!!AvMission methodsFor: 'initializing' stamp: 'Jon 12/1/2004 22:19'!initialize	map := AvNavigationMap new.! !!AvMission methodsFor: 'accessing' stamp: 'Jon 12/1/2004 22:20'!currentNavigator	^ currentNavigator! !!AvMission methodsFor: 'accessing' stamp: 'Jon 12/1/2004 22:20'!currentNavigator: anAvNavigator	currentNavigator := anAvNavigator! !!AvMission methodsFor: 'accessing' stamp: 'Jon 1/27/2006 11:43'!cycleTime	"Answer the number of milliseconds the most recent cycle took."	^cycleTime! !!AvMission methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:53'!elapsedTime	"Answer the elapsed time since the start of the mission."	^startTime isNil		ifTrue: [0]		ifFalse: [Time millisecondsSince: startTime].! !!AvMission methodsFor: 'accessing' stamp: 'Jon 1/3/2006 15:37'!failed	status := #failed! !!AvMission methodsFor: 'accessing' stamp: 'Jon 12/1/2004 22:20'!map	^ map! !!AvMission methodsFor: 'accessing' stamp: 'Jon 12/1/2004 22:20'!map: anAvMap	map := anAvMap! !!AvMission methodsFor: 'accessing' stamp: 'Jon 12/9/2004 09:07'!mapEntryForSwCorner	| entry |	entry := self map mapEntries		detect: [:each | each name asLowercase = 'anchor']		ifNone: [^nil].	^(entry isLocation and: [entry gpsCoordinate notNil])		ifTrue: [entry]		ifFalse: [nil].! !!AvMission methodsFor: 'accessing' stamp: 'Jon 12/1/2004 22:20'!name	^ name! !!AvMission methodsFor: 'accessing' stamp: 'Jon 12/1/2004 22:20'!name: aString	name := aString! !!AvMission methodsFor: 'accessing' stamp: 'Jon 1/3/2006 15:38'!running	status := #running! !!AvMission methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:12'!startTime	^startTime! !!AvMission methodsFor: 'accessing' stamp: 'Jon 1/3/2006 15:38'!succeeded	status := #succeeded! !!AvMission methodsFor: 'accessing' stamp: 'Jon 12/1/2004 22:20'!vehicle	^ vehicle! !!AvMission methodsFor: 'accessing' stamp: 'Jon 12/1/2004 22:21'!vehicle: anAvVehicle	vehicle := anAvVehicle! !!AvMission methodsFor: 'testing' stamp: 'Jon 1/3/2006 15:37'!hasFailed	^status == #failed! !!AvMission methodsFor: 'testing' stamp: 'Jon 12/1/2004 22:19'!hasMapEntryForSwCorner	^self mapEntryForSwCorner notNil! !!AvMission methodsFor: 'testing' stamp: 'Jon 1/3/2006 15:37'!hasSucceeded	^status == #succeeded! !!AvMission methodsFor: 'testing' stamp: 'Jon 1/3/2006 15:36'!isDone	^(status == #succeeded) | (status == #failed)! !!AvMission methodsFor: 'testing' stamp: 'Jon 1/3/2006 15:36'!isRunning	^status == #running! !!AvMission methodsFor: 'execution' stamp: 'Jon 1/27/2006 12:09'!runMission	"Run the receiver."	| lastNavLogTime |	self startMission.	lastNavLogTime := 0.	[self isDone] whileFalse: [		| delta |		cycleTime := Time millisecondsToRun: [			self execute.			AvSystem current logCycle.			(Time millisecondsSince: lastNavLogTime) >= 1000				ifTrue: [					lastNavLogTime := Time millisecondClockValue.					AvSystem current logNavigation]].		delta := AvSystem timePerCycle - cycleTime.		delta > 0			ifTrue: [(Delay forMilliseconds: delta) wait]].! !!AvMission methodsFor: 'execution' stamp: 'Jon 1/12/2006 11:15'!startMission	"Set up whatever is required to start the mission."	startTime := Time millisecondClockValue.	self running.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvMission class	instanceVariableNames: ''!!AvMission class methodsFor: 'instance creation' stamp: 'Jon 1/12/2006 11:28'!fromFilename: missionFilename	"Read and populate an instance of the receiver from the named file, and return that instance."	| file mission |	file := FileStream readOnlyFileNamed: missionFilename.	mission := file fileInObjectAndCode.	file close.	^mission! !AvMission subclass: #AvGoalBasedMission	instanceVariableNames: 'goals currentGoal'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Mission'!!AvGoalBasedMission commentStamp: 'Jon 12/29/2004 15:07' prior: 0!An AvGoalBasedMission is a mission that represents flow of control as a collection of goals.Instance Variables	goals:		<OrderedCollection of: <AvGoal>>goals	- the collection of top level goals that represent the completion of the receiver!!AvGoalBasedMission methodsFor: 'initializing' stamp: 'Jon 12/1/2004 22:18'!initialize	goals := OrderedCollection new.	super initialize.! !!AvGoalBasedMission methodsFor: 'accessing' stamp: 'jon 11/12/2004 21:58'!addGoal: avGoal	self goals add: avGoal! !!AvGoalBasedMission methodsFor: 'accessing' stamp: 'jon 11/21/2004 23:09'!allGoals	^goals		inject: OrderedCollection new		into: [:sum :each |			sum				add: each;				addAll: each allSubGoals;				yourself].! !!AvGoalBasedMission methodsFor: 'accessing' stamp: 'Jon 12/28/2005 07:43'!currentGoal	^currentGoal! !!AvGoalBasedMission methodsFor: 'accessing' stamp: 'Jon 1/16/2006 09:04'!currentGoalInformation	^currentGoal isNil		ifTrue: ['none']		ifFalse: [currentGoal information].! !!AvGoalBasedMission methodsFor: 'accessing' stamp: 'jon 11/12/2004 21:16'!goals	^ goals! !!AvGoalBasedMission methodsFor: 'accessing' stamp: 'Jon 12/15/2004 13:52'!goals: anObject	goals := anObject! !!AvGoalBasedMission methodsFor: 'accessing' stamp: 'Jon 12/28/2005 07:47'!nextGoal	^currentGoal nextGoal! !!AvGoalBasedMission methodsFor: 'accessing' stamp: 'Jon 1/15/2006 21:48'!nextGoalAfter: avGoal	"Answer the next goal after the given one, which is one of my children.	If it is the last goal, there aren't any more, so answer nil."	"Because #after:ifAbsent: doesn't do what it needs to, we need to do this..."	^[goals after: avGoal ifAbsent: [nil]] on: Error do: [:exception | ^nil].! !!AvGoalBasedMission methodsFor: 'accessing' stamp: 'Jon 1/27/2006 19:55'!parentGoalFor: anAvGoal 	^self allGoals		detect: [:each | each subGoals includes: anAvGoal]		ifNone: [self].! !!AvGoalBasedMission methodsFor: 'accessing' stamp: 'Jon 2/8/2006 15:59'!removeGoal: avGoal	| parent |	(parent := self parentGoalFor: avGoal) == self		ifTrue: [self goals remove: avGoal ifAbsent: []]		ifFalse: [parent removeGoal: avGoal].! !!AvGoalBasedMission methodsFor: 'accessing' stamp: 'Jon 1/6/2006 09:14'!startGoal	"Answer the start goal, or nil if there isn't one."	^self allGoals		detect: [:each | each isStartGoal]		ifNone: [nil].! !!AvGoalBasedMission methodsFor: 'accessing' stamp: 'Jon 1/16/2006 09:28'!statusNote	^status isNil		ifTrue: ['none']		ifFalse: [status asString].! !!AvGoalBasedMission methodsFor: 'testing' stamp: 'Jon 1/27/2006 12:34'!hasShutdownGoal	^goals notEmpty and: [goals last isShutdownGoal].! !!AvGoalBasedMission methodsFor: 'testing' stamp: 'Jon 1/6/2006 09:12'!hasStartGoal	^goals notEmpty and: [goals first isStartGoal].! !!AvGoalBasedMission methodsFor: 'execution' stamp: 'Jon 1/12/2006 11:36'!execute	"Execute one cycle of the receiver."	self isDone		ifTrue: [^self].	"We re-assign currentGoal here to handle when it is a non-leaf goal. #execute will always return a leaf goal."	self setCurrentGoal: currentGoal execute.	currentGoal isComplete		ifTrue: [self handleGoalComplete].! !!AvGoalBasedMission methodsFor: 'execution' stamp: 'Jon 1/25/2006 20:46'!startMission	"Set up whatever is required to start the mission."	super startMission.	self setCurrentGoal: self startGoal.	AvSystem current log: 'Setting start goal to: ', currentGoal printString.	AvSystem current log: 'Setting start navigator to: ', currentGoal navigator printString.	"We need to seed the DR engine with the intended start location."	vehicle tracker currentPosition: currentGoal navigator startLocation position.	AvSystem current log: 'Setting initial DR position to: ', vehicle tracker currentPosition printString.	"Finally, start the system, and give it time to sync..."	currentNavigator motionModel start.	(Delay forMilliseconds: 1000) wait.! !!AvGoalBasedMission methodsFor: 'private' stamp: 'Jon 1/27/2006 12:17'!handleFailedAtomicGoal	AvSystem current log: 'GOAL (failed atomic goal: ', currentGoal information, ')'.	currentGoal := currentGoal nextGoal! !!AvGoalBasedMission methodsFor: 'private' stamp: 'Jon 1/27/2006 12:16'!handleFailedMission	AvSystem current log: 'MISSION (Failed)'.	self failed.! !!AvGoalBasedMission methodsFor: 'private' stamp: 'Jon 1/27/2006 12:17'!handleFailedRequiredGoal	AvSystem current log: 'GOAL (failed required goal: ', currentGoal information, ')'.	[		currentGoal := currentGoal owner.		currentGoal notNil and: [currentGoal isRequired]] whileTrue.	currentGoal isNil		ifTrue: [self handleFailedMission]		ifFalse: [			currentGoal := currentGoal nextGoal.			currentGoal isNil				ifTrue: [self handleFailedMission]].! !!AvGoalBasedMission methodsFor: 'private' stamp: 'Jon 12/29/2005 21:27'!handleGoalComplete	"Private - the current goal is complete. Find out if it failed or succeeded, and what that means."	currentGoal hasSucceeded		ifTrue: [^self handleSuccessfulGoal].	currentGoal hasFailed		ifTrue: [			currentGoal isAtomic				ifTrue: [self handleFailedAtomicGoal]				ifFalse: [self handleFailedRequiredGoal]].! !!AvGoalBasedMission methodsFor: 'private' stamp: 'Jon 1/27/2006 12:17'!handleSuccessfulGoal	| completedGoal |	completedGoal := currentGoal.	self setCurrentGoal: currentGoal nextGoal.	AvSystem current logOldGoal: completedGoal newGoal: currentGoal.	currentGoal isNil		ifTrue: [self handleSuccessfulMission].! !!AvGoalBasedMission methodsFor: 'private' stamp: 'Jon 1/27/2006 12:16'!handleSuccessfulMission	AvSystem current log: 'MISSION (Successful)'.	self succeeded.! !!AvGoalBasedMission methodsFor: 'private' stamp: 'Jon 1/27/2006 12:18'!setCurrentGoal: aGoal	"Set the current goal, and grab the new navigator while we're there."	currentGoal == aGoal		ifTrue: [^self].	currentGoal := aGoal.	currentGoal notNil		ifTrue: [			currentNavigator := aGoal navigator.			currentNavigator notNil				ifTrue: [currentNavigator setupFrom: vehicle]].! !!AvGoalBasedMission methodsFor: 'logging' stamp: 'Jon 1/25/2006 21:41'!describeOn: aStream	aStream cr; nextPutAll: 'Name: ', name.	goals do: [:each |		aStream			cr;			nextPutAll: 'Goal: ('.		each describeOn: aStream.		aStream nextPutAll: ') '].	aStream cr.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvGoalBasedMission class	instanceVariableNames: ''!!AvGoalBasedMission class methodsFor: 'examples' stamp: 'jon 11/12/2004 21:55'!exampleRoboMagellanMission	"AvMission exampleRoboMagellanMission"	AvLocation initializeRoboMagellanLocations.	^self new		name: 'RoboMagellan 1';		addGoal: (AvGoal new			name: 'Navigate to Base of North Ramp';			navigator: (AvWaypointNavigator new				destination: (AvLocation named: 'Base of North Ramp');				finalHeading: 180;				yourself);			yourself);		addGoal: (AvGoal new			name: 'Line up with Ramp';			navigator: (AvCloseQuartersNavigator new				finalHeading: 180;				useCameraToLineUpWithRampBase;				allowableArea: ((AvLocation named: 'Base of North Ramp') rectangleFromBottomCenterExtent: 10 @ 2);				yourself);			yourself);		addGoal: (AvGoal new			name: 'Go up Ramp';			navigator: AvRampNavigator upRamp;			yourself);		addGoal: (AvGoal new			name: 'Find Bonus Cone 1';			navigator: AvVisualNavigator scanForTrafficCone;			yourself);		addGoal: (AvGoal new			name: 'Touch Bonus Cone 1';			navigator: AvVisualNavigator driveToTrafficCone;			yourself);		addGoal: (AvGoal new			name: 'Turn Around';			navigator: (AvCloseQuartersNavigator new				finalHeading: 0;				allowableArea: ((AvLocation named: 'Bonus Cone 1') rectangleFromCenter: 5 @ 5);				yourself);			yourself);		addGoal: (AvGoal new			name: 'Navigate to Top of North Ramp';			navigator: (AvWaypointNavigator new				destination: (AvLocation named: 'Top of North Ramp');				finalHeading: 0;				yourself);			yourself);		addGoal: (AvGoal new			name: 'Line up with Ramp';			navigator: (AvCloseQuartersNavigator new				finalHeading: 0;				useCameraToLineUpWithRampTop;				allowableArea: ((AvLocation named: 'Top of North Ramp') rectangleFromTopCenterExtent: 2 @ 2);				yourself);			yourself);		addGoal: (AvGoal new			name: 'Go down Ramp';			navigator: AvRampNavigator downRamp;			yourself);		yourself! !Object subclass: #AvNavigator	instanceVariableNames: 'vehicle motionModel initialPosition map stateMachine desiredOutput status'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvNavigator commentStamp: 'Jon 12/27/2005 23:16' prior: 0!An AvNavigator is an abstract class that knows how to accomplish very specific navigation goals. A navigator produces an output object the specifies how the vehicle should move. The output includes speed and heading, and can include, depending on the type of vehicle, depth or altitude.Instance Variables	desiredOutput:		<AvNavigatorOutput>	initialPosition:		<AvPosition>	map:				<AvMap>	motionModel:		<AvMotionModel>	stateMachine:		<AvStateMachine>	vehicle:			<AvVehicle>desiredOutput	- the state that the navigator wants to be in	- it is the resposibility of the motion model to make the vehicle's state correspond with this objectinitialPosition	- the position where the vehicle was when it (the navigator) first received controlmap	- the world mapmotionModel	- the object that contains vehicle-specific knowledge of how to make the vehicle's state correspond with the navigator's outputstateMachine	- the finite state machine that populates a navigator's output objectvehicle	- a shortcut to the vehicle!!AvNavigator methodsFor: 'initializing' stamp: 'Jon 12/27/2005 23:13'!initialize! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 12/4/2004 09:49'!desiredOutput	^desiredOutput! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 11/28/2004 09:38'!initialPosition	^ initialPosition! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 11/28/2004 09:38'!initialPosition: anObject	initialPosition := anObject! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 11/28/2004 09:48'!map	^ map! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 11/28/2004 09:48'!map: anObject	map := anObject! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 11/28/2004 09:38'!motionModel	^ motionModel! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 12/23/2005 16:29'!motionModel: anAvMotionModel	motionModel := anAvMotionModel.	desiredOutput := self motionModel desiredNavigatorOutputClass new.	motionModel navigatorOutput: self desiredOutput.! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 11/28/2004 09:38'!planner	^ planner! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 11/28/2004 09:38'!planner: anObject	planner := anObject! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 11/29/2004 12:25'!setInitialPositionFromMapObjectNamed: objectName	| object |	object := map mapObjectNamed: objectName.	object isNil		ifTrue: [self error: 'object ', objectName, ' not found in map...'].	object isPointMapObject		ifFalse: [self error: 'object ', objectName, ' must be a point-based map object...'].	self initialPosition: object position! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:38'!setupFrom: avVehicle	self		vehicle: avVehicle;		motionModel: avVehicle motionModel.! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 11/28/2004 09:38'!stateMachine	^ stateMachine! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 11/28/2004 09:38'!stateMachine: anObject	stateMachine := anObject! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 1/23/2006 20:03'!statusNote	^status isNil		ifTrue: ['none']		ifFalse: [status asString].! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 12/4/2004 11:37'!vehicle	^ vehicle! !!AvNavigator methodsFor: 'accessing' stamp: 'Jon 12/4/2004 11:37'!vehicle: anAvVehicle	vehicle := anAvVehicle! !!AvNavigator methodsFor: 'accessing-derived' stamp: 'Jon 12/4/2004 09:50'!desiredAltitude	^self desiredOutput desiredAltitude! !!AvNavigator methodsFor: 'accessing-derived' stamp: 'Jon 12/4/2004 09:50'!desiredAltitude: aNumber	self desiredOutput desiredAltitude: aNumber! !!AvNavigator methodsFor: 'accessing-derived' stamp: 'Jon 12/4/2004 09:49'!desiredDepth	^self desiredOutput desiredDepth! !!AvNavigator methodsFor: 'accessing-derived' stamp: 'Jon 12/4/2004 09:50'!desiredDepth: aNumber	self desiredOutput desiredDepth: aNumber! !!AvNavigator methodsFor: 'accessing-derived' stamp: 'Jon 12/4/2004 09:49'!desiredHeading	^self desiredOutput desiredHeading! !!AvNavigator methodsFor: 'accessing-derived' stamp: 'Jon 12/4/2004 09:50'!desiredHeading: aNumber	self desiredOutput desiredHeading: aNumber! !!AvNavigator methodsFor: 'accessing-derived' stamp: 'Jon 12/4/2004 09:49'!desiredSpeed	^self desiredOutput desiredSpeed! !!AvNavigator methodsFor: 'accessing-derived' stamp: 'Jon 12/4/2004 09:50'!desiredSpeed: aNumber	self desiredOutput desiredSpeed: aNumber! !!AvNavigator methodsFor: 'accessing-derived' stamp: 'Jon 1/14/2006 17:15'!tracker	^vehicle tracker! !!AvNavigator methodsFor: 'status' stamp: 'Jon 12/28/2005 08:04'!handleStatusFor: avGoal	"Set the goal's status based on the receiver's concept of where we are."	status isNil		ifTrue: [^self].	self isRunning		ifTrue: [avGoal setRunning]		ifFalse: [			self hasSucceeded				ifTrue: [avGoal setSucceeded]				ifFalse: [avGoal setFailed]].! !!AvNavigator methodsFor: 'status' stamp: 'Jon 12/28/2005 08:04'!hasFailed	^status == #failed! !!AvNavigator methodsFor: 'status' stamp: 'Jon 12/28/2005 08:04'!hasSucceeded	^status == #succeeded! !!AvNavigator methodsFor: 'status' stamp: 'Jon 12/28/2005 08:04'!isComplete	^status == #succeeded or: [status == #failed]! !!AvNavigator methodsFor: 'status' stamp: 'Jon 12/28/2005 08:04'!isRunning	^status == #running! !!AvNavigator methodsFor: 'status' stamp: 'Jon 12/28/2005 08:03'!setFailed	status := #failed! !!AvNavigator methodsFor: 'status' stamp: 'Jon 12/28/2005 08:02'!setRunning	status := #running! !!AvNavigator methodsFor: 'status' stamp: 'Jon 12/28/2005 08:03'!setSucceeded	status := #succeeded! !!AvNavigator methodsFor: 'execution' stamp: 'Jon 1/6/2006 08:33'!execute	stateMachine execute.	motionModel execute.! !!AvNavigator methodsFor: 'execution' stamp: 'Jon 12/28/2005 08:08'!executeFor: avGoal	self execute.	self handleStatusFor: avGoal! !!AvNavigator methodsFor: 'testing' stamp: 'jon 11/21/2004 10:14'!hasAllRequiredValues	"Answer whether or not all the receiver's attributes have been set."	^true! !!AvNavigator methodsFor: 'testing' stamp: 'jon 11/17/2004 16:11'!isCloseQuartersNavigator	^false! !!AvNavigator methodsFor: 'testing' stamp: 'jon 11/17/2004 16:11'!isRampNavigator	^false! !!AvNavigator methodsFor: 'testing' stamp: 'jon 11/17/2004 16:11'!isShutdownNavigator	^false! !!AvNavigator methodsFor: 'testing' stamp: 'Jon 1/6/2006 09:13'!isStartupNavigator	^false! !!AvNavigator methodsFor: 'testing' stamp: 'jon 11/17/2004 15:16'!isVisualNavigator	^false! !!AvNavigator methodsFor: 'testing' stamp: 'jon 11/17/2004 16:11'!isWaypointNavigator	^false! !!AvNavigator methodsFor: 'editor-cleanup' stamp: 'jon 11/17/2004 18:43'!removeDeletedObjects	"Do nothing in general."! !!AvNavigator methodsFor: 'logging' stamp: 'Jon 1/27/2006 11:51'!logCurrentInformationTo: stream	stream		nextPutAll: 'NAV: (';		nextPutAll: self class simpleDescriptiveName;		space;		nextPutAll: self statusNote.	self logSpecificInformationTo: stream.	stream nextPutAll: ') ('.	desiredOutput logCurrentInformationTo: stream.	stream nextPut: $).! !!AvNavigator methodsFor: 'logging' stamp: 'Jon 1/16/2006 09:07'!logSpecificInformationTo: stream	"Subclasses may override."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvNavigator class	instanceVariableNames: ''!!AvNavigator class methodsFor: 'accessing' stamp: 'jon 11/12/2004 21:23'!descriptiveName	^self subclassResponsibility! !!AvNavigator class methodsFor: 'accessing' stamp: 'jon 11/17/2004 13:01'!simpleDescriptiveName	^(self descriptiveName readStream upToAll: 'Navigator') withBlanksTrimmed asLowercase! !!AvNavigator class methodsFor: 'instance creation' stamp: 'Jon 11/28/2004 09:47'!newFor: aMission	^self new		map: aMission map;		yourself.! !AvNavigator subclass: #AvCloseQuartersNavigator	instanceVariableNames: 'allowableArea finalHeading visualTracker lineUp'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvCloseQuartersNavigator commentStamp: 'Jon 1/7/2005 12:02' prior: 0!An AvCloseQuartersNavigator is a navigator that can direct the vehicle to change its heading and/or position, optionally within a constrained area. If a position change is requested, the navigator can direct the vehicle to line up with some visually specified object, such as a ramp.Instance Variables	allowableArea:		<AvArea>	finalHeading:		<Number>	visualTracker:		<AvVisualTracker>	lineUp:				<Symbol>allowableArea	- an area that limits the vehicle's movement while it is navigatingfinalHeading	- the desired final heading the vehicle should have when finishedvisualTracker	- if lineUp is something other than #none, the visual tracker is used to visually line up the vehiclelineUp	- can be one of:		#none - we don't care what the vehicle is lined up with at the end		#upRamp - line up with the bottom of a ramp, in preparation for going up		#downRamp - line up with the top of a ramp, in preparation for going down!!AvCloseQuartersNavigator methodsFor: 'initializing' stamp: 'jon 11/16/2004 22:43'!initialize	super initialize.	lineUp := #none! !!AvCloseQuartersNavigator methodsFor: 'accessing' stamp: 'jon 11/16/2004 17:40'!allowableArea	^ allowableArea! !!AvCloseQuartersNavigator methodsFor: 'accessing' stamp: 'Jon 1/7/2005 12:03'!allowableArea: anAvArea	allowableArea := anAvArea! !!AvCloseQuartersNavigator methodsFor: 'accessing' stamp: 'jon 11/16/2004 17:40'!finalHeading	^ finalHeading! !!AvCloseQuartersNavigator methodsFor: 'accessing' stamp: 'Jon 1/7/2005 12:03'!finalHeading: aNumber	finalHeading := aNumber! !!AvCloseQuartersNavigator methodsFor: 'accessing' stamp: 'jon 11/16/2004 22:32'!lineUp	^ lineUp! !!AvCloseQuartersNavigator methodsFor: 'accessing' stamp: 'Jon 1/7/2005 12:03'!lineUp: aSymbol	lineUp := aSymbol! !!AvCloseQuartersNavigator methodsFor: 'accessing' stamp: 'jon 11/17/2004 10:43'!lineUpFrom: aString	aString = 'doesn''t matter'		ifTrue: [^lineUp := #none].	aString = 'ramp going up'		ifTrue: [^lineUp := #upRamp].	aString = 'ramp going down'		ifTrue: [^lineUp := #downRamp].	lineUp := nil! !!AvCloseQuartersNavigator methodsFor: 'accessing' stamp: 'jon 11/16/2004 22:47'!lineUpString	lineUp == #none		ifTrue: [^'doesn''t matter'].	lineUp == #upRamp		ifTrue: [^'ramp going up'].	lineUp == #downRamp		ifTrue: [^'ramp going down'].	^'unknown'! !!AvCloseQuartersNavigator methodsFor: 'accessing' stamp: 'Jon 1/7/2005 12:02'!visualTracker	^ visualTracker! !!AvCloseQuartersNavigator methodsFor: 'accessing' stamp: 'Jon 1/7/2005 12:03'!visualTracker: anAvVisualTracker	visualTracker := anAvVisualTracker! !!AvCloseQuartersNavigator methodsFor: 'testing' stamp: 'jon 11/21/2004 10:14'!hasAllRequiredValues	"Answer whether or not all the receiver's attributes have been set."	^allowableArea notNil & finalHeading notNil & lineUp notNil! !!AvCloseQuartersNavigator methodsFor: 'testing' stamp: 'jon 11/17/2004 16:11'!isCloseQuartersNavigator	^true! !!AvCloseQuartersNavigator methodsFor: 'editor-cleanup' stamp: 'jon 11/17/2004 18:44'!removeDeletedObjects	(allowableArea notNil and: [allowableArea isDeleted]) 		ifTrue: [allowableArea := nil].! !!AvCloseQuartersNavigator methodsFor: 'editor-dispatching' stamp: 'jon 11/15/2004 13:18'!addNavigatorMorphsTo: panelMorph for: missionEditor	missionEditor addCloseQuartersNavigatorMorphsTo: panelMorph for: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvCloseQuartersNavigator class	instanceVariableNames: ''!!AvCloseQuartersNavigator class methodsFor: 'accessing' stamp: 'jon 11/12/2004 21:23'!descriptiveName	^'Close Quarters Navigator'! !Object subclass: #AvNavigatorOutput	instanceVariableNames: 'desiredHeading desiredSpeed'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvNavigatorOutput commentStamp: 'Jon 12/29/2004 15:16' prior: 0!An AvNavigatorOutput is responsible for maintaining the output of a navigator.Instance Variables	desiredHeading:		<Number>	desiredSpeed:			<Number>desiredHeading	- the heading (in degrees) the navigator wants the vehicle to be atdesiredSpeed	- the speed (in meters per second) the navigator wants the vehicle to be at!!AvNavigatorOutput methodsFor: 'initializing' stamp: 'Jon 12/4/2004 11:45'!initialize	desiredSpeed := 0.0.	desiredHeading := 0.0.! !!AvNavigatorOutput methodsFor: 'accessing' stamp: 'Jon 12/4/2004 09:34'!desiredHeading	^ desiredHeading! !!AvNavigatorOutput methodsFor: 'accessing' stamp: 'Jon 12/4/2004 09:34'!desiredHeading: aNumber	desiredHeading := aNumber! !!AvNavigatorOutput methodsFor: 'accessing' stamp: 'Jon 12/4/2004 09:34'!desiredSpeed	^ desiredSpeed! !!AvNavigatorOutput methodsFor: 'accessing' stamp: 'Jon 12/4/2004 09:34'!desiredSpeed: aNumber	desiredSpeed := aNumber! !!AvNavigatorOutput methodsFor: 'printing' stamp: 'Jon 12/4/2004 11:44'!printDesiredValuesOn: aStream	aStream		nextPutAll: 'Heading: ';		nextPutAll: (desiredHeading roundTo: 0.01) printString;		nextPutAll: ' Speed: ';		nextPutAll: (desiredSpeed roundTo: 0.01) printString.! !!AvNavigatorOutput methodsFor: 'printing' stamp: 'Jon 12/4/2004 11:43'!printOn: aStream	aStream		print: self class;		nextPutAll: ' ('.	self printDesiredValuesOn: aStream.	aStream nextPut: $).! !!AvNavigatorOutput methodsFor: 'logging' stamp: 'Jon 1/27/2006 11:51'!logCurrentInformationTo: stream	stream		nextPutAll: 'desiredHeading: ';		print: desiredHeading;		nextPutAll: ' desiredSpeed: ';		print: desiredSpeed;		nextPutAll: ' m/s'.! !AvNavigatorOutput subclass: #AvAirBasedNavigatorOutput	instanceVariableNames: 'desiredAltitude'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvAirBasedNavigatorOutput methodsFor: 'initializing' stamp: 'Jon 12/4/2004 11:46'!initialize	super initialize.	desiredAltitude := 0.0.! !!AvAirBasedNavigatorOutput methodsFor: 'accessing' stamp: 'Jon 12/4/2004 11:46'!desiredAltitude	^desiredAltitude! !!AvAirBasedNavigatorOutput methodsFor: 'accessing' stamp: 'Jon 12/4/2004 11:46'!desiredAltitude: aNumber	desiredAltitude := aNumber! !!AvAirBasedNavigatorOutput methodsFor: 'printing' stamp: 'Jon 12/4/2004 11:46'!printDesiredValuesOn: aStream	super printDesiredValuesOn: aStream.	aStream		nextPutAll: ' Altitude: ';		nextPutAll: (desiredAltitude roundTo: 0.01) printString.! !AvNavigatorOutput subclass: #AvGroundBasedNavigatorOutput	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvGroundBasedNavigatorOutput commentStamp: 'Jon 12/29/2004 15:17' prior: 0!An AvGroundBasedNavigatorOutput is basically a concrete subclass of the abstract class AvNavigatorOutput. Since ground vehicles only care about speed and heading (with respect to motion), this class does not add any state or behavior.!AvNavigator subclass: #AvRampNavigator	instanceVariableNames: 'topLocation bottomLocation direction visualTracker'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvRampNavigator methodsFor: 'accessing' stamp: 'jon 11/15/2004 23:28'!bottomLocation	^ bottomLocation! !!AvRampNavigator methodsFor: 'accessing' stamp: 'jon 11/15/2004 23:28'!bottomLocation: anObject	bottomLocation _ anObject! !!AvRampNavigator methodsFor: 'accessing' stamp: 'jon 11/15/2004 23:28'!direction	^ direction! !!AvRampNavigator methodsFor: 'accessing' stamp: 'jon 11/15/2004 23:28'!direction: anObject	direction _ anObject! !!AvRampNavigator methodsFor: 'accessing' stamp: 'jon 11/16/2004 10:20'!downRamp	self direction: #downRamp! !!AvRampNavigator methodsFor: 'accessing' stamp: 'jon 11/15/2004 23:28'!topLocation	^ topLocation! !!AvRampNavigator methodsFor: 'accessing' stamp: 'jon 11/15/2004 23:28'!topLocation: anObject	topLocation _ anObject! !!AvRampNavigator methodsFor: 'accessing' stamp: 'jon 11/16/2004 10:20'!upRamp	self direction: #upRamp! !!AvRampNavigator methodsFor: 'testing' stamp: 'jon 11/21/2004 10:15'!hasAllRequiredValues	"Answer whether or not all the receiver's attributes have been set."	^topLocation notNil & bottomLocation notNil & direction notNil! !!AvRampNavigator methodsFor: 'testing' stamp: 'jon 11/16/2004 10:20'!isDownRamp	^direction == #downRamp! !!AvRampNavigator methodsFor: 'testing' stamp: 'jon 11/17/2004 16:12'!isRampNavigator	^true! !!AvRampNavigator methodsFor: 'testing' stamp: 'jon 11/16/2004 10:20'!isUpRamp	^direction == #upRamp! !!AvRampNavigator methodsFor: 'editor-cleanup' stamp: 'jon 11/17/2004 18:44'!removeDeletedObjects	(topLocation notNil and: [topLocation isDeleted]) 		ifTrue: [topLocation := nil].	(bottomLocation notNil and: [bottomLocation isDeleted]) 		ifTrue: [bottomLocation := nil].! !!AvRampNavigator methodsFor: 'editor-dispatching' stamp: 'jon 11/15/2004 13:19'!addNavigatorMorphsTo: panelMorph for: missionEditor	missionEditor addRampNavigatorMorphsTo: panelMorph for: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvRampNavigator class	instanceVariableNames: ''!!AvRampNavigator class methodsFor: 'accessing' stamp: 'jon 11/12/2004 21:23'!descriptiveName	^'Ramp Navigator'! !AvNavigator subclass: #AvShutdownNavigator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvShutdownNavigator methodsFor: 'initializing' stamp: 'Jon 1/6/2006 08:44'!initialize	super initialize.	self initializeStateMachine.! !!AvShutdownNavigator methodsFor: 'initializing' stamp: 'Jon 1/6/2006 08:44'!initializeStateMachine	stateMachine := (AvStateMachine on: self)		addStateHandler: (AvStateHandler new executeSelector: #handleStartNavigator) for: #startNavigator;		yourself.	stateMachine nextState: #startNavigator.! !!AvShutdownNavigator methodsFor: 'testing' stamp: 'jon 11/17/2004 16:11'!isShutdownNavigator	^true! !!AvShutdownNavigator methodsFor: 'state machine handlers' stamp: 'Jon 1/6/2006 08:45'!handleStartNavigator	initialPosition := self vehicle position.	motionModel stop.	self setSucceeded.! !!AvShutdownNavigator methodsFor: 'editor-dispatching' stamp: 'jon 11/15/2004 13:20'!addNavigatorMorphsTo: panelMorph for: missionEditor	missionEditor addShutdownNavigatorMorphsTo: panelMorph for: self! !!AvShutdownNavigator methodsFor: 'logging' stamp: 'Jon 1/25/2006 21:43'!describeOn: aStream	aStream		nextPutAll: 'Shutdown Navigator'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvShutdownNavigator class	instanceVariableNames: ''!!AvShutdownNavigator class methodsFor: 'accessing' stamp: 'jon 11/13/2004 21:53'!descriptiveName	^'Shutdown Navigator'! !AvNavigator subclass: #AvStartupNavigator	instanceVariableNames: 'startLocation'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvStartupNavigator methodsFor: 'initializing' stamp: 'Jon 1/6/2006 08:58'!initialize	super initialize.	self initializeStateMachine.! !!AvStartupNavigator methodsFor: 'initializing' stamp: 'Jon 1/6/2006 08:58'!initializeStateMachine	stateMachine := (AvStateMachine on: self)		addStateHandler: (AvStateHandler new executeSelector: #handleStartNavigator) for: #startNavigator;		yourself.	stateMachine nextState: #startNavigator.! !!AvStartupNavigator methodsFor: 'accessing' stamp: 'Jon 1/6/2006 09:01'!startLocation	^startLocation! !!AvStartupNavigator methodsFor: 'accessing' stamp: 'Jon 1/6/2006 09:01'!startLocation: avLocation	startLocation := avLocation! !!AvStartupNavigator methodsFor: 'testing' stamp: 'Jon 1/6/2006 09:13'!isStartupNavigator	^true! !!AvStartupNavigator methodsFor: 'state machine handlers' stamp: 'Jon 1/20/2006 17:39'!handleStartNavigator	initialPosition isNil		ifTrue: [initialPosition := self startLocation].	stateMachine millisecondsInCurrentState > 1500		ifTrue: [self setSucceeded].! !!AvStartupNavigator methodsFor: 'editor-dispatching' stamp: 'Jon 1/6/2006 08:58'!addNavigatorMorphsTo: panelMorph for: missionEditor	missionEditor addStartupNavigatorMorphsTo: panelMorph for: self! !!AvStartupNavigator methodsFor: 'printing' stamp: 'Jon 1/25/2006 20:51'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		print: startLocation;		nextPut: $).! !!AvStartupNavigator methodsFor: 'logging' stamp: 'Jon 1/25/2006 21:43'!describeOn: aStream	aStream		nextPutAll: 'Startup Navigator (';		nextPutAll: startLocation printString;		nextPutAll: ') '.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvStartupNavigator class	instanceVariableNames: ''!!AvStartupNavigator class methodsFor: 'accessing' stamp: 'Jon 1/6/2006 08:57'!descriptiveName	^'Startup Navigator'! !AvNavigator subclass: #AvTestNavigator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvTestNavigator methodsFor: 'execution' stamp: 'Jon 12/23/2005 16:34'!execute	motionModel execute.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvTestNavigator class	instanceVariableNames: ''!!AvTestNavigator class methodsFor: 'example' stamp: 'Jon 1/2/2006 15:16'!exampleMicroRover	"AvTestNavigator exampleMicroRover"	| vehicle navigator |	vehicle := AvVehicle fromFilename: 'devices\MicroRover.txt'.	navigator := self new.	navigator		vehicle: vehicle;		motionModel: vehicle motionModel.	^navigator! !!AvTestNavigator class methodsFor: 'example' stamp: 'Jon 1/28/2006 10:41'!exampleMicroRoverTestCompass	"AvTestNavigator exampleMicroRoverTestCompass"	| vehicle navigator |	vehicle := AvVehicle fromFilename: 'devices\MicroRover.txt'.	navigator := self new.	navigator		vehicle: vehicle;		motionModel: vehicle motionModel.	(navigator motionModel sensorNamed: 'compass') inspect.	(navigator motionModel sensorNamed: 'turrent') inspect.	navigator tracker currentPosition: (AvPosition x: 0 y: 0).	self halt: 'Proceed when inspector is ready...'.	navigator motionModel start.	(Delay forMilliseconds: 1000) wait.	100 timesRepeat: [		(navigator motionModel sensorNamed: 'master') finishCycle.		(Delay forMilliseconds: 100) wait.		10 timesRepeat: [World doOneCycle]].	(navigator motionModel sensorNamed: 'master') doneMission.	navigator motionModel stop.	Transcript cr; show: 'Done Test Compass...'.	^navigator! !!AvTestNavigator class methodsFor: 'example' stamp: 'Jon 1/3/2006 14:29'!exampleMicroRoverTestMotors	"AvTestNavigator exampleMicroRoverTestMotors"	| vehicle navigator |	vehicle := AvVehicle fromFilename: 'devices\MicroRover.txt'.	navigator := self new.	navigator		vehicle: vehicle;		motionModel: vehicle motionModel.	navigator motionModel start.	(Delay forMilliseconds: 1000) wait.	(navigator motionModel actuatorNamed: 'leftMotor') setRPM: 600.	(navigator motionModel sensorNamed: 'master') finishCycle.	3 timesRepeat: [		(Delay forMilliseconds: 1000) wait.		(navigator motionModel sensorNamed: 'master') keepAlive].	(navigator motionModel actuatorNamed: 'leftMotor') setRPM: 0.	(navigator motionModel sensorNamed: 'master') finishCycle.	(Delay forMilliseconds: 1000) wait.	(navigator motionModel actuatorNamed: 'rightMotor') setRPM: 600.	(navigator motionModel sensorNamed: 'master') finishCycle.	3 timesRepeat: [		(Delay forMilliseconds: 1000) wait.		(navigator motionModel sensorNamed: 'master') keepAlive].	(navigator motionModel actuatorNamed: 'leftMotor') setRPM: 0.	(navigator motionModel actuatorNamed: 'rightMotor') setRPM: 0.	(navigator motionModel sensorNamed: 'master') finishCycle.	(Delay forMilliseconds: 1000) wait.	(navigator motionModel sensorNamed: 'master') doneMission.	navigator motionModel stop.	^navigator! !!AvTestNavigator class methodsFor: 'example' stamp: 'Jon 1/4/2006 20:39'!exampleMicroRoverTestSonar	"AvTestNavigator exampleMicroRoverTestSonar"	| vehicle navigator |	vehicle := AvVehicle fromFilename: 'devices\MicroRover.txt'.	navigator := self new.	navigator		vehicle: vehicle;		motionModel: vehicle motionModel.	navigator motionModel start.	(Delay forMilliseconds: 1000) wait.	400 timesRepeat: [		(navigator motionModel sensorNamed: 'master') finishCycle.		(Delay forMilliseconds: 100) wait.		World doOneCycle].	(navigator motionModel sensorNamed: 'master') doneMission.	navigator motionModel stop.	^navigator! !!AvTestNavigator class methodsFor: 'example' stamp: 'Jon 1/3/2006 15:08'!exampleMicroRoverTestTurrent	"AvTestNavigator exampleMicroRoverTestTurrent"	| vehicle navigator |	vehicle := AvVehicle fromFilename: 'devices\MicroRover.txt'.	navigator := self new.	navigator		vehicle: vehicle;		motionModel: vehicle motionModel.	navigator motionModel start.	45 to: 205 by: 10 do: [:index |		(Delay forMilliseconds: 100) wait.		(navigator motionModel actuatorNamed: 'turrent') setAngle: index.		(navigator motionModel sensorNamed: 'master') finishCycle].	(Delay forMilliseconds: 1000) wait.	(navigator motionModel actuatorNamed: 'turrent') setAngle: 125.	(navigator motionModel sensorNamed: 'master') finishCycle.	(Delay forMilliseconds: 1000) wait.	(navigator motionModel sensorNamed: 'master') doneMission.	navigator motionModel stop.	^navigator! !!AvTestNavigator class methodsFor: 'example' stamp: 'Jon 1/3/2006 14:54'!exampleMicroRoverTestTurrent2	"AvTestNavigator exampleMicroRoverTestTurrent2"	| vehicle navigator |	vehicle := AvVehicle fromFilename: 'devices\MicroRover.txt'.	navigator := self new.	navigator		vehicle: vehicle;		motionModel: vehicle motionModel.	navigator motionModel start.	(Delay forMilliseconds: 1000) wait.	(navigator motionModel actuatorNamed: 'turrent') setAngle: 45.	(navigator motionModel sensorNamed: 'master') finishCycle.	(Delay forMilliseconds: 1000) wait.	(navigator motionModel actuatorNamed: 'turrent') setAngle: 85.	(navigator motionModel sensorNamed: 'master') finishCycle.	(Delay forMilliseconds: 1000) wait.	(navigator motionModel actuatorNamed: 'turrent') setAngle: 125.	(navigator motionModel sensorNamed: 'master') finishCycle.	(Delay forMilliseconds: 1000) wait.	(navigator motionModel actuatorNamed: 'turrent') setAngle: 165.	(navigator motionModel sensorNamed: 'master') finishCycle.	(Delay forMilliseconds: 1000) wait.	(navigator motionModel actuatorNamed: 'turrent') setAngle: 205.	(navigator motionModel sensorNamed: 'master') finishCycle.	(Delay forMilliseconds: 1000) wait.	(navigator motionModel actuatorNamed: 'turrent') setAngle: 125.	(navigator motionModel sensorNamed: 'master') finishCycle.	(Delay forMilliseconds: 1000) wait.	(navigator motionModel sensorNamed: 'master') doneMission.	navigator motionModel stop.	^navigator! !!AvTestNavigator class methodsFor: 'accessing' stamp: 'Jon 12/27/2005 10:13'!descriptiveName	^'Test Navigator'! !AvNavigator subclass: #AvVisualNavigator	instanceVariableNames: 'targetLocation mode tracker color type'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvVisualNavigator commentStamp: '<historical>' prior: 0!An AvVisualNavigator handles navigation while being directed from one or more visual sensors, such as a camera.Instance Variables:	targetLocation:	<AvLocation>	mode:				<Symbol>	tracker:			<AvVisualTracker>	color:				<Color>	type:				<Symbol>targetLocation	- the approximate location of the target on the mapmode	- can be one of #search, #guide	- in search mode, the navigator uses the scanning turrent to try and find the target	- in guide mode, the navigator controls the vehicle to move towards the targettracker	- the object that handles visually tracking whatever object we're trying to navigate to/on/etccolor	- the approximate color of the target object, if applicabletype	- the type of target object	- can be one of #rampTop, #rampBottom, #cone!!AvVisualNavigator methodsFor: 'accessing' stamp: 'jon 11/16/2004 22:54'!color	^ color! !!AvVisualNavigator methodsFor: 'accessing' stamp: 'jon 11/17/2004 08:23'!color: aColor	color := aColor! !!AvVisualNavigator methodsFor: 'accessing' stamp: 'jon 11/17/2004 08:22'!mode	^ mode! !!AvVisualNavigator methodsFor: 'accessing' stamp: 'jon 11/17/2004 08:23'!mode: aSymbol	mode := aSymbol! !!AvVisualNavigator methodsFor: 'accessing' stamp: 'jon 11/16/2004 22:54'!targetLocation	^ targetLocation! !!AvVisualNavigator methodsFor: 'accessing' stamp: 'jon 11/17/2004 08:23'!targetLocation: anAvLocation	targetLocation := anAvLocation! !!AvVisualNavigator methodsFor: 'accessing' stamp: 'Jon 1/7/2005 11:52'!tracker	^tracker! !!AvVisualNavigator methodsFor: 'accessing' stamp: 'Jon 1/7/2005 11:52'!tracker: anAvVisualTracker	tracker := anAvVisualTracker! !!AvVisualNavigator methodsFor: 'accessing' stamp: 'jon 11/16/2004 22:54'!type	^ type! !!AvVisualNavigator methodsFor: 'accessing' stamp: 'jon 11/17/2004 08:23'!type: aSymbol	type := aSymbol! !!AvVisualNavigator methodsFor: 'accessing' stamp: 'jon 11/17/2004 13:42'!typeFrom: aString	aString = 'cone'		ifTrue: [^type := #cone].	aString = 'ramp bottom'		ifTrue: [^type := #rampBottom].	aString = 'ramp top'		ifTrue: [^type := #rampTop].	type := nil.! !!AvVisualNavigator methodsFor: 'accessing' stamp: 'jon 11/17/2004 13:38'!typeString	type == #cone		ifTrue: [^'cone'].	type == #rampBottom		ifTrue: [^'ramp bottom'].	type == #rampTop		ifTrue: [^'ramp top'].	^'unknown'! !!AvVisualNavigator methodsFor: 'testing' stamp: 'jon 11/21/2004 10:15'!hasAllRequiredValues	"Answer whether or not all the receiver's attributes have been set."	^targetLocation notNil & mode notNil & color notNil & type notNil! !!AvVisualNavigator methodsFor: 'testing' stamp: 'jon 11/17/2004 13:27'!isModeGuide	^mode == #guide! !!AvVisualNavigator methodsFor: 'testing' stamp: 'jon 11/17/2004 13:27'!isModeSearch	^mode == #search! !!AvVisualNavigator methodsFor: 'testing' stamp: 'jon 11/17/2004 15:16'!isVisualNavigator	^true! !!AvVisualNavigator methodsFor: 'editor-cleanup' stamp: 'jon 11/17/2004 18:44'!removeDeletedObjects	(targetLocation notNil and: [targetLocation isDeleted]) 		ifTrue: [targetLocation := nil].! !!AvVisualNavigator methodsFor: 'editor-dispatching' stamp: 'jon 11/15/2004 13:21'!addNavigatorMorphsTo: panelMorph for: missionEditor	missionEditor addVisualNavigatorMorphsTo: panelMorph for: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvVisualNavigator class	instanceVariableNames: ''!!AvVisualNavigator class methodsFor: 'accessing' stamp: 'jon 11/12/2004 21:24'!descriptiveName	^'Visual Navigator'! !Object subclass: #AvVisualTracker	instanceVariableNames: 'color camera'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvVisualTracker commentStamp: 'Jon 1/7/2005 11:56' prior: 0!An AvVisualTracker is responsible for tracking objects visually. Specific subclasses handle tracking specific kinds of visual objects, such as a cone or a ramp.Instance Variables	camera:		<AvCameraSensor>	color:			<Color>camera	- a camera sensor	- can be either a blob-tracking camera sensor (like a CMU camera) or a full-blown image processing cameracolor	- the approximate color of the object the camera is supposed to track!AvVisualTracker subclass: #AvVisualConeTracker	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvVisualConeTracker commentStamp: 'Jon 1/7/2005 12:00' prior: 0!An AvVisualConeTracker is resposible for tracking a traffic-style cone. It uses a CMU-camera, or something similar, to do color blob vectoring. It can also use a standard image-processing camera to do shape analysis.!AvVisualTracker subclass: #AvVisualRampTracker	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvVisualRampTracker commentStamp: 'Jon 1/7/2005 11:58' prior: 0!An AvVisualRampTracker is resposible for identifying and providing offsets to a ramp. It uses a full-blown image processing camera to accomplish this.!AvNavigatorOutput subclass: #AvWaterBasedNavigatorOutput	instanceVariableNames: 'desiredDepth'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvWaterBasedNavigatorOutput methodsFor: 'initializing' stamp: 'Jon 12/4/2004 11:45'!initialize	super initialize.	desiredDepth := 0.0.! !!AvWaterBasedNavigatorOutput methodsFor: 'accessing' stamp: 'Jon 12/4/2004 09:34'!desiredDepth	^ desiredDepth! !!AvWaterBasedNavigatorOutput methodsFor: 'accessing' stamp: 'Jon 12/4/2004 09:34'!desiredDepth: aNumber	desiredDepth := aNumber! !!AvWaterBasedNavigatorOutput methodsFor: 'printing' stamp: 'Jon 12/4/2004 11:45'!printDesiredValuesOn: aStream	super printDesiredValuesOn: aStream.	aStream		nextPutAll: ' Depth: ';		nextPutAll: (desiredDepth roundTo: 0.01) printString.! !AvNavigator subclass: #AvWaypointNavigator	instanceVariableNames: 'destinationLocation waypoints nextWaypoint'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvWaypointNavigator commentStamp: 'Jon 12/8/2004 13:58' prior: 0!An AvWaypointNavigator is a navigator that handles navigating along a path, or to a specific location on the map.Instance Variables	destinationLocation:	<AvLocation | AvPath>	nextWaypoint:			<AvPosition>	waypoints:				<OrderedCollection | ReadStream on: <AvPosition>>destinationLocation	- contains either the destination location on the map, or a path that traces out the route to follownextWaypoint	- contains the waypoint the navigator is trying to reachwaypoints	- dual use		- for editing/planning, contains a collection of positions that make up the waypoints the receiver is to follow		- for execution, contains a read stream over this collection		- for execution, nextWaypoint is fed by the next position from the stream!!AvWaypointNavigator methodsFor: 'initializing' stamp: 'Jon 11/27/2004 22:38'!initialize	self initializeStateMachine.	super initialize.! !!AvWaypointNavigator methodsFor: 'initializing' stamp: 'Jon 12/4/2004 09:25'!initializeStateMachine	stateMachine := (AvStateMachine on: self)		addStateHandler: (AvStateHandler new executeSelector: #handleStartNavigator) for: #startNavigator;		addStateHandler: (AvStateHandler new executeSelector: #handleHeadingForWaypoint) for: #headingForWaypoint;		addStateHandler: (AvStateHandler new executeSelector: #handleAtWaypoint) for: #atWaypoint;		addStateHandler: (AvStateHandler new executeSelector: #handleReplan) for: #replan;		addStateHandler: (AvStateHandler new executeSelector: #handleFailedFinish) for: #failedFinish;		addStateHandler: (AvStateHandler new executeSelector: #handleSuccessfulFinish) for: #successfulFinish;		addStateHandler: (AvStateHandler new executeSelector: #handleTimedOut) for: #timedOut;		yourself.	stateMachine nextState: #startNavigator.! !!AvWaypointNavigator methodsFor: 'accessing' stamp: 'Jon 12/4/2004 08:40'!allowableOffsetToPosition	"Answer how close the vehicle has to be to a given position to be considered there"	^1.0! !!AvWaypointNavigator methodsFor: 'accessing' stamp: 'jon 11/15/2004 13:32'!destinationLocation	^destinationLocation! !!AvWaypointNavigator methodsFor: 'accessing' stamp: 'Jon 11/27/2004 22:46'!destinationLocation: aMapObject	destinationLocation := aMapObject.	destinationLocation isPath		ifTrue: [self waypoints: destinationLocation points]		ifFalse: [self planWaypointsFromDestination].! !!AvWaypointNavigator methodsFor: 'accessing' stamp: 'Jon 12/4/2004 09:19'!remainingWaypoints	"Answer a collection containing the remaining waypoints, without disturbing where we are."	| oldPosition remaining |	oldPosition := waypoints position.	remaining := waypoints upToEnd.	waypoints position: oldPosition.	^remaining! !!AvWaypointNavigator methodsFor: 'accessing' stamp: 'Jon 11/27/2004 22:44'!waypoints	^ waypoints! !!AvWaypointNavigator methodsFor: 'accessing' stamp: 'Jon 11/27/2004 22:44'!waypoints: aCollection	waypoints := aCollection! !!AvWaypointNavigator methodsFor: 'state machine handlers' stamp: 'Jon 1/15/2006 21:53'!handleAtWaypoint	self atLastWaypoint		ifTrue: [^stateMachine nextState: #successfulFinish].	nextWaypoint := waypoints next.	AvSystem current log: 'Switching to next waypoint: ', nextWaypoint printString.	stateMachine nextState: #headingForWaypoint.! !!AvWaypointNavigator methodsFor: 'state machine handlers' stamp: 'Jon 12/29/2005 20:52'!handleFailedFinish	self setFailed.! !!AvWaypointNavigator methodsFor: 'state machine handlers' stamp: 'Jon 1/26/2006 22:28'!handleHeadingForWaypoint	(self isAtPosition: nextWaypoint)		ifTrue: [^stateMachine nextState: #atWaypoint].	self		desiredHeading: (self vehicle position bearingTo: nextWaypoint);		desiredSpeed: 1.63.! !!AvWaypointNavigator methodsFor: 'state machine handlers' stamp: 'Jon 12/28/2005 08:01'!handleStartNavigator	initialPosition := self vehicle position.	waypoints := ReadStream on: waypoints.	nextWaypoint := waypoints next.	stateMachine nextState: #headingForWaypoint.	self setRunning.! !!AvWaypointNavigator methodsFor: 'state machine handlers' stamp: 'Jon 1/15/2006 21:53'!handleSuccessfulFinish	AvSystem current log: 'At final waypoint...'.	self setSucceeded! !!AvWaypointNavigator methodsFor: 'state machine handlers' stamp: 'Jon 12/4/2004 09:47'!handleTimedOut	"We've been timed out. Try and reach the next waypoint instead of the current one.	If wa can't, fail."		| waypointsLeft |	waypointsLeft := self remainingWaypoints.	waypointsLeft isEmpty		ifTrue: [^self cantReachFinalWaypoint].	(self vehicle position distanceTo: nextWaypoint) < (self allowableOffsetToPosition * 3)		ifTrue: [stateMachine nextState: #atWaypoint]		ifFalse: [stateMachine nextState: #failedFinish].! !!AvWaypointNavigator methodsFor: 'planning' stamp: 'Jon 12/4/2004 08:57'!addMapEntriesToPlanner: planner	| boxes |	boxes := OrderedCollection new.	self map mapEntries do: [:each |		(each isArea and: [each hasPropertyNamed: #exclusionZone])			ifTrue: [boxes add: each]].	planner map: boxes.! !!AvWaypointNavigator methodsFor: 'planning' stamp: 'Jon 12/4/2004 08:57'!planWaypointsFromDestination	| planner |	initialPosition isNil		ifTrue: [^self].	(planner := AvWaypointPlanner new)		startLocation: initialPosition mapPoint;		endLocation: destinationLocation position mapPoint.	self addMapEntriesToPlanner: planner.	planner replan.	waypoints := planner path isNil		ifTrue: [nil]		ifFalse: [planner path collect: [:each | AvPosition fromPoint: each]].! !!AvWaypointNavigator methodsFor: 'testing' stamp: 'Jon 1/15/2006 21:36'!atLastWaypoint	^waypoints atEnd! !!AvWaypointNavigator methodsFor: 'testing' stamp: 'Jon 1/7/2005 11:40'!hasAllRequiredValues	"Answer whether or not all the receiver's editable attributes have been set."	^destinationLocation notNil! !!AvWaypointNavigator methodsFor: 'testing' stamp: 'Jon 1/7/2005 11:39'!isAtPosition: aPosition	"Answer true if the vehicle is close enough to the given position to make it practically there."	^(vehicle position distanceTo: aPosition) abs <= self allowableOffsetToPosition! !!AvWaypointNavigator methodsFor: 'testing' stamp: 'jon 11/17/2004 16:12'!isWaypointNavigator	^true! !!AvWaypointNavigator methodsFor: 'editor-cleanup' stamp: 'jon 11/17/2004 18:45'!removeDeletedObjects	(destinationLocation notNil and: [destinationLocation isDeleted]) 		ifTrue: [destinationLocation := nil].! !!AvWaypointNavigator methodsFor: 'editor-dispatching' stamp: 'jon 11/15/2004 13:22'!addNavigatorMorphsTo: panelMorph for: missionEditor	missionEditor addWaypointNavigatorMorphsTo: panelMorph for: self! !!AvWaypointNavigator methodsFor: 'private' stamp: 'Jon 12/4/2004 09:25'!cantReachFinalWaypoint	"We have timed out looking for the final waypoint. Deal with it."	stateMachine nextState: #failedFinish.! !!AvWaypointNavigator methodsFor: 'logging' stamp: 'Jon 1/25/2006 21:44'!describeOn: aStream	aStream		nextPutAll: 'Waypoint Navigator (';		nextPutAll: waypoints size printString;		nextPutAll: ' waypoints) '.! !!AvWaypointNavigator methodsFor: 'logging' stamp: 'Jon 1/27/2006 11:50'!logSpecificInformationTo: stream	"Subclasses may override."	waypoints isCollection		ifTrue: [^self].	stream		nextPutAll: ' #';		print: waypoints position;		nextPutAll: '/';		print: waypoints size.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvWaypointNavigator class	instanceVariableNames: ''!!AvWaypointNavigator class methodsFor: 'accessing' stamp: 'jon 11/12/2004 21:24'!descriptiveName	^'Waypoint Navigator'! !Object subclass: #AvWaypointPlanner	instanceVariableNames: 'map startLocation endLocation endHeading path boundingBox'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Navigation'!!AvWaypointPlanner methodsFor: 'accessing' stamp: 'jon 10/13/2004 23:24'!boundingBox	"Answer the value of boundingBox"	^ boundingBox! !!AvWaypointPlanner methodsFor: 'accessing' stamp: 'jon 10/13/2004 23:24'!boundingBox: anObject	"Set the value of boundingBox"	boundingBox _ anObject! !!AvWaypointPlanner methodsFor: 'accessing' stamp: 'jon 10/13/2004 21:51'!endLocation	"Answer the value of endLocation"	^ endLocation! !!AvWaypointPlanner methodsFor: 'accessing' stamp: 'jon 10/13/2004 21:51'!endLocation: aPoint	"Set the value of endLocation"	endLocation := aPoint! !!AvWaypointPlanner methodsFor: 'accessing' stamp: 'jon 10/13/2004 21:50'!map	"Answer the value of map"	^ map! !!AvWaypointPlanner methodsFor: 'accessing' stamp: 'jon 10/13/2004 23:00'!map: aCollection	"Set the value of map"	map := aCollection! !!AvWaypointPlanner methodsFor: 'accessing' stamp: 'jon 10/13/2004 21:53'!path	"Answer the value of path"	^ path! !!AvWaypointPlanner methodsFor: 'accessing' stamp: 'jon 10/13/2004 21:53'!path: aPath	"Set the value of path"	path := aPath! !!AvWaypointPlanner methodsFor: 'accessing' stamp: 'jon 10/13/2004 21:51'!startLocation	"Answer the value of startLocation"	^ startLocation! !!AvWaypointPlanner methodsFor: 'accessing' stamp: 'jon 10/13/2004 21:51'!startLocation: aPoint	"Set the value of startLocation"	startLocation := aPoint! !!AvWaypointPlanner methodsFor: 'planning' stamp: 'jon 10/15/2004 11:51'!replan	path := OrderedCollection with: startLocation with: endLocation.	path := (self replanBetween: startLocation and: endLocation)		ifTrue: [self simplifyPath: path]		ifFalse: [nil].! !!AvWaypointPlanner methodsFor: 'private-planning' stamp: 'jon 10/15/2004 15:07'!chooseBestPathFrom: paths	| simplifiedPaths angles weights bestPath minWeight |	simplifiedPaths := paths collect: [:each | self simplifyPath: each].	angles := simplifiedPaths collect: [:each | self findLargestAngleInPath: each].	weights := (1 to: angles size) collect: [:index |		((angles at: index) * 0.75) + ((simplifiedPaths at: index) size * 0.25)].	minWeight := 1000000.	weights with: simplifiedPaths do: [:eachWeight :eachPath |		eachWeight < minWeight			ifTrue: [				minWeight := eachWeight.				bestPath := eachPath]].	^bestPath! !!AvWaypointPlanner methodsFor: 'private-planning' stamp: 'Jon 11/29/2004 13:27'!findIntersectionPointFrom: firstPoint to: secondPoint in: object	| points |	points := self findIntersectionPointsFrom: firstPoint to: secondPoint in: object.	points := points select: [:each | each onLineFrom: firstPoint to: secondPoint].	points := points reject: [:each | each = firstPoint | (each = secondPoint)].	points isEmpty		ifTrue: [^nil].	points size = 1		ifTrue: [^points first].	^(firstPoint dist: points first) < (firstPoint dist: points last)		ifTrue: [points first]		ifFalse: [points last]! !!AvWaypointPlanner methodsFor: 'private-planning' stamp: 'Jon 11/29/2004 12:53'!findIntersectionPointsFrom: firstPoint to: secondPoint in: object	| points |	points := OrderedCollection new.	object lineSegments do: [:eachLineSegment |		| point |		point := self			intersectFrom: firstPoint			to: secondPoint			and: eachLineSegment start			to: eachLineSegment end.		point notNil			ifTrue: [points add: point]].	^points! !!AvWaypointPlanner methodsFor: 'private-planning' stamp: 'jon 10/14/2004 13:56'!findLargestAngleInPath: aPath	| angle |	aPath size < 3		ifTrue: [^180].	angle := 0.	1 to: aPath size - 2 do: [:index |		| first second third |		first := aPath at: index.		second := aPath at: index + 1.		third := aPath at: index + 2.		angle := angle max: ((second bearingToPoint: third) - (first bearingToPoint: second)) abs].	^angle! !!AvWaypointPlanner methodsFor: 'private-planning' stamp: 'jon 10/15/2004 12:54'!intersectFrom: firstLineStart to: firstLineEnd and: secondLineStart to: secondLineEnd	"Answer the intersection point of two line segments. Return nil if there is no intersection."	^(LineSegment from: firstLineStart to: firstLineEnd)		intersectionWith: (LineSegment from: secondLineStart to: secondLineEnd)! !!AvWaypointPlanner methodsFor: 'private-planning' stamp: 'Jon 11/29/2004 13:23'!mapObjectIntersecting: firstPoint and: secondPoint	| points objects sorted |	points := OrderedCollection new.	objects := map select: [:each |		| point |		(point := self findIntersectionPointFrom: firstPoint to: secondPoint in: each) isNil			ifTrue: [false]			ifFalse: [				(point ~= firstPoint and: [point ~= secondPoint])					ifTrue: [points add: point. true]					ifFalse: [false]]].	objects isEmpty		ifTrue: [^nil].	objects size = 1		ifTrue: [^objects first].	sorted := (1 to: points size) asSortedCollection: [:a :b | (firstPoint dist: (points at: a)) <= (firstPoint dist: (points at: b))].	^objects at: sorted first! !!AvWaypointPlanner methodsFor: 'private-planning' stamp: 'Jon 11/29/2004 13:06'!movePointAt: index toAvoid: object	| point previousPoint objectCorners goodCorners |	point := path at: index.	previousPoint := path at: index - 1.	objectCorners := object points collect: [:each | each mapPoint].	goodCorners := objectCorners reject: [:eachPoint |		(previousPoint dist: eachPoint) <= 2 or: [			(self object: object intersectsWithoutTouchingEnds: previousPoint and: eachPoint)]].	goodCorners := goodCorners reject: [:each | each = point].	goodCorners := goodCorners asSortedCollection: [:a :b |		(a dist: point) <= (b dist: point)].	^goodCorners isEmpty		ifTrue: [nil]		ifFalse: [path at: index put: goodCorners first]! !!AvWaypointPlanner methodsFor: 'private-planning' stamp: 'Jon 11/29/2004 13:03'!object: object intersectsWithoutTouchingEnds: firstPoint and: secondPoint	| point |	point := self findIntersectionPointFrom: firstPoint to: secondPoint in: object.	^point notNil and: [point ~= firstPoint and: [point ~= secondPoint]]! !!AvWaypointPlanner methodsFor: 'private-planning' stamp: 'Jon 11/29/2004 13:28'!replanBetween: firstPoint and: secondPoint	| object |	path size > 500		ifTrue: [^false].	(object := self mapObjectIntersecting: firstPoint and: secondPoint) notNil		ifTrue: [			| index currentLocation |			index := path indexOf: secondPoint.			currentLocation := self findIntersectionPointFrom: firstPoint to: secondPoint in: object.			currentLocation isNil				ifTrue: [^true].			path add: currentLocation before: secondPoint.			currentLocation := self 				movePointAt: index				toAvoid: object.			currentLocation isNil | (currentLocation = firstPoint) | (currentLocation = secondPoint)				ifTrue: [^false].			^(self replanBetween: firstPoint and: currentLocation)				ifTrue: [self replanBetween: currentLocation and: secondPoint]				ifFalse: [false]].	^true! !!AvWaypointPlanner methodsFor: 'private-planning' stamp: 'jon 10/14/2004 14:18'!simplifyPath: aPath	aPath size < 3		ifTrue: [^aPath].	1 to: aPath size - 2 do: [:index |		| first third |		first := aPath at: index.		third := aPath at: index + 2.		(self mapObjectIntersecting: first and: third) isNil			ifTrue: [^self simplifyPath: (aPath copyFrom: 1 to: index), (aPath copyFrom: index + 2 to: aPath size)]].	^aPath! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvWaypointPlanner class	instanceVariableNames: ''!!AvWaypointPlanner class methodsFor: 'instance creation' stamp: 'jon 10/13/2004 21:50'!fromForm: mapForm	^self new		map: mapForm;		yourself! !Object subclass: #AvMap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Tracker/Map'!!AvMap commentStamp: '<historical>' prior: 0!An AvMap is an abstract class that represents the area a mission takes place in.!Object subclass: #AvMapObject	instanceVariableNames: 'name timestamp properties note'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Tracker/Map'!!AvMapObject commentStamp: 'Jon 1/5/2006 15:22' prior: 0!An AvMapObject represents a single object of interest in the world.Instance Variables:	name:				<String>	timestamp:			<DateAndTime>	note:				<String>	properties:			<Dictionary key: <Symbol> value: <Object>>name	- the name of the map entrytimestamp	- the date/time the map object was originally creatednote	- textual information either generated or added later regarding this map objectproperties	- contains specific attributes of the object	- may include things like color, type, etc!!AvMapObject methodsFor: 'initializing' stamp: 'jon 11/17/2004 18:06'!initialize	"Here for compatibility with older versions of Squeak..."! !!AvMapObject methodsFor: 'accessing' stamp: 'jon 11/17/2004 18:06'!addPropertyNamed: propertyName withValue: value	self properties at: propertyName put: value! !!AvMapObject methodsFor: 'accessing' stamp: 'jon 11/17/2004 18:08'!hasPropertyNamed: propertyName	properties isNil		ifTrue: [^false].	^properties includesKey: propertyName! !!AvMapObject methodsFor: 'accessing' stamp: 'jon 11/17/2004 18:05'!markDeleted	self addPropertyNamed: #deleted withValue: true! !!AvMapObject methodsFor: 'accessing' stamp: 'jon 11/17/2004 18:05'!markNotDeleted	self removePropertyNamed: #deleted! !!AvMapObject methodsFor: 'accessing' stamp: 'jon 10/16/2004 13:14'!name	^name! !!AvMapObject methodsFor: 'accessing' stamp: 'jon 10/16/2004 13:14'!name: aString	name := aString! !!AvMapObject methodsFor: 'accessing' stamp: 'jon 10/14/2004 21:18'!note	^ note! !!AvMapObject methodsFor: 'accessing' stamp: 'jon 10/14/2004 21:18'!note: aString	"Set the value of note to the given string."	note := aString! !!AvMapObject methodsFor: 'accessing' stamp: 'jon 11/17/2004 18:07'!properties	properties isNil		ifTrue: [properties := Dictionary new].	^properties! !!AvMapObject methodsFor: 'accessing' stamp: 'jon 11/20/2004 21:52'!propertyNamed: propertyName	properties isNil		ifTrue: [^nil].	^properties at: propertyName! !!AvMapObject methodsFor: 'accessing' stamp: 'jon 11/17/2004 18:06'!removePropertyNamed: propertyName	self properties removeKey: propertyName ifAbsent: []! !!AvMapObject methodsFor: 'accessing' stamp: 'jon 10/14/2004 21:18'!timestamp	^ timestamp! !!AvMapObject methodsFor: 'testing' stamp: 'jon 11/16/2004 17:43'!isArea	^false! !!AvMapObject methodsFor: 'testing' stamp: 'jon 11/17/2004 18:07'!isDeleted	^self hasPropertyNamed: #deleted! !!AvMapObject methodsFor: 'testing' stamp: 'jon 11/15/2004 12:52'!isLocation	^false! !!AvMapObject methodsFor: 'testing' stamp: 'jon 11/15/2004 12:52'!isPath	^false! !!AvMapObject methodsFor: 'testing' stamp: 'Jon 11/29/2004 12:24'!isPointMapObject	^false! !!AvMapObject methodsFor: 'dragging' stamp: 'jon 11/21/2004 09:42'!handleDragFrom: mousePoint using: translateFromScreenToMapBlock displayingWith: displayBlock useSlopArea: slopFlag	| command originalPosition endPosition moved originalMousePoint offsets delay dragPoints |	command := AvEditorCommand new.	originalPosition := self undoPosition.	originalMousePoint := translateFromScreenToMapBlock value: mousePoint.	dragPoints := self closestPointsTo: originalMousePoint.	offsets := dragPoints collect: [:each | each mapPoint - originalMousePoint].	moved := slopFlag not.	delay := Delay forMilliseconds: 50.	[Sensor anyButtonPressed] whileTrue: [		| current |		current := translateFromScreenToMapBlock value: Sensor cursorPoint.		(moved not and: [(originalMousePoint dist: current) <= 1])			ifTrue: [current := originalMousePoint]			ifFalse: [moved := true].		dragPoints with: offsets do: [:eachPoint :eachOffset | eachPoint mapPoint: current + eachOffset].		displayBlock value.		delay wait].	endPosition := self undoPosition.	^moved		ifTrue: [			command				name: 'drag ', self dragType;				undoBlock: [self setPositionFrom: originalPosition];				redoBlock: [self setPositionFrom: endPosition];				yourself]		ifFalse: [nil].! !!AvMapObject methodsFor: 'printing' stamp: 'Jon 2/22/2005 09:55'!printOn: aStream	aStream		nextPutAll: self class descriptiveTitle;		nextPutAll: ' (';		nextPutAll: self name.	(self note notNil and: [self note notEmpty])		ifTrue: [			aStream 				nextPutAll: ' - ';				nextPutAll: self note].	aStream nextPut: $)! !!AvMapObject methodsFor: 'private' stamp: 'jon 10/14/2004 21:17'!setTimestamp	timestamp := DateAndTime now! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvMapObject class	instanceVariableNames: ''!!AvMapObject class methodsFor: 'instance creation' stamp: 'jon 10/16/2004 13:14'!newAt: avPosition named: aString	"Answer a new instance of the receiver, initialized to the given position and name."	^self new		setTimestamp;		name: aString;		position: avPosition;		yourself.! !!AvMapObject class methodsFor: 'instance creation' stamp: 'jon 10/16/2004 13:14'!newX: xCoordinate y: yCoordinate named: aString	"Answer a new instance of the receiver, initialized to the given position and name."	^self		newAt: (AvPosition x: xCoordinate y: yCoordinate)		named: aString! !!AvMapObject class methodsFor: 'accessing' stamp: 'Jon 2/22/2005 09:53'!descriptiveTitle	^self name! !AvMap subclass: #AvNavigationMap	instanceVariableNames: 'mapEntries mapExtent southWestCoordinate northEastCoordinate surfaceMap surfaceMapName offsetHeading'	classVariableNames: 'SurfaceMapColors'	poolDictionaries: ''	category: 'Av-Tracker/Map'!!AvNavigationMap commentStamp: '<historical>' prior: 0!An AvNavigationMap is a sparse grid-based map that contains objects of interest in the world. In general, it is assumed that the grid a navigation map is based on is aligned with the cardinal compass points. X increases to the east, and Y increases to the north.Instance Variables:	mapEntries:				<Array of: <Array of: <OrderedCollection of: <AvMapEntry>>>>	mapExtent:					<Point>	southEastCoordinate:		<AvGpsCoordinate>	northWestCoordinate:		<AvGpsCoordinate>	surfaceMap:				<Form>mapEntries	- contains, for each discrete (X, Y) grid location, an ordered collection of map entries	- the first level array represents the X coordinate	- the second level array represents the Y coordinate.mapExtent	- the extent of the map, in metresnorthEastCoordinate, southWestCoordinate	- gps coordinates of the north east & south west corners of the map	- the southWestCoordinate is where the map origin (0,0) issurfaceMap	- contains a form that encodes surface features (grass, dirt, pavement, no-go, etc)!!AvNavigationMap methodsFor: 'initializing' stamp: 'jon 11/16/2004 16:59'!initialize	mapEntries := OrderedCollection new.	offsetHeading := 0.0.	super initialize.! !!AvNavigationMap methodsFor: 'accessing' stamp: 'jon 10/14/2004 20:40'!mapEntries	^ mapEntries! !!AvNavigationMap methodsFor: 'accessing' stamp: 'jon 11/13/2004 15:53'!mapEntries: aCollection	mapEntries := aCollection! !!AvNavigationMap methodsFor: 'accessing' stamp: 'jon 10/14/2004 20:44'!mapExtent	^ mapExtent! !!AvNavigationMap methodsFor: 'accessing' stamp: 'Jon 11/29/2004 12:23'!mapObjectNamed: objectName	^mapEntries		detect: [:each | each name = objectName]		ifNone: [nil].! !!AvNavigationMap methodsFor: 'accessing' stamp: 'jon 10/14/2004 20:44'!northEastCoordinate	^ northEastCoordinate! !!AvNavigationMap methodsFor: 'accessing' stamp: 'jon 10/14/2004 20:45'!northEastCoordinate: anAvGpsCoordinate	"Set the value of northEastCoordinate to the given gps coordinate."	northEastCoordinate := anAvGpsCoordinate! !!AvNavigationMap methodsFor: 'accessing' stamp: 'jon 11/16/2004 16:58'!offsetHeading	^offsetHeading! !!AvNavigationMap methodsFor: 'accessing' stamp: 'jon 11/16/2004 16:59'!offsetHeading: aNumber	offsetHeading := aNumber! !!AvNavigationMap methodsFor: 'accessing' stamp: 'jon 10/20/2004 22:41'!southWestCoordinate	^ southWestCoordinate! !!AvNavigationMap methodsFor: 'accessing' stamp: 'jon 10/20/2004 22:41'!southWestCoordinate: anAvGpsCoordinate	"Set the value of southWestCoordinate to the given gps coordinate."	southWestCoordinate := anAvGpsCoordinate! !!AvNavigationMap methodsFor: 'accessing' stamp: 'jon 10/14/2004 20:45'!surfaceMap	^ surfaceMap! !!AvNavigationMap methodsFor: 'accessing' stamp: 'jon 10/14/2004 20:46'!surfaceMap: aForm	"Set the value of surfaceMap to the given form, which contains information about the surface of the drivable surface."	surfaceMap := aForm! !!AvNavigationMap methodsFor: 'accessing' stamp: 'jon 11/13/2004 16:17'!surfaceMapName	^surfaceMapName! !!AvNavigationMap methodsFor: 'accessing' stamp: 'jon 11/13/2004 16:17'!surfaceMapName: aString	surfaceMapName := aString! !!AvNavigationMap methodsFor: 'map entries' stamp: 'Jon 12/29/2005 20:41'!addEntry: mapEntry	mapEntries add: mapEntry! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvNavigationMap class	instanceVariableNames: ''!!AvNavigationMap class methodsFor: 'surface map' stamp: 'jon 10/12/2004 21:15'!grass	^#grass! !!AvNavigationMap class methodsFor: 'surface map' stamp: 'jon 10/12/2004 21:14'!initializeSurfaceMapColors	"AvNavigationMap initializeSurfaceMapColors"	SurfaceMapColors := Dictionary new		at: Color red put: self nogo;		at: Color green put: self grass;		at: Color magenta put: self pavement;		at: Color blue put: self raisedArea;		at: Color yellow put: self ramp;		yourself! !!AvNavigationMap class methodsFor: 'surface map' stamp: 'jon 10/12/2004 21:15'!nogo	^#nogo! !!AvNavigationMap class methodsFor: 'surface map' stamp: 'jon 10/12/2004 21:15'!pavement	^#pavement! !!AvNavigationMap class methodsFor: 'surface map' stamp: 'jon 10/12/2004 21:15'!raisedArea	^#raisedArea! !!AvNavigationMap class methodsFor: 'surface map' stamp: 'jon 10/12/2004 21:15'!ramp	^#ramp! !!AvNavigationMap class methodsFor: 'surface map' stamp: 'jon 10/12/2004 21:12'!surfaceMapColors	"AvNavigationMap surfaceMapColors"	SurfaceMapColors isNil		ifTrue: [self initializeSurfaceMapColors].	^SurfaceMapColors! !!AvNavigationMap class methodsFor: 'surface map' stamp: 'jon 10/12/2004 21:14'!surfaceMapSymbolFor: color	^self surfaceMapColors at: color ifAbsent: [#unknown].! !AvMap subclass: #AvOverviewMap	instanceVariableNames: 'image northWestCoordinate northEastCoordinate'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Tracker/Map'!AvMapObject subclass: #AvPath	instanceVariableNames: 'points'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Tracker/Map'!!AvPath commentStamp: 'jon 11/17/2004 16:55' prior: 0!An AvPath is a map object that describes a series of line segments tracing out a path or route on the map.Instance Variables	points:		<OrderedCollection of: <AvPosition>>points	- a collection of position points that make up the end points of the line segments the receiver describes!!AvPath methodsFor: 'initializing' stamp: 'jon 11/16/2004 11:46'!initialize	points := OrderedCollection new.	super initialize.! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/10/2004 21:51'!addPoint: avPosition	points add: avPosition! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/11/2004 05:23'!centerPoint	^(points		inject: 0 @ 0		into: [:sum :each | sum + each mapPoint]) // points size! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/10/2004 22:20'!closestPointTo: mapPoint	| min |	min := points first.	points do: [:each |		(each mapPoint dist: mapPoint) < (min mapPoint dist: mapPoint)			ifTrue: [min := each]].	^min! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/11/2004 05:50'!closestPointsTo: mapPoint	| point |	point := self closestPointTo: mapPoint.	(point notNil and: [(point mapPoint dist: mapPoint) < 2])		ifTrue: [^Array with: point].	1 to: points size - 1 do: [:index |		| lineMatch |		lineMatch := mapPoint nearestPointOnLineFrom: (points at: index) mapPoint to: (points at: index + 1) mapPoint.		(mapPoint dist: lineMatch) < 2			ifTrue: [^Array with: (points at: index) with: (points at: index + 1)]].	^#()! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/11/2004 05:50'!distanceTo: mapPoint	| closePoints |	closePoints := self closestPointsTo: mapPoint.	closePoints isEmpty		ifTrue: [^10000].	closePoints size = 1		ifTrue: [^closePoints first mapPoint dist: mapPoint].	^(mapPoint		nearestPointOnLineFrom: closePoints first mapPoint		to: closePoints last mapPoint) dist: mapPoint! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/12/2004 16:56'!dragType	^'path'! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/17/2004 12:24'!length	"Answer the length of the receiver, in meters."	| length |	length := 0.0.	self segmentsDo: [:firstPoint :secondPoint |		length := length + (firstPoint mapPoint dist: secondPoint mapPoint)].	^length! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/21/2004 15:03'!minimumPointCount	^2! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/12/2004 12:18'!moveBy: offset	points do: [:each |		each mapPoint: each mapPoint + offset].! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/10/2004 21:50'!points	^points! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/10/2004 21:50'!points: aCollection	points := aCollection! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/17/2004 12:25'!segmentsDo: aBlock	points size < 2		ifTrue: [^self].	1 to: points size - 1 do: [:eachIndex |		aBlock value: (points at: eachIndex) value: (points at: eachIndex + 1)].! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/12/2004 14:12'!setPositionFrom: aCollection	points := aCollection! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/21/2004 08:29'!size	^points size! !!AvPath methodsFor: 'accessing' stamp: 'jon 11/12/2004 14:13'!undoPosition	^points collect: [:each | each copy]! !!AvPath methodsFor: 'testing' stamp: 'jon 11/10/2004 21:58'!isEmpty	^points isEmpty! !!AvPath methodsFor: 'testing' stamp: 'jon 11/12/2004 08:45'!isPath	^true! !!AvPath methodsFor: 'drawing' stamp: 'Jon 12/27/2005 23:10'!drawOn: aCanvas translateBy: translateBlock selected: selectedSet	| selected |	self isEmpty		ifTrue: [^self].	selected := selectedSet includes: self.	1 to: points size - 1 do: [:eachIndex |		| point nextPoint |		point := points at: eachIndex.		nextPoint := eachIndex = points size			ifTrue: [nil]			ifFalse: [points at: eachIndex + 1].		aCanvas			line: (translateBlock value: point mapPoint)			to: (translateBlock value: nextPoint mapPoint)			width: (selected ifTrue: [2] ifFalse: [1])			color: Color blue veryMuchLighter].	points do: [:each |		| box |		box := (0 @ 0 extent: 5 @ 5) align: 2 @ 2 with: (translateBlock value: each mapPoint).		selected			ifTrue: [aCanvas frameAndFillRectangle: box fillColor: Color green borderWidth: 1 borderColor: Color red]			ifFalse: [aCanvas frameAndFillRectangle: box fillColor: Color green borderWidth: 1 borderColor: Color black]].! !!AvPath methodsFor: 'drawing' stamp: 'jon 11/12/2004 10:01'!drawOnForm: aForm translateBy: translateBlock clipTo: clipBox selected: selected	| line |	self isEmpty		ifTrue: [^self].	line := (Form extent: 1 @ 1 depth: 16)		fillColor: Color blue veryMuchLighter;		yourself.	1 to: points size - 1 do: [:eachIndex |		| point nextPoint |		point := points at: eachIndex.		nextPoint := eachIndex = points size			ifTrue: [nil]			ifFalse: [points at: eachIndex + 1].		aForm			drawLine: line			from: (translateBlock value: point mapPoint)			to: (translateBlock value: nextPoint mapPoint)			clippingBox: clipBox			rule: Form over			fillColor: nil].	points do: [:each |		| box |		box := (0 @ 0 extent: 3 @ 3) align: 1 @ 1 with: (translateBlock value: each mapPoint).		box := box intersect: clipBox.		aForm fill: box fillColor: Color green.		selected			ifTrue: [aForm border: ((box expandBy: 1) intersect: clipBox) width: 1 fillColor: Color red]].! !!AvPath methodsFor: 'point editing' stamp: 'jon 11/21/2004 15:03'!deletePointAt: mousePoint using: translateFromScreenToMapBlock	| command original final mapPoint point |	command := AvEditorCommand new.	original := self undoPosition.	mapPoint := translateFromScreenToMapBlock value: mousePoint.	point := self closestPointTo: mapPoint.	point isNil		ifTrue: [^nil].	self size = self minimumPointCount		ifTrue: [^nil].	points remove: point.	final := self undoPosition.	^command		name: 'delete point from ', self dragType;		undoBlock: [self setPositionFrom: original];		redoBlock: [self setPositionFrom: final];		yourself! !!AvPath methodsFor: 'point editing' stamp: 'jon 11/21/2004 14:58'!insertPointAt: mousePoint using: translateFromScreenToMapBlock	| command original final mapPoint segmentPoints |	command := AvEditorCommand new.	original := self undoPosition.	mapPoint := translateFromScreenToMapBlock value: mousePoint.	segmentPoints := self closestPointsTo: mapPoint.	segmentPoints size = 2		ifFalse: [^nil].	points add: (AvPosition fromPoint: mapPoint) after: segmentPoints first.	final := self undoPosition.	^command		name: 'insert point on ', self dragType;		undoBlock: [self setPositionFrom: original];		redoBlock: [self setPositionFrom: final];		yourself! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvPath class	instanceVariableNames: ''!!AvPath class methodsFor: 'accessing' stamp: 'Jon 2/22/2005 09:54'!descriptiveTitle	^'Path'! !AvPath subclass: #AvArea	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Tracker/Map'!!AvArea commentStamp: 'jon 11/17/2004 16:50' prior: 0!An AvArea is a map object that describes a polygonal area of the map.!!AvArea methodsFor: 'accessing' stamp: 'Jon 11/28/2004 09:56'!boundingBox	^Rectangle encompassing: (points collect: [:each | each mapPoint])! !!AvArea methodsFor: 'accessing' stamp: 'jon 11/21/2004 14:54'!closestPointsTo: mapPoint	| point myPoints |	point := self closestPointTo: mapPoint.	(point notNil and: [(point mapPoint dist: mapPoint) < 2])		ifTrue: [^Array with: point].	myPoints := points, (Array with: points first).	1 to: points size do: [:index |		| lineMatch |		lineMatch := mapPoint nearestPointOnLineFrom: (myPoints at: index) mapPoint to: (myPoints at: index + 1) mapPoint.		(mapPoint dist: lineMatch) < 2			ifTrue: [^Array with: (myPoints at: index) with: (myPoints at: index + 1)]].	^#()! !!AvArea methodsFor: 'accessing' stamp: 'jon 11/21/2004 14:59'!dragType	^'area'! !!AvArea methodsFor: 'accessing' stamp: 'Jon 11/29/2004 12:37'!lineSegments	"Answer a collection of LineSegment objects that make up each of the receiver's sides."	| segments myPoints |	myPoints := points, (Array with: points first).	segments := OrderedCollection new.	1 to: points size do: [:index |		segments add: (LineSegment from: (myPoints at: index) mapPoint to: (myPoints at: index + 1) mapPoint)].	^segments! !!AvArea methodsFor: 'accessing' stamp: 'jon 11/21/2004 15:03'!minimumPointCount	^3! !!AvArea methodsFor: 'testing' stamp: 'jon 11/21/2004 08:29'!hasAtLeastThreePoints	^self size >= 3! !!AvArea methodsFor: 'testing' stamp: 'jon 11/16/2004 11:48'!isArea	^true! !!AvArea methodsFor: 'testing' stamp: 'jon 11/16/2004 11:48'!isPath	^false! !!AvArea methodsFor: 'drawing' stamp: 'Jon 12/28/2005 07:35'!drawOn: aCanvas translateBy: translateBlock selected: selectedSet	| selected |	self isEmpty		ifTrue: [^self].	selected := selectedSet includes: self.	aCanvas		drawPolygon: (points collect: [:each | translateBlock value: each mapPoint])		color: (Color gray veryMuchLighter alpha: 0.3)		borderWidth: 1		borderColor: (selected ifTrue: [Color blue veryMuchLighter] ifFalse: [Color black]).	points do: [:each |		| box |		box := (0 @ 0 extent: 5 @ 5) align: 2 @ 2 with: (translateBlock value: each mapPoint).		selected			ifTrue: [aCanvas frameAndFillRectangle: box fillColor: Color green borderWidth: 1 borderColor: Color red]			ifFalse: [aCanvas frameAndFillRectangle: box  fillColor: Color green borderWidth: 1 borderColor: Color black]].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvArea class	instanceVariableNames: ''!!AvArea class methodsFor: 'accessing' stamp: 'Jon 2/22/2005 09:54'!descriptiveTitle	^'Area'! !AvMapObject subclass: #AvPointMapObject	instanceVariableNames: 'position gpsCoordinate'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Tracker/Map'!!AvPointMapObject commentStamp: 'jon 11/17/2004 16:50' prior: 0!An AvPointMapObject is a map object that resides at one particular place.Instance Variables	gpsCoordinate:	<AvGpsCoordinate>	position:			<AvPosition>gpsCoordinate	- this is optional, and may be nil	- if set, it holds the gps coordinate that describes the receiver's locationposition	- the position on the map!!AvPointMapObject methodsFor: 'accessing' stamp: 'jon 11/13/2004 13:41'!centerPoint	^position mapPoint! !!AvPointMapObject methodsFor: 'accessing' stamp: 'jon 11/13/2004 14:06'!gpsCoordinate	^ gpsCoordinate! !!AvPointMapObject methodsFor: 'accessing' stamp: 'jon 11/13/2004 14:06'!gpsCoordinate: anAvGpsCoordinate	"Set the value of gpsCoordinate to the given gps coordinate."	gpsCoordinate := anAvGpsCoordinate! !!AvPointMapObject methodsFor: 'accessing' stamp: 'jon 11/13/2004 14:06'!position	^ position! !!AvPointMapObject methodsFor: 'accessing' stamp: 'jon 11/13/2004 14:05'!position: avPosition	position := avPosition! !!AvPointMapObject methodsFor: 'accessing' stamp: 'jon 11/13/2004 14:05'!undoPosition	^position copy! !!AvPointMapObject methodsFor: 'geometry' stamp: 'jon 11/13/2004 14:03'!closestPointsTo: mapPoint	^Array with: self position! !!AvPointMapObject methodsFor: 'geometry' stamp: 'jon 11/13/2004 14:04'!computePositionFromOrigin: originLocation	"Compute our position relative to the given origin location, which must be the SW corner of the map.	Assume both GPS coordinates have been set."	| distance bearing |	distance := originLocation gpsCoordinate distanceTo: self gpsCoordinate.	bearing := originLocation gpsCoordinate bearingTo: self gpsCoordinate.	position := AvPosition fromPoint: (Point r: distance degrees: (90 - bearing) \\ 360)! !!AvPointMapObject methodsFor: 'geometry' stamp: 'jon 11/13/2004 14:04'!distanceTo: mapPoint	^self position mapPoint dist: mapPoint! !!AvPointMapObject methodsFor: 'positioning' stamp: 'jon 11/13/2004 14:04'!moveBy: offset	position := position + offset! !!AvPointMapObject methodsFor: 'positioning' stamp: 'jon 11/13/2004 14:05'!setPositionFrom: avPosition	self position: avPosition! !!AvPointMapObject methodsFor: 'testing' stamp: 'Jon 11/29/2004 12:24'!isPointMapObject	^true! !!AvPointMapObject methodsFor: 'printing' stamp: 'jon 11/13/2004 15:59'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self name;		nextPutAll: ' - ';		print: self position.	(self note notNil and: [self note notEmpty])		ifTrue: [			aStream 				nextPutAll: ' - ';				nextPutAll: self note].	aStream nextPut: $)! !!AvPointMapObject methodsFor: 'printing' stamp: 'Jon 12/29/2005 20:44'!shortPrintOn: aStream	aStream		nextPut: $<;		nextPutAll: self name;		nextPutAll: ' - ';		print: self position;		nextPut: $>.! !AvPointMapObject subclass: #AvLocation	instanceVariableNames: ''	classVariableNames: 'Locations'	poolDictionaries: ''	category: 'Av-Tracker/Map'!!AvLocation commentStamp: 'jon 11/17/2004 16:51' prior: 0!An AvLocation is a point object on the map.!!AvLocation methodsFor: 'accessing' stamp: 'jon 11/12/2004 16:55'!dragType	^'location'! !!AvLocation methodsFor: 'testing' stamp: 'jon 11/10/2004 12:39'!isLocation	^true! !!AvLocation methodsFor: 'drawing' stamp: 'jon 11/16/2004 11:59'!drawOn: aCanvas translateBy: translateBlock selected: selectedSet	| box |	box := (0 @ 0 extent: 5 @ 5) align: 2 @ 2 with: (translateBlock value: self position mapPoint).	(selectedSet includes: self)		ifTrue: [aCanvas frameAndFillRectangle: box fillColor: Color green borderWidth: 1 borderColor: Color red]		ifFalse: [aCanvas frameAndFillRectangle: box fillColor: Color green borderWidth: 1 borderColor: Color black].! !!AvLocation methodsFor: 'drawing' stamp: 'jon 11/12/2004 10:00'!drawOnForm: aForm translateBy: translateBlock clipTo: clipBox selected: selected	| box |	box := (0 @ 0 extent: 3 @ 3) align: 1 @ 1 with: (translateBlock value: self position mapPoint).	box := box intersect: clipBox.	aForm fill: box fillColor: Color green.	selected		ifTrue: [aForm border: ((box expandBy: 1) intersect: clipBox) width: 1 fillColor: Color red].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvLocation class	instanceVariableNames: ''!!AvLocation class methodsFor: 'accessing' stamp: 'Jon 2/22/2005 09:54'!descriptiveTitle	^'Location'! !!AvLocation class methodsFor: 'locations' stamp: 'jon 10/17/2004 14:37'!correctDirectBackyardPositions	"AvLocation correctDirectBackyardPositions"	| locations origin |	AvLocation initializeDirectBackyardLocations.	locations := self locations.	origin := (locations at: 'SW Corner') position.	(locations at: 'NW Corner') position: origin + (Point r: 45.5 degrees: 270 - 185).	(locations at: 'SE Corner') position: origin + (Point r: 65.2 degrees: 270 - 270).	(locations at: 'N Driveway Corner')		position: (locations at: 'SE Corner') position + (Point r: 12.7 degrees: 270 - 190).	(locations at: 'Gate Corner')		position: (locations at: 'N Driveway Corner') position + (Point r: 26.4 degrees: 270 - 100).	(locations at: 'NE Corner')		position: (locations at: 'Gate Corner') position + (Point r: 27.0 degrees: 270 - 190).! !!AvLocation class methodsFor: 'locations' stamp: 'jon 10/17/2004 13:05'!initializeBackyardLocations	"AvLocation initializeBackyardLocations"	| origin |	Locations := Dictionary new		at: 'SW Corner' put: (origin := self new			name: 'SW Corner';			position: (AvPosition fromPoint: 0 @ 0);			gpsCoordinate: (AvGpsCoordinate latitude: 43.02163 longitude: 80.37630);			yourself);		at: 'NW Corner' put: (self new			name: 'NW Corner';			gpsCoordinate: (AvGpsCoordinate latitude: 43.02222 longitude: 80.37676);			computePositionFromOrigin: origin;			yourself);		at: 'NE Corner' put: (self new			name: 'NE Corner';			gpsCoordinate: (AvGpsCoordinate latitude: 43.02214 longitude: 80.37576);			computePositionFromOrigin: origin;			yourself);		at: 'Gate Corner' put: (self new			name: 'Gate Corner';			gpsCoordinate: (AvGpsCoordinate latitude: 43.02188 longitude: 80.37583);			computePositionFromOrigin: origin;			yourself);		at: 'N Driveway Corner' put: (self new			name: 'N Driveway Corner';			gpsCoordinate: (AvGpsCoordinate latitude: 43.02179 longitude: 80.37559);			computePositionFromOrigin: origin;			yourself);		at: 'SE Corner' put: (self new			name: 'SE Corner';			gpsCoordinate: (AvGpsCoordinate latitude: 43.02174 longitude: 80.37554);			computePositionFromOrigin: origin;			yourself);		yourself! !!AvLocation class methodsFor: 'locations' stamp: 'jon 10/17/2004 14:37'!initializeDirectBackyardLocations	"AvLocation initializeDirectBackyardLocations"	Locations := Dictionary new		at: 'SW Corner' put: (self new			name: 'SW Corner';			position: (AvPosition fromPoint: 0 @ 0);			gpsCoordinate: (AvGpsCoordinate latitude: 43.02163 longitude: 80.37630);			yourself);		at: 'NW Corner' put: (self new			name: 'NW Corner';			gpsCoordinate: (AvGpsCoordinate latitude: 43.02222 longitude: 80.37676);			position: (AvPosition fromPoint: 0 @ 45.5);			yourself);		at: 'NE Corner' put: (self new			name: 'NE Corner';			gpsCoordinate: (AvGpsCoordinate latitude: 43.02214 longitude: 80.37576);			position: (AvPosition fromPoint: 36.4 @ 45.5);			yourself);		at: 'Gate Corner' put: (self new			name: 'Gate Corner';			gpsCoordinate: (AvGpsCoordinate latitude: 43.02188 longitude: 80.37583);			position: (AvPosition fromPoint: 36.4 @ 15.5);			yourself);		at: 'N Driveway Corner' put: (self new			name: 'N Driveway Corner';			gpsCoordinate: (AvGpsCoordinate latitude: 43.02179 longitude: 80.37559);			position: (AvPosition fromPoint: 65.2 @ 12.7);			yourself);		at: 'SE Corner' put: (self new			name: 'SE Corner';			gpsCoordinate: (AvGpsCoordinate latitude: 43.02174 longitude: 80.37554);			position: (AvPosition fromPoint: 65.2 @ 0);			yourself);		yourself! !!AvLocation class methodsFor: 'locations' stamp: 'jon 10/17/2004 08:42'!initializeRoboMagellanLocations	"AvLocation initializeRoboMagellanLocations"	| origin |	Locations := Dictionary new		at: 'SW Corner' put: (origin := self new			name: 'SW Corner';			position: (AvPosition fromPoint: 0 @ 0);			gpsCoordinate: (AvGpsCoordinate latitude: 47.620075 longitude: 122.351889);			yourself);		at: 'Start' put: (self new			name: 'Start';			gpsCoordinate: (AvGpsCoordinate latitude: 47.620644 longitude: 122.350684);			computePositionFromOrigin: origin;			yourself);		at: 'Finish' put: (self new			name: 'Finish';			gpsCoordinate: (AvGpsCoordinate latitude: 47.620569 longitude: 122.351829);			computePositionFromOrigin: origin;			yourself);		at: 'Base of North Ramp' put: (self new			name: 'Base of North Ramp';			gpsCoordinate: (AvGpsCoordinate latitude: 47.620573 longitude: 122.350804);			computePositionFromOrigin: origin;			yourself);		at: 'Top of North Ramp' put: (self new			name: 'Top of North Ramp';			gpsCoordinate: (AvGpsCoordinate latitude: 47.620528 longitude: 122.350804);			computePositionFromOrigin: origin;			yourself);		at: 'Bonus Cone 1' put: (self new			name: 'Bonus Cone 1';			gpsCoordinate: (AvGpsCoordinate latitude: 47.620465 longitude: 122.350819);			computePositionFromOrigin: origin;			yourself);		at: 'Bonus Cone 2' put: (self new			name: 'Bonus Cone 2';			gpsCoordinate: (AvGpsCoordinate latitude: 47.620152 longitude: 122.351249);			computePositionFromOrigin: origin;			yourself);		at: 'Bonus Cone 3' put: (self new			name: 'Bonus Cone 3';			gpsCoordinate: (AvGpsCoordinate latitude: 47.620620 longitude: 122.351283);			computePositionFromOrigin: origin;			yourself);		yourself! !!AvLocation class methodsFor: 'locations' stamp: 'jon 11/9/2004 21:59'!locationNear: mapPoint	| closeLocations min |	closeLocations := self locations values asArray select: [:each | (each position mapPoint dist: mapPoint) <= 2].	closeLocations isEmpty		ifTrue: [^nil].	closeLocations size = 1		ifTrue: [^closeLocations first].	min := closeLocations first.	closeLocations do: [:each |		(mapPoint dist: each position mapPoint) < (mapPoint dist: min position mapPoint)			ifTrue: [min := each]].	^min! !!AvLocation class methodsFor: 'locations' stamp: 'jon 10/17/2004 12:30'!locations	"AvLocation locations"	^Locations! !!AvLocation class methodsFor: 'locations' stamp: 'jon 11/9/2004 12:38'!newName	"AvLocation newName"	| names numbers |	names := self locations keys select: [:each | each includesSubString: 'Unnamed'].	numbers := names collect: [:each | (each subStrings: ' ') last asNumber].	^numbers isEmpty		ifTrue: ['Unnamed 1']		ifFalse: ['Unnamed ', (numbers asSortedCollection last + 1) printString]! !!AvLocation class methodsFor: 'locations' stamp: 'jon 11/9/2004 22:01'!removeLocation: location	self locations removeKey: location name ifAbsent: [nil]! !!AvLocation class methodsFor: 'locations' stamp: 'jon 10/17/2004 13:13'!testBackyardMap	"AvLocation testBackyardMap"	| locations form offset |	AvLocation initializeBackyardLocations.	locations := self locations.	form := Form extent: 600 @ 500 depth: 32.	form fillColor: Color white.	offset := 40 @ 40.	locations do: [:each |		| box mapPosition formPosition |		mapPosition := each position mapPoint + offset.		formPosition := (mapPosition x * 4) @ (form height - (mapPosition y * 4)).		box := (0 @ 0 extent: 5 @ 5) align: 2 @ 2 with: formPosition.		form fill: box fillColor: Color green].	ImageMorph new		image: form;		openInWorld! !!AvLocation class methodsFor: 'locations' stamp: 'Jon 1/6/2006 12:31'!testDirectBackyardMap	"AvLocation testDirectBackyardMap"	| locations form offset |	AvLocation correctDirectBackyardPositions.	locations := self locations.	form := Form extent: 700 @ 500 depth: 32.	form		fillColor: Color black;		fill: (form boundingBox insetBy: 1) fillColor: Color white.	offset := 10 @ 10.	locations do: [:each |		| box mapPosition formPosition |		mapPosition := each position mapPoint + offset.		formPosition := (mapPosition x * 8) @ (form height - (mapPosition y * 8)).		box := (0 @ 0 extent: 5 @ 5) align: 2 @ 2 with: formPosition.		form fill: box fillColor: Color green].	ImageMorph new		image: form;		openInWorld! !!AvLocation class methodsFor: 'locations' stamp: 'jon 10/24/2004 09:27'!testRoboMagellanMap	"AvLocation testRoboMagellanMap"	| locations form scaleFactor |	AvLocation initializeRoboMagellanLocations.	locations := self locations.	form := Form fromFileNamed: 'CourseMap-PDA.bmp'.	scaleFactor := 2.	locations do: [:each |		| box mapPosition formPosition |		mapPosition := each position mapPoint.		formPosition := (mapPosition x * scaleFactor) @ (form height - (mapPosition y * scaleFactor)).		box := (0 @ 0 extent: 3 @ 3) align: 1 @ 1 with: formPosition.		form fill: box fillColor: Color green].	ImageMorph new		image: form;		openInWorld! !Object subclass: #AvTrackEntry	instanceVariableNames: 'timestamp position heading logEntry'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Tracker/Map'!!AvTrackEntry commentStamp: 'Jon 1/5/2006 10:12' prior: 0!An AvTrackEntry is an abstract class responsible for keeping common information regarding track entries.Instance Variables:	timestamp:		<Integer>	position:			<AvPosition>	logEntry:			<AvLogEntry>timestamp	- contains the millisecond count since the start of the mission	- set from the main mission timerposition	- contains the estimated position of the vehicle at the time the track entry was madelogEntry	- is a reference to the most recent log entry in the av log when the track entry was made	- contains environmental and other information!!AvTrackEntry methodsFor: 'accessing' stamp: 'Jon 1/14/2006 17:17'!heading	^heading! !!AvTrackEntry methodsFor: 'accessing' stamp: 'Jon 1/14/2006 17:17'!heading: aNumber	heading := aNumber! !!AvTrackEntry methodsFor: 'accessing' stamp: 'jon 8/6/2004 15:19'!logEntry	"Answer the log entry that was current when the receiver was created."	^logEntry! !!AvTrackEntry methodsFor: 'accessing' stamp: 'jon 8/6/2004 15:18'!position	"Answer the current position the receiver thinks the auv is at."	^ position! !!AvTrackEntry methodsFor: 'accessing' stamp: 'jon 8/6/2004 15:19'!timestamp	"Answer the value of timestamp, which is in milliseconds since the start of the mission."	^ timestamp! !!AvTrackEntry methodsFor: 'printing' stamp: 'Jon 1/27/2006 12:02'!logCurrentInformationTo: stream	stream nextPutAll: '(pos: '.	self printPositionOn: stream.	stream nextPutAll: ') '.! !!AvTrackEntry methodsFor: 'printing' stamp: 'jon 8/6/2004 15:23'!printOn: aStream	aStream		print: self class;		nextPutAll: ' ('.	self printPositionOn: aStream.	aStream nextPutAll: ' - '.	self printTimestampOn: aStream.	aStream nextPut: $)! !!AvTrackEntry methodsFor: 'printing' stamp: 'Jon 1/15/2006 14:42'!printPositionOn: aStream	position printOn: aStream! !!AvTrackEntry methodsFor: 'printing' stamp: 'jon 8/6/2004 15:24'!printTimestampOn: aStream	aStream nextPutAll: timestamp asStringWithCommas! !!AvTrackEntry methodsFor: 'private' stamp: 'jon 8/10/2004 12:15'!setPosition: aPosition timestamp: anInteger logEntry: aLogEntry	position := aPosition.	timestamp := anInteger.	logEntry := aLogEntry.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvTrackEntry class	instanceVariableNames: ''!!AvTrackEntry class methodsFor: 'instance creation' stamp: 'jon 8/10/2004 12:14'!atLocation: position timestamp: millisecondsSinceStart logEntry: currentLogEntry	^self new		setPosition: position		timestamp: millisecondsSinceStart		logEntry: currentLogEntry! !AvTrackEntry subclass: #AvNavigationTrackEntry	instanceVariableNames: 'extraInformation'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Tracker/Map'!!AvNavigationTrackEntry commentStamp: 'Jon 1/5/2006 09:29' prior: 0!An AvNavigationTrackEntry is an abstract class for track entries in a navigation mapper.Instance Variables:	extraInformation:	<Dictionary>extraInformation	- contains any vehicle-specific information!AvNavigationTrackEntry subclass: #AvAbsoluteNavigationTrackEntry	instanceVariableNames: 'latitude longitude'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Tracker/Map'!!AvAbsoluteNavigationTrackEntry commentStamp: '<historical>' prior: 0!An AvAbsoluteNavigationTrackEntry is one that has an absolute, fixed position associated with it. GPS readings and certain types of terrain recognition can trigger the use of this class.Instance Variables:	latitude:		<Float>	longitude:		<Float>latitude, longitude	- contains the latitude/longitude of the location, in degrees, with the fractional part representing minutes and seconds!AvNavigationTrackEntry subclass: #AvDeadReckonedNavigationTrackEntry	instanceVariableNames: 'leftEncoderCount rightEncoderCount'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Tracker/Map'!!AvDeadReckonedNavigationTrackEntry commentStamp: 'Jon 1/5/2006 09:29' prior: 0!An AvDeadReckonedNavigationTrackEntry is used when the vehicle's position is estimated using dead reckoning.!!AvDeadReckonedNavigationTrackEntry methodsFor: 'accessing' stamp: 'Jon 1/5/2006 09:30'!leftEncoderCount	^leftEncoderCount! !!AvDeadReckonedNavigationTrackEntry methodsFor: 'accessing' stamp: 'Jon 1/5/2006 09:30'!leftEncoderCount: aNumber	leftEncoderCount := aNumber! !!AvDeadReckonedNavigationTrackEntry methodsFor: 'accessing' stamp: 'Jon 1/5/2006 09:30'!rightEncoderCount	^rightEncoderCount! !!AvDeadReckonedNavigationTrackEntry methodsFor: 'accessing' stamp: 'Jon 1/5/2006 09:30'!rightEncoderCount: aNumber	rightEncoderCount := aNumber! !!AvDeadReckonedNavigationTrackEntry methodsFor: 'logging' stamp: 'Jon 1/27/2006 12:03'!logCurrentInformationTo: stream	super logCurrentInformationTo: stream.	stream 		nextPutAll: '(leftEncoder: ';		print: leftEncoderCount;		nextPutAll: ' rightEncoder: ';		print: rightEncoderCount;		nextPutAll: ' heading: ';		print: heading;		nextPutAll: ') '.! !Object subclass: #AvTracker	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Tracker/Map'!!AvTracker commentStamp: '<historical>' prior: 0!An AvTracker is the abstract superclass of all trackers.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvTracker class	instanceVariableNames: ''!!AvTracker class methodsFor: 'lat/long conversion' stamp: 'jon 8/22/2004 22:23'!bearingFrom: firstPosition to: secondPosition	"Answer the bearing, in degrees, between the two given positions. Each position is an	instance of Point, where x contains the latitude, and y the longitude.	Based on the formula at: http://www.movable-type.co.uk/scripts/LatLong.html "	| firstPart secondPart deltaLongitude |	deltaLongitude := secondPosition y - firstPosition y.	firstPart := deltaLongitude degreesToRadians sin negated * secondPosition x degreesToRadians cos.	secondPart := (firstPosition x degreesToRadians cos * secondPosition x degreesToRadians sin)		- (firstPosition x degreesToRadians sin * secondPosition x degreesToRadians cos * deltaLongitude degreesToRadians cos).	^(firstPart arcTan: secondPart) radiansToDegrees! !!AvTracker class methodsFor: 'lat/long conversion' stamp: 'jon 8/22/2004 22:19'!distanceFrom: firstPosition to: secondPosition	"Answer the distance, in meters, between the two given positions. Each position is an	instance of Point, where x contains the latitude, and y the longitude.	Based on the Haversine formula: http://www.movable-type.co.uk/scripts/LatLong.html "	| radius deltaLatitude deltaLongitude alpha km |	radius := 6371.	deltaLatitude := secondPosition x - firstPosition x.	deltaLongitude := secondPosition y - firstPosition y.	alpha := (deltaLatitude / 2) degreesToRadians sin squared		+ (firstPosition x degreesToRadians cos			* secondPosition x degreesToRadians cos			* (deltaLongitude / 2) degreesToRadians sin squared).	km := 2.0 * radius * (alpha sqrt arcTan: (1 - alpha) sqrt).	^km * 1000.0! !!AvTracker class methodsFor: 'lat/long conversion' stamp: 'jon 10/10/2004 09:18'!exampleBearing	"AvMapper exampleBearing"	"First coordinate:	53 09 02N @ 001 50 40W	Second coordinate:	52 12 19N @ 000 08 33W"	| first second |	first := (53 + (9 / 60.0) + (2 / 3600.0)) @ (1 + (50 / 60.0) + (40 / 3600.0)).	second := (52 + (12 / 60.0) + (19 / 3600.0)) @ ((8 / 60.0) + (33 / 3600.0)).	^self bearingFrom: first to: second! !!AvTracker class methodsFor: 'lat/long conversion' stamp: 'jon 10/10/2004 09:18'!exampleDistance	"AvMapper exampleDistance"	"First coordinate:	53 09 02N @ 001 50 40W	Second coordinate:	52 12 19N @ 000 08 33W"	| first second |	first := (53 + (9 / 60.0) + (2 / 3600.0)) @ (1 + (50 / 60.0) + (40 / 3600.0)).	second := (52 + (12 / 60.0) + (19 / 3600.0)) @ ((8 / 60.0) + (33 / 3600.0)).	^(self distanceFrom: first to: second) / 1000.0! !AvTracker subclass: #AvNavigationTracker	instanceVariableNames: 'trackEntries currentPosition vehicleSpecification sensorModel overviewMap navigationMap'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Tracker/Map'!!AvNavigationTracker commentStamp: 'jon 10/27/2004 23:34' prior: 0!An AvNavigationTracker is responsible for keeping track of a vehicle's position, as well as the back-track of where it has been.Instance Variables:	trackEntries: 		<OrderedCollection of: <AvNavigationTrackEntry>>	currentPosition: 	<AvPosition>	sensorModel:		<AvSensorModel>	overviewMap:		<AvOverviewMap>	navigationMap:		<AvNavigationMap>	trackEntries	- contains the ordered list of track entries since the beginning of the mission. 	- is updated whenever state changes, and also at predetermined intervals if state doesn't change often enoughcurrentPosition	- contains the up-to-date, best estimate of the vehicle's current position	- is updated every clock ticksensorModel	- contains all the sensors	- used to figure out the vehicle's pose (orientation) and motion, and thus to compute its position!!AvNavigationTracker methodsFor: 'accessing' stamp: 'jon 10/17/2004 09:02'!currentPosition	^ currentPosition! !!AvNavigationTracker methodsFor: 'accessing' stamp: 'jon 10/17/2004 09:03'!currentPosition: anAvPosition	currentPosition := anAvPosition! !!AvNavigationTracker methodsFor: 'accessing' stamp: 'jon 10/17/2004 09:03'!navigationMap	^ navigationMap! !!AvNavigationTracker methodsFor: 'accessing' stamp: 'jon 10/17/2004 09:03'!navigationMap: anAvNavigationMap	navigationMap := anAvNavigationMap! !!AvNavigationTracker methodsFor: 'accessing' stamp: 'jon 10/17/2004 09:03'!overviewMap	^ overviewMap! !!AvNavigationTracker methodsFor: 'accessing' stamp: 'jon 10/17/2004 09:03'!overviewMap: anAvOverviewMap	overviewMap := anAvOverviewMap! !!AvNavigationTracker methodsFor: 'accessing' stamp: 'jon 10/17/2004 09:03'!sensorModel	^ sensorModel! !!AvNavigationTracker methodsFor: 'accessing' stamp: 'Jon 1/14/2006 17:10'!sensorModel: anAvSensorModel	sensorModel := anAvSensorModel.	(sensorModel sensorNamed: 'encoder') tracker: self.! !!AvNavigationTracker methodsFor: 'accessing' stamp: 'jon 10/17/2004 09:03'!trackEntries	^ trackEntries! !!AvNavigationTracker methodsFor: 'accessing' stamp: 'jon 10/17/2004 09:04'!trackEntries: anOrderedCollection	trackEntries := anOrderedCollection! !!AvNavigationTracker methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:44'!vehicleSpecification: avVehicleSpecification	vehicleSpecification := avVehicleSpecification! !!AvNavigationTracker methodsFor: 'accessing-derived' stamp: 'Jon 1/15/2006 17:31'!compass	^sensorModel sensorNamed: 'compass'! !!AvNavigationTracker methodsFor: 'accessing-derived' stamp: 'Jon 12/23/2005 16:48'!heading	^sensorModel heading! !!AvNavigationTracker methodsFor: 'accessing-derived' stamp: 'Jon 1/5/2006 10:30'!metersPerEncoderCount	^vehicleSpecification metersPerEncoderCount! !!AvNavigationTracker methodsFor: 'accessing-derived' stamp: 'Jon 1/4/2006 15:46'!poseFilter	^sensorModel poseFilter! !!AvNavigationTracker methodsFor: 'accessing-derived' stamp: 'Jon 1/5/2006 10:29'!trackWidth	^vehicleSpecification trackWidth! !!AvNavigationTracker methodsFor: 'encoder updating' stamp: 'Jon 1/28/2006 10:39'!updateEncodersFrom: leftEncoderCount and: rightEncoderCount	"The distance-travelled encoders have been updated. Recalculate our DR-position based on that."	| trackEntry delta computedHeading lastPosition radians newX newY |	"We don't want to do any DR until we have a valid initial heading."	self compass gotFirstReading		ifFalse: [^self].	trackEntries isEmpty		ifTrue: [			delta := 0.0.			computedHeading := self heading. "from the compass"			"At the beginning, the currentPosition is set to the map start location."			lastPosition := currentPosition.			lastPosition isNil				ifTrue: [lastPosition := AvPosition zero]]		ifFalse: [			| lastEntry leftMeters rightMeters difference |			lastEntry := trackEntries last.			leftMeters := (leftEncoderCount - lastEntry leftEncoderCount) * self metersPerEncoderCount.			rightMeters := (rightEncoderCount - lastEntry rightEncoderCount)  * self metersPerEncoderCount.			delta := (rightMeters + leftMeters) / 2.0.			lastPosition := lastEntry position.			computedHeading := trackEntries size \\ 10 = 0				ifTrue: [self heading]				ifFalse: [					(difference := rightMeters - leftMeters) abs < 0.001						ifTrue: [lastEntry heading]						ifFalse: [difference / self trackWidth + lastEntry heading]]].	"Since we use a different coordinate system than standard math, we need to translate our heading..."	radians := (90 - computedHeading) degreesToRadians.	newX := (delta * radians cos + lastPosition mapPoint x) roundTo: 0.0001.	newY := (delta * radians sin + lastPosition mapPoint y) roundTo: 0.0001.	newX abs < 0.0001		 ifTrue: [newX := 0.0].	newY abs < 0.0001		 ifTrue: [newY := 0.0].	currentPosition := AvPosition x: newX y: newY.	trackEntry := (AvDeadReckonedNavigationTrackEntry atLocation: currentPosition timestamp: 0 logEntry: nil)		heading: computedHeading;		leftEncoderCount: leftEncoderCount;		rightEncoderCount: rightEncoderCount;		yourself.	trackEntries add: trackEntry.! !!AvNavigationTracker methodsFor: 'initializing' stamp: 'Jon 1/14/2006 17:11'!initialize	super initialize.	trackEntries := OrderedCollection new.! !!AvNavigationTracker methodsFor: 'logging' stamp: 'Jon 1/27/2006 12:01'!logCurrentInformationTo: stream	trackEntries isEmpty		ifTrue: [^self].	stream nextPutAll: 'DR '.	trackEntries last logCurrentInformationTo: stream.! !AvPointMapObject subclass: #AvWaterMapObject	instanceVariableNames: 'depth waterTemperature'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Tracker/Map'!Object subclass: #AvMotionModel	instanceVariableNames: 'navigatorOutput actuatorModel sensorModel tracker running speedController headingController'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Motion'!!AvMotionModel commentStamp: 'Jon 1/16/2005 08:57' prior: 0!An AvMotionModel is the abstract superclass of all vehicle-specific motion models. A motion model is resposible for translating the navigator output into vehicle-specific motion. A motion model subclass will control the vehicle actuators, watch the vehicle sensors, and make the specific aspects of the vehicle (speed, heading, depth, altitude as applicable) match the navigator output.Instance Variables	actuatorModel:		<AvActuatorModel>	sensorModel:			<AvSensorModel>	navigatorOutput:		<AvNavigatorOutput>	running:				<Boolean>	speedController:		<AvStateMachine | AvExecutionBlock>	headingController:		<AvStateMachine | AvExecutionBlock>actuatorModel	- the controller for all the vehicle's actuatorssensorModel	- the controller for all the vehicle's sensorsnavigatorOutput	- a vehicle-type-specific (ground, underwater, air) subclass of AvNavigatorOutput	- represents what the active navigator wants the vehicle to dorunning	- a boolean flag that indicated whether or not the system is runningspeedController	- the object responsible for making the robot go the speed the navigator requests	- can be a complex state machine, or just a simple execution blockheadingController	- the object responsible for making the robot go the direction the navigator requests	- can be a complex state machine, or just a simple execution block!!AvMotionModel methodsFor: 'initializing' stamp: 'Jon 1/14/2005 12:37'!initialize	super initialize.	running := false.	self 		initializeSpeedController;		initializeHeadingController.! !!AvMotionModel methodsFor: 'accessing' stamp: 'jon 10/26/2004 22:37'!actuatorModel	^ actuatorModel! !!AvMotionModel methodsFor: 'accessing' stamp: 'jon 10/26/2004 22:37'!actuatorModel: anAvActuatorModel	actuatorModel := anAvActuatorModel! !!AvMotionModel methodsFor: 'accessing' stamp: 'Jon 12/5/2004 09:43'!actuatorNamed: aString	^actuatorModel actuatorNamed: aString! !!AvMotionModel methodsFor: 'accessing' stamp: 'Jon 12/4/2004 11:42'!navigatorOutput	^navigatorOutput! !!AvMotionModel methodsFor: 'accessing' stamp: 'Jon 12/4/2004 11:42'!navigatorOutput: anAvNavigatorOutput	navigatorOutput := anAvNavigatorOutput! !!AvMotionModel methodsFor: 'accessing' stamp: 'jon 10/26/2004 22:37'!sensorModel	^ sensorModel! !!AvMotionModel methodsFor: 'accessing' stamp: 'jon 10/26/2004 22:37'!sensorModel: anAvSensorModel	sensorModel := anAvSensorModel! !!AvMotionModel methodsFor: 'accessing' stamp: 'jon 11/23/2004 13:59'!sensorNamed: sensorName	^sensorModel sensorNamed: sensorName! !!AvMotionModel methodsFor: 'accessing' stamp: 'Jon 1/5/2006 10:17'!trackWidth	^self subclassResponsibility! !!AvMotionModel methodsFor: 'accessing' stamp: 'Jon 1/5/2006 09:25'!tracker	^tracker! !!AvMotionModel methodsFor: 'accessing' stamp: 'Jon 1/5/2006 09:26'!tracker: avTracker	tracker := avTracker! !!AvMotionModel methodsFor: 'accessing-derived' stamp: 'Jon 12/23/2005 14:18'!desiredHeading	"Answer the vehicle's desired heading, in degrees."	^navigatorOutput desiredHeading! !!AvMotionModel methodsFor: 'accessing-derived' stamp: 'Jon 12/23/2005 14:18'!desiredSpeed	"Answer the vehicle's desired speed, in meters per second."	^navigatorOutput desiredSpeed! !!AvMotionModel methodsFor: 'accessing-derived' stamp: 'Jon 11/11/2005 12:01'!vehicleHeading	^sensorModel heading! !!AvMotionModel methodsFor: 'accessing-derived' stamp: 'Jon 11/11/2005 12:01'!vehicleSpeed	^sensorModel speed! !!AvMotionModel methodsFor: 'starting/stopping' stamp: 'jon 11/23/2004 15:15'!start	running		ifTrue: [^self].	sensorModel start.	actuatorModel start.	running := true.! !!AvMotionModel methodsFor: 'starting/stopping' stamp: 'jon 11/23/2004 15:15'!stop	running		ifFalse: [^self].	sensorModel stop.	actuatorModel stop.	running := false.! !!AvMotionModel methodsFor: 'testing' stamp: 'jon 11/23/2004 15:16'!isRunning	^running! !!AvMotionModel methodsFor: 'execution' stamp: 'Jon 12/23/2005 16:54'!execute	sensorModel execute.	self		executeSpeed;		executeHeading.! !!AvMotionModel methodsFor: 'private' stamp: 'Jon 1/14/2005 12:38'!executeHeading	headingController execute! !!AvMotionModel methodsFor: 'private' stamp: 'Jon 1/14/2005 12:38'!executeSpeed	speedController execute! !!AvMotionModel methodsFor: 'logging' stamp: 'Jon 1/27/2006 15:44'!logCurrentInformationTo: stream	sensorModel logCurrentInformationTo: stream.	actuatorModel logCurrentInformationTo: stream.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvMotionModel class	instanceVariableNames: ''!!AvMotionModel class methodsFor: 'instance creation' stamp: 'jon 11/23/2004 15:16'!forVehicleNamed: vehicleName	^(self allSubclasses		detect: [:each | (each respondsTo: #vehicleName) and: [each vehicleName = vehicleName]]		ifNone: [^nil]) new initialize; yourself! !AvMotionModel subclass: #AvGroundMotionModel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Motion'!!AvGroundMotionModel commentStamp: 'Jon 1/16/2005 08:58' prior: 0!An AvGroundMotionModel is the abstract superclass of all ground-based vehicle motion models.!!AvGroundMotionModel methodsFor: 'navigator support' stamp: 'Jon 12/4/2004 09:32'!desiredNavigatorOutputClass	"Answer the type of output we're expecting from the navigator."	^AvGroundBasedNavigatorOutput! !AvGroundMotionModel subclass: #AvDroneMotionModel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Motion'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDroneMotionModel class	instanceVariableNames: ''!!AvDroneMotionModel class methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:01'!vehicleName	^'Drone'! !AvGroundMotionModel subclass: #AvMicroRoverMotionModel	instanceVariableNames: 'turnRate'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Motion'!!AvMicroRoverMotionModel commentStamp: 'Jon 11/11/2005 11:55' prior: 0!An AvMicroRoverMotionModel is the motion model class for MicroRover, a small autonomous ground vehicle.MicroRover has a custom chassis that uses a pair of treads for propulsion, where each tread is powered from a separate DC gearmotor. It has a pair of sonars mounted on a pivoting turrent, and a 3-axis tilt-compensated digital compass that handles heading, pitch, and roll. It also has an optical encoder mounted on each drive wheel, and a GPS for positioning.Instance Variables	turnRate:		<Float>turnRate	- indicates the amount to turn	- 0.0 is straight ahead, 1.0 is full right, -1.0 is full left	- turnRate is the interface between the heading controller and the speed controller.!!AvMicroRoverMotionModel methodsFor: 'initializing' stamp: 'Jon 1/15/2006 14:12'!initialize	super initialize.	turnRate := 0.0.! !!AvMicroRoverMotionModel methodsFor: 'initializing' stamp: 'Jon 11/2/2005 13:01'!initializeHeadingController	headingController := (AvStateMachine on: self)		addStateHandler: (AvStateHandler new executeSelector: #handleHeadingStarting) for: #starting;		addStateHandler: (AvStateHandler new executeSelector: #handleOnHeading) for: #onHeading;		addStateHandler: (AvStateHandler new executeSelector: #handleChangeHeading) for: #changeHeading;		yourself.	headingController nextState: #starting.! !!AvMicroRoverMotionModel methodsFor: 'initializing' stamp: 'Jon 12/23/2005 13:56'!initializeSpeedController	speedController := (AvStateMachine on: self)		addStateHandler: (AvStateHandler new executeSelector: #handleSpeed) for: #speed;		yourself.	speedController nextState: #speed.! !!AvMicroRoverMotionModel methodsFor: 'accessing' stamp: 'Jon 1/5/2006 10:29'!metersPerEncoderCount	"Answer the number of meters the vehicle travels during one encoder count."	"The encoder disk has 8 transitions per revolution, and the tread diameter is 1.958 inches at the drive wheel.	1.958 * 0.0254 * Float pi / 8.0 "	^0.01953! !!AvMicroRoverMotionModel methodsFor: 'accessing' stamp: 'Jon 1/5/2006 10:21'!trackWidth	"Answer the track width, in meters. Note that this is not the width of one of the tracks -- rather,	it is the width of the vehicle, from the center of the left track to the center of the right track."	"The track is 8 inches, which is 20.32 cm..."	^0.2032! !!AvMicroRoverMotionModel methodsFor: 'accessing' stamp: 'Jon 1/5/2006 10:25'!vehicleSpecification	"Answer a new instance of vehicle specification, which is simply a place to cache 	specific numbers about the vehicle for other navigation systems to use."	^AvVehicleSpecification new		trackWidth: self trackWidth;		metersPerEncoderCount: self metersPerEncoderCount;		yourself.! !!AvMicroRoverMotionModel methodsFor: 'speed control' stamp: 'Jon 1/15/2006 21:56'!handleSpeed	"The FSM for speed control is very simple - one state, and this is it. Simply set the speed	according to the desired speed and the turn rate."	| leftTreadRPM rightTreadRPM leftTreadRPMDelta rightTreadRPMDelta |	leftTreadRPM := self desiredSpeed * self rpmAtOneMeterPerSecond.	rightTreadRPM := leftTreadRPM.	leftTreadRPMDelta := 0.	rightTreadRPMDelta := 0.	turnRate ~= 0.0		ifTrue: [			"If we're turning right, then we need to slow down the right tread. Vice versa for left turns."			turnRate positive				ifTrue: [rightTreadRPMDelta := rightTreadRPM * 2.0 * turnRate negated]				ifFalse: [leftTreadRPMDelta := leftTreadRPM * 2.0 * turnRate]].	"Note - in general, the deltas will be either 0 or negative..."	(self actuatorNamed: 'leftMotor') setRPM: leftTreadRPM + leftTreadRPMDelta.	(self actuatorNamed: 'rightMotor') setRPM: rightTreadRPM + rightTreadRPMDelta.	"AvSystem current log: 'Motion - turnRate: ', turnRate printString, ' left rpm: ', (leftTreadRPM + leftTreadRPMDelta) printString, ' right: ', (rightTreadRPM + rightTreadRPMDelta) printString"! !!AvMicroRoverMotionModel methodsFor: 'heading control' stamp: 'Jon 12/23/2005 13:45'!handleChangeHeading	turnRate := (navigatorOutput desiredHeading - self vehicleHeading) / 180.0.	(self vehicleHeading - navigatorOutput desiredHeading) abs <= self allowableHeadingOffset		ifTrue: [headingController nextState: #onHeading].! !!AvMicroRoverMotionModel methodsFor: 'heading control' stamp: 'Jon 11/11/2005 11:56'!handleHeadingStarting	turnRate := 0.0.	headingController nextState: #onHeading.! !!AvMicroRoverMotionModel methodsFor: 'heading control' stamp: 'Jon 12/23/2005 13:46'!handleOnHeading	turnRate := 0.0.	(self vehicleHeading - navigatorOutput desiredHeading) abs > self allowableHeadingOffset		ifTrue: [headingController nextState: #changeHeading].! !!AvMicroRoverMotionModel methodsFor: 'execution' stamp: 'Jon 1/6/2006 08:32'!execute	super execute.	(self sensorNamed: 'master') finishCycle! !!AvMicroRoverMotionModel methodsFor: 'private' stamp: 'Jon 12/23/2005 14:20'!allowableHeadingOffset	"Answer the allowable heading offset, in degrees. Anything more than this will trigger a turn."	^10.0! !!AvMicroRoverMotionModel methodsFor: 'private' stamp: 'Jon 1/5/2006 09:26'!encodersUpdated	"The encoders have been updated. On MicroRover, this means tell the tracker."	| sensor |	sensor := self sensorNamed: 'encoder'.	tracker updateEncodersFrom: sensor leftTicks and: sensor rightTicks! !!AvMicroRoverMotionModel methodsFor: 'private' stamp: 'Jon 12/23/2005 14:16'!rpmAtOneMeterPerSecond	"Answer the motor RPM for this vehicle to travel one meter per second.	The Micro Rover's drive wheel (with the tread around it) is 52 mm in diameter, which	works out to ~163mm in circumference. Each revolution of the motor, the vehicle will	travel 163 mm, or 0.163 meters. Thus, 1 m/s = 368.1 rpm."	^368.1! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvMicroRoverMotionModel class	instanceVariableNames: ''!!AvMicroRoverMotionModel class methodsFor: 'accessing' stamp: 'Jon 11/2/2005 13:00'!vehicleName	^'MicroRover'! !AvGroundMotionModel subclass: #AvOrionMotionModel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Motion'!!AvOrionMotionModel commentStamp: 'Jon 1/16/2005 09:17' prior: 0!An AvOrionMotionModel is the motion model class for Orion, a small autonomous ground vehicle.Orion is based on a Tamiya Clod Buster chassis, with significant changes and upgrades. It is four wheel drive, with the front and rear axles each being powered by a separate DC gearmotor. It has four wheel steering, with the front and rear wheels being independently steered by a pair of hobby servos. It also has four wheel independent brakes -- each of the four brakes is operated by a hobby servo.!!AvOrionMotionModel methodsFor: 'initializing' stamp: 'Jon 1/14/2005 12:40'!initializeComplexSpeedController	speedController := (AvStateMachine on: self)		addStateHandler: (AvStateHandler new executeSelector: #handleSpeedStarting) for: #starting;		addStateHandler: (AvStateHandler new executeSelector: #handleAtSpeed) for: #atSpeed;		addStateHandler: (AvStateHandler new executeSelector: #handleChangeSpeed) for: #changeSpeed;		addStateHandler: (AvStateHandler new executeSelector: #handleRampingSpeedUp) for: #rampSpeedUp;		addStateHandler: (AvStateHandler new executeSelector: #handleRampingSpeedDown) for: #rampSpeedDown;		addStateHandler: (AvStateHandler new executeSelector: #handleEmergencyStop) for: #emergencyStop;		yourself.	speedController nextState: #starting.! !!AvOrionMotionModel methodsFor: 'initializing' stamp: 'Jon 10/13/2005 12:40'!initializeHeadingController	headingController := (AvStateMachine on: self)		addStateHandler: (AvStateHandler new executeSelector: #handleHeadingStarting) for: #starting;		addStateHandler: (AvStateHandler new executeSelector: #handleOnHeading) for: #onHeading;		addStateHandler: (AvStateHandler new executeSelector: #handleChangeHeading) for: #changeHeading;		yourself.	headingController nextState: #starting.! !!AvOrionMotionModel methodsFor: 'initializing' stamp: 'Jon 12/5/2004 09:40'!initializeSimpleSpeedController	speedController := AvExecutionBlock 		named: 'speedController' 		with: [self doSimpleSpeedControl].! !!AvOrionMotionModel methodsFor: 'initializing' stamp: 'Jon 1/14/2005 12:36'!initializeSpeedController	self initializeSimpleSpeedController! !!AvOrionMotionModel methodsFor: 'speed control' stamp: 'Jon 12/5/2004 13:26'!doSimpleSpeedControl	"The simple speed controller assumes the embedded system takes care of	actual speed control, so we just feed it how fast we want it to go, and let it take	care of speed control."	| rpm |	rpm := self wheelRpmFrom: navigatorOutput desiredSpeed.	(self actuatorNamed: 'frontMotor') setRPM: rpm.	(self actuatorNamed: 'rearMotor') setRPM: rpm.! !!AvOrionMotionModel methodsFor: 'speed control' stamp: 'Jon 12/4/2004 12:01'!handleAtSpeed	(self vehicleSpeed - navigatorOutput desiredSpeed) abs > self allowableSpeedOffset		ifTrue: [^speedController nextState: #changeSpeed].! !!AvOrionMotionModel methodsFor: 'speed control' stamp: 'Jon 12/4/2004 12:02'!handleChangeSpeed	(self vehicleSpeed < navigatorOutput desiredSpeed)		ifTrue: [speedController nextState: #rampSpeedUp]		ifFalse: [speedController nextState: #rampSpeedDown].! !!AvOrionMotionModel methodsFor: 'speed control' stamp: 'Jon 12/4/2004 12:05'!handleRampSpeedUp	| delta |	delta := navigatorOutput desiredSpeed - self vehicleSpeed.	! !!AvOrionMotionModel methodsFor: 'private' stamp: 'Jon 12/5/2004 13:37'!wheelRpmFrom: metersPerSecond	^metersPerSecond * self class speedToRpmConversionFactor.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvOrionMotionModel class	instanceVariableNames: ''!!AvOrionMotionModel class methodsFor: 'accessing' stamp: 'Jon 12/5/2004 13:36'!speedToRpmConversionFactor	"Answer the number which, when multiplied by speed (in meters per second), gives tire RPM."	"| tireDiameter tireCircumference |	tireDiameter := 6.125 * 25.4 / 1000.0.	tireCircumference := tireDiameter * Float pi.	^60.0 / tireCircumference"	^122.761325219524! !!AvOrionMotionModel class methodsFor: 'accessing' stamp: 'Jon 12/4/2004 09:52'!vehicleName	^'Orion'! !AvMotionModel subclass: #AvUnderwaterMotionModel	instanceVariableNames: 'depthController'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Motion'!!AvUnderwaterMotionModel commentStamp: 'Jon 1/16/2005 08:59' prior: 0!An AvUnderwaterMotionModel is the abstract superclass of all underwater-based vehicle motion models.Instance Variables	depthController:		<AvStateMachine | AvExecutionBlock>depthController	- the object responsible for maintaining the vehicle depth at the level requested by the navigator!!AvUnderwaterMotionModel methodsFor: 'execution' stamp: 'Jon 1/14/2005 12:42'!execute	super execute.	self executeDepth.! !!AvUnderwaterMotionModel methodsFor: 'navigator support' stamp: 'Jon 12/4/2004 09:33'!desiredNavigatorOutputClass	"Answer the type of output we're expecting from the navigator."	^AvWaterBasedNavigatorOutput! !AvUnderwaterMotionModel subclass: #AvMicroSeekerMotionModel	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Motion'!!AvMicroSeekerMotionModel commentStamp: 'Jon 1/16/2005 09:01' prior: 0!An AvMicroSeekerMotionModel is the motion model class for MicroSeeker, a small AUV.MicroSeeker has a single thruster, a pair of front-mounted dive planes, and a pair of rear-mounted rudders. The dive planes are controlled by a single hobby servo, and the rudders by another hobby servo. The thruster is powered from a simple DC gearmotor.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvMicroSeekerMotionModel class	instanceVariableNames: ''!!AvMicroSeekerMotionModel class methodsFor: 'accessing' stamp: 'Jon 12/4/2004 09:56'!vehicleName	^'MicroSeeker'! !Object subclass: #AvVehicleSpecification	instanceVariableNames: 'trackWidth metersPerEncoderCount'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Motion'!!AvVehicleSpecification methodsFor: 'accessing' stamp: 'Jon 1/5/2006 10:23'!metersPerEncoderCount	^metersPerEncoderCount! !!AvVehicleSpecification methodsFor: 'accessing' stamp: 'Jon 1/5/2006 10:23'!metersPerEncoderCount: aNumber	metersPerEncoderCount := aNumber! !!AvVehicleSpecification methodsFor: 'accessing' stamp: 'Jon 1/5/2006 10:23'!trackWidth	^trackWidth! !!AvVehicleSpecification methodsFor: 'accessing' stamp: 'Jon 1/5/2006 10:23'!trackWidth: aNumber	trackWidth := aNumber! !Object subclass: #AvPoseFilter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvPoseFilter commentStamp: 'Jon 12/29/2005 20:50' prior: 0!An AvPoseFilter is a filter that computes pose, or orientation, of a vehicle based on orientation sensors.See the subclasses for each specific kind of pose filter.!AvPoseFilter subclass: #AvComplexPoseFilter	instanceVariableNames: 'imu compass rollover orientation'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvComplexPoseFilter commentStamp: 'Jon 12/29/2005 20:47' prior: 0!An AvComplexPoseFilter is a filter that computes pose, or orientation, of a vehicle based on orientation sensors.The main filter output is based on the readings from three orthagonal rate gyros. However, rate gyros drift with time, so this drift (which is called bias) has to be periodically compensated for. It can be compensated competely by stopping the vehicle, waiting for it to come completely to rest, and measuring the vehicle's pitch and roll using a two-axis accelerometer. The yaw gyro, which is the one that is used to compute the vehicle's heading, can be compensated for by using the compass, as long as the reading is stable for a few cycles.The rollover sensor is a last-resort thing -- if we've come to a halt, and the rollover sensor says we're upside down or on our side, the other orientation sensors don't matter.Instance Variables:	imu:			<AvInertialSensor>	compass:		<AvCompassSensor>	rollover:		<AvRolloverSensor>	orientation:	<AvOrientation>imu, compass, rollover	- references to the orientation sensorsorientation	- contains a quaternion that represents the vehicle's pose in 3-dimensional space!Object subclass: #AvSensor	instanceVariableNames: 'name model hardwareInterface'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvSensor commentStamp: 'Jon 1/16/2005 09:22' prior: 0!An AvSensor represents a single instance of a sensor on the vehicle.Instance Variables:	name:					<String>	model:					<AvSensorModel>	hardwareInterface:		<AvHardwareInterface>name	- the unique name of this particular sensormodel	- a back reference to the model that contains all the sensors for this vehiclehardwareInterface	- the hardware interface for this sensor	- note that a hardware interface can be shared across many sensors	- note also that a vehicle may have many hardware interfaces!!AvSensor methodsFor: 'accessing' stamp: 'jon 10/27/2004 12:46'!hardwareInterface	^hardwareInterface! !!AvSensor methodsFor: 'accessing' stamp: 'jon 10/27/2004 12:46'!hardwareInterface: anAvHardwareInterface	hardwareInterface := anAvHardwareInterface! !!AvSensor methodsFor: 'accessing' stamp: 'jon 10/23/2004 16:19'!model	^model! !!AvSensor methodsFor: 'accessing' stamp: 'jon 10/23/2004 16:19'!model: avSensorModel	model := avSensorModel! !!AvSensor methodsFor: 'accessing' stamp: 'jon 10/21/2004 21:34'!name	^name! !!AvSensor methodsFor: 'accessing' stamp: 'jon 10/21/2004 21:33'!name: aString	name := aString! !!AvSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 11:56'!packetCommand: anInteger	"This is included so the packet extractor will work. Subclasses should not override."! !!AvSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 11:56'!packetLength: anInteger	"This is included so the packet extractor will work. Subclasses should not override."! !!AvSensor methodsFor: 'api' stamp: 'jon 10/27/2004 22:27'!handleResponse	"The device sends this when we have a complete response or push command received."! !!AvSensor methodsFor: 'api' stamp: 'Jon 10/26/2005 21:38'!sendCommand: commandName	hardwareInterface device sendCommand: commandName! !!AvSensor methodsFor: 'api' stamp: 'jon 10/27/2004 18:14'!synchronize	"Synchronize the receiver with the serial port."! !!AvSensor methodsFor: 'printing' stamp: 'jon 10/27/2004 12:37'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self name;		nextPutAll: ')'! !!AvSensor methodsFor: 'testing' stamp: 'jon 11/21/2004 09:35'!isConnected	^hardwareInterface notNil and: [hardwareInterface isConnected]! !!AvSensor methodsFor: 'logging' stamp: 'Jon 1/16/2006 09:19'!logCurrentInformationTo: stream	stream nextPutAll: self name.! !AvSensor subclass: #AvAngleEncoderSensor	instanceVariableNames: 'angle'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvAngleEncoderSensor commentStamp: 'jon 10/20/2004 22:26' prior: 0!An AvAngleEncoderSensor represents an encoder that measures the position of a limited rotating assembly, like a servo.Instance Variables:	angle:	<Integer>angle	- holds the angle of the encoder, in degrees	- zero is the "neutral" setting, which may be on one end or in the middle, depending on what the encoder is for!AvSensor subclass: #AvCameraSensor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!AvCameraSensor subclass: #AvAvrCameraSensor	instanceVariableNames: 'frameLines frame ack version'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvAvrCameraSensor methodsFor: 'initializing' stamp: 'Jon 3/3/2005 13:05'!initialize	self initializeFrameLines.	super initialize.! !!AvAvrCameraSensor methodsFor: 'initializing' stamp: 'Jon 3/3/2005 13:06'!initializeFrameLines	frameLines := Array new: 72.! !!AvAvrCameraSensor methodsFor: 'accessing' stamp: 'Jon 10/27/2005 14:17'!frame	^frame! !!AvAvrCameraSensor methodsFor: 'commands' stamp: 'Jon 3/3/2005 13:06'!dumpFrame	self initializeFrameLines.	self sendCommand: #dumpFrame.! !!AvAvrCameraSensor methodsFor: 'commands' stamp: 'Jon 10/26/2005 22:11'!getVersion	ack := nil.	version := nil.	self sendCommand: #version.! !!AvAvrCameraSensor methodsFor: 'commands' stamp: 'Jon 10/26/2005 22:06'!ping	ack := nil.	self sendCommand: #ping.! !!AvAvrCameraSensor methodsFor: 'responses' stamp: 'Jon 3/8/2005 08:55'!ack: aString	ack := aString! !!AvAvrCameraSensor methodsFor: 'responses' stamp: 'Jon 10/27/2005 14:15'!frameLine: byteArray	"Receive a single frame line from a 'DF' command.	The format is:		0x0B	- frame line tag		0x--	- line number for this frame line		....		- 176 bytes of raw color data, in Bayer format		0x0F	- end of line tag"	| lineNumber bytes |	lineNumber := byteArray at: 2.	bytes := byteArray copyFrom: 3 to: byteArray size - 1.	frameLines at: lineNumber + 1 put: bytes.	self hasAllFrameLines		ifTrue: [self generateFrame].! !!AvAvrCameraSensor methodsFor: 'responses' stamp: 'Jon 10/26/2005 22:09'!version: aString	version := aString! !!AvAvrCameraSensor methodsFor: 'testing' stamp: 'Jon 3/3/2005 13:07'!hasAllFrameLines	^(frameLines		detect: [:each | each isNil]		ifNone: [#none]) notNil! !!AvAvrCameraSensor methodsFor: 'private' stamp: 'Jon 10/27/2005 14:32'!generateFrame	frame := Form extent: 176 @ 144 depth: 32.	frameLines		with: (0 to: frameLines size - 1)		do: [:eachLine :eachY |			eachLine				with: (0 to: eachLine size - 1)				do: [:eachByte :eachX |					| green red blue |					green := (eachByte // 16) / 15.0.					eachX even						ifTrue: [							blue := (eachByte bitAnd: 15) / 15.0.							red := ((eachLine at: eachX + 2) bitAnd: 15) / 15.0]						ifFalse: [							red := (eachByte bitAnd: 15) / 15.0.							blue := ((eachLine at: eachX) bitAnd: 15) / 15.0].					frame						colorAt: eachX @ (eachY * 2) put: (Color r: red g: green / 2.0 b: blue);						colorAt: eachX @ (eachY * 2 + 1) put: (Color r: red g: green / 2.0 b: blue)]].! !AvSensor subclass: #AvCompassSensor	instanceVariableNames: 'heading pitch roll mapOffset gotFirstReading'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvCompassSensor commentStamp: 'Jon 12/29/2005 20:49' prior: 0!An AvCompassSensor represents a digital 3-axis tilt-compensated compass such as the Honeywell HMR-3300.Instance Variables:	heading:		<AvHeading>	pitch:			<Integer>	roll:				<Integer>	mapOffset:		<AvHeadingOffset>heading	- contains the heading, from 0 through 359 degrees	- 0 is north, 90 is east, 180 is south, and 270 is westpitch	- contains the pitch of the sensor, if it is equipped with a tilt chip	- pitch is in degrees, with 0 being level, positive is pitching forwards, and negative is pitching backroll	- contains the roll of the sensor, if it is equipped with a tilt chip	- roll is in degrees, with 0 being level, positive is rolling right, and negative is rolling leftmapOffset	- contains the offset of the map from magnetic north	- the heading instance variable is set by adding the sensor heading value to the mapOffset	- thus, when the vehicle is pointing true north on the map, the compass sensor heading reads 0!!AvCompassSensor methodsFor: 'accessing' stamp: 'Jon 1/15/2006 17:30'!gotFirstReading	^gotFirstReading! !!AvCompassSensor methodsFor: 'accessing' stamp: 'Jon 1/27/2006 20:48'!handleResponse	"We have a valid heading now."	gotFirstReading := true.	AvSystem current log: 'COMPASS (heading: ', heading printString, ')'.! !!AvCompassSensor methodsFor: 'accessing' stamp: 'Jon 12/23/2005 16:38'!heading	^heading! !!AvCompassSensor methodsFor: 'accessing' stamp: 'Jon 1/2/2006 21:47'!heading: aNumber	heading := aNumber! !!AvCompassSensor methodsFor: 'accessing' stamp: 'Jon 12/23/2005 16:38'!pitch	^pitch! !!AvCompassSensor methodsFor: 'accessing' stamp: 'Jon 1/28/2006 08:44'!pitch: aNumber	pitch := aNumber > 127		ifTrue: [(256 - aNumber) negated]		ifFalse: [aNumber].! !!AvCompassSensor methodsFor: 'accessing' stamp: 'Jon 12/23/2005 16:38'!roll	^roll! !!AvCompassSensor methodsFor: 'accessing' stamp: 'Jon 1/28/2006 08:44'!roll: aNumber	roll := aNumber > 127		ifTrue: [(256 - aNumber) negated]		ifFalse: [aNumber].! !!AvCompassSensor methodsFor: 'initializing' stamp: 'Jon 1/15/2006 17:30'!initialize	super initialize.	heading := 0.	pitch := 0.	roll := 0.	gotFirstReading := false.! !!AvCompassSensor methodsFor: 'logging' stamp: 'Jon 1/27/2006 11:54'!logCurrentInformationTo: stream	stream		nextPutAll: '(heading: ';		print: heading;		nextPutAll: ' pitch: ';		print: pitch;		nextPutAll: ' roll: ';		print: roll;		nextPutAll: ') '.! !AvSensor subclass: #AvContactSensor	instanceVariableNames: 'hasContact'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvContactSensor commentStamp: '<historical>' prior: 0!An AvContactSensor represents a contact or bump sensor, which can report if the vehicle has hit something.Instance Variables:	hasContact	<Boolean>hasContact	- true if the contact sensor is reporting a touch, false otherwise!AvSensor subclass: #AvGpsSensor	instanceVariableNames: 'gpsCoordinate sentences gpsTimeSet'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvGpsSensor commentStamp: 'Jon 1/16/2005 09:23' prior: 0!An AvGpsSensor reads NMEA sentence data from a GPS receiver over a hardware interface, typically a serial port.It can answer the current (latest) GPS coordinate.Instance Variables:	gpsCoordinate:	<AvGpsCoordinate>	sentences:			<Dictionary>gpsCoordinate	- the most recent GPS coordinate returned by the physical sensorsentences	- contains the set of sentences returned by the physical sensor	- we need to extract information from two sentences (GPGLL & PGRME) in order to get a current GPS coordinate!!AvGpsSensor methodsFor: 'initializing' stamp: 'Jon 1/12/2006 12:25'!initialize	self initializeSentences.	gpsTimeSet := false.	super initialize.! !!AvGpsSensor methodsFor: 'initializing' stamp: 'jon 10/20/2004 12:22'!initializeSentences	sentences := Dictionary new.! !!AvGpsSensor methodsFor: 'accessing' stamp: 'jon 10/20/2004 10:57'!gpsCoordinate	^gpsCoordinate! !!AvGpsSensor methodsFor: 'accessing' stamp: 'jon 10/22/2004 22:49'!sentence: aString	self addSentence: aString! !!AvGpsSensor methodsFor: 'api' stamp: 'jon 10/20/2004 13:46'!synchronize	"Synchronize the receiver with the serial port."	self hardwareInterface synchronizeFrom: [:serialPort |		self synchronizeOn: serialPort]! !!AvGpsSensor methodsFor: 'printing' stamp: 'jon 10/27/2004 12:36'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		"nextPutAll: (self isRunning			ifTrue: ['']			ifFalse: ['NOT RUNNING: ']);"		nextPutAll: self name;		nextPutAll: ' - ';		print: self gpsCoordinate;		nextPutAll: ')'! !!AvGpsSensor methodsFor: 'private' stamp: 'jon 10/20/2004 12:08'!addSentence: lineString	| sentence |	sentence := (ReadStream on: lineString) upTo: $,.	sentences at: sentence put: lineString.	self checkForGpsCoordinate! !!AvGpsSensor methodsFor: 'private' stamp: 'Jon 1/12/2006 12:13'!checkForGpsCoordinate	"Check if we have enough sentences to make a GPS coordinate.	If we do, make it, and reset the sentences map to be empty.	Note - this method assumes that the sentences come in the correct order, and	the ones we are looking for are for the same reading."	((sentences includesKey: '$PGRME') and: [sentences includesKey: '$GPRMC'])		ifTrue: [			gpsCoordinate := self coordinateFromGPRMC: (sentences at: '$GPRMC').			self updateCoordinate: gpsCoordinate withAttributesFrom: (sentences at: '$PGRME').			self initializeSentences].! !!AvGpsSensor methodsFor: 'private' stamp: 'jon 10/23/2004 16:35'!coordinateFromGPGLL: gpgllString	"Answer a new instance of AvGpsCoordinate, parsed from the given GPGLL format NMEA sentence."	| tokens tokenStream stream degreesLatitude degreesLongitude minutes invalid |	tokenStream := ReadStream on: (tokens := self subStringsFrom: gpgllString using: ',*').	tokenStream next = '$GPGLL'		ifFalse: [^nil].	stream := ReadStream on: tokenStream next.	degreesLatitude := (stream next: 2) asNumber.	minutes := Number readFrom: stream.	degreesLatitude := degreesLatitude + (minutes / 60.0).	tokenStream next = 'S'		ifTrue: [degreesLatitude := degreesLatitude negated].	stream := ReadStream on: tokenStream next.	degreesLongitude := (stream next: 3) asNumber.	minutes := Number readFrom: stream.	degreesLongitude := degreesLongitude + (minutes / 60.0).	tokenStream next = 'W'		ifTrue: [degreesLongitude := degreesLongitude negated].	invalid := (tokens at: 7) = 'V'.	^(AvGpsCoordinate latitude: degreesLatitude longitude: degreesLongitude)		valid: invalid not;		yourself! !!AvGpsSensor methodsFor: 'private' stamp: 'Jon 1/12/2006 12:26'!coordinateFromGPRMC: gprmcString	"Answer a new instance of AvGpsCoordinate, parsed from the given GPRMC format NMEA sentence."	| tokenStream stream degreesLatitude degreesLongitude minutes invalid timeString |	tokenStream := ReadStream on: (self subStringsFrom: gprmcString using: ',*').	tokenStream next = '$GPRMC'		ifFalse: [^nil].	timeString := tokenStream next.	invalid := tokenStream next = 'V'.	stream := ReadStream on: tokenStream next.	degreesLatitude := (stream next: 2) asNumber.	minutes := Number readFrom: stream.	degreesLatitude := degreesLatitude + (minutes / 60.0).	tokenStream next = 'S'		ifTrue: [degreesLatitude := degreesLatitude negated].	stream := ReadStream on: tokenStream next.	degreesLongitude := (stream next: 3) asNumber.	minutes := Number readFrom: stream.	degreesLongitude := degreesLongitude + (minutes / 60.0).	tokenStream next = 'W'		ifTrue: [degreesLongitude := degreesLongitude negated].	tokenStream next; next. "Skip speed & course over ground..."	self parseTimeFrom: timeString dateFrom: tokenStream next.	^(AvGpsCoordinate latitude: degreesLatitude longitude: degreesLongitude)		valid: invalid not;		yourself! !!AvGpsSensor methodsFor: 'private' stamp: 'Jon 1/12/2006 13:21'!parseTimeFrom: timeString dateFrom: dateString	"Parse UTC time & date from a $GPRMC sentence field.	Time format is 'hhmmss.sss'. We're not interested in sub-second accuracy.	Date format is DDMMYY."	| stream hours minutes seconds year month day dateAndTime linuxDateString |	"We only need to do this if it hasn't been done."	gpsTimeSet		ifTrue: [^self].	stream := ReadStream on: timeString.	hours := (stream next: 2) asNumber.	minutes := (stream next: 2) asNumber.	seconds := (stream next: 2) asNumber.	stream := ReadStream on: dateString.	day := (stream next: 2) asNumber.	month := (stream next: 2) asNumber.	year := (stream next: 2) asNumber.	dateAndTime := (DateAndTime 		year: year		month: month		day: day		hour: hours		minute: minutes		second: seconds		offset: Duration zero) asLocal.	"Linux date command format is: 'MMDDhhmmYYYY.ss' "	linuxDateString := (WriteStream on: (String new: 20))		nextPutAll: dateAndTime monthIndex asTwoCharacterString;		nextPutAll: dateAndTime dayOfMonth asTwoCharacterString;		nextPutAll: dateAndTime hour24 asTwoCharacterString;		nextPutAll: dateAndTime minutes asTwoCharacterString;		nextPutAll: dateAndTime year printString;		nextPut: $.;		nextPutAll: dateAndTime seconds asTwoCharacterString;		contents.	AvSystem current setSystemTimeAndDateFrom: linuxDateString.	gpsTimeSet := true.! !!AvGpsSensor methodsFor: 'private' stamp: 'Jon 1/12/2006 12:52'!setSystemTimeAndDateFrom: aString	"First, we don't need to do this for anything but the target system, which is not X86."	AvSystem current isEmbeddedSystem		ifFalse: [^self].	"Next, check if the date has been set."	Date today year >= 2006		ifTrue: [^self].	! !!AvGpsSensor methodsFor: 'private' stamp: 'jon 10/20/2004 09:45'!subStringsFrom: aString using: separators	"Answer an array containing the substrings in the receiver separated by the elements of separators."	| char result sourceStream subString |	(separators allSatisfy: [:element | element isKindOf: Character])		ifFalse: [^ self error: 'separators must be Characters.'].	sourceStream := ReadStream on: aString.	result := OrderedCollection new.	subString := String new.	[sourceStream atEnd]		whileFalse: [			char := sourceStream next.			(separators includes: char)				ifTrue: [					result add: subString copy.					subString := String new]				ifFalse: [subString := subString , (String with: char)]].	subString notEmpty		ifTrue: [result add: subString copy].	^ result asArray! !!AvGpsSensor methodsFor: 'private' stamp: 'jon 10/22/2004 21:12'!synchronizeOn: serialPort	| lastTime timeout done |	lastTime := Time millisecondClockValue.	timeout := 500.	done := false.	[done] whileFalse: [		| bytes |		bytes := [serialPort readByteArray] on: Error do: [:exception | serialPort close. self error: 'Error reading serial port...'].		bytes notEmpty			ifTrue: [lastTime := Time millisecondClockValue].		done := (Time millisecondsSince: lastTime) > timeout].! !!AvGpsSensor methodsFor: 'private' stamp: 'Jon 1/16/2005 09:24'!updateCoordinate: aCoordinate withAttributesFrom: pgrmeString	| subStrings uncertainty |	subStrings := self subStringsFrom: pgrmeString using: ',*'.	subStrings first = '$PGRME'		ifFalse: [^nil].	uncertainty := subStrings second asNumber.	aCoordinate uncertainty: uncertainty! !!AvGpsSensor methodsFor: 'logging' stamp: 'Jon 1/27/2006 11:55'!logCurrentInformationTo: stream	stream		nextPutAll: '(';		print: self gpsCoordinate;		nextPutAll: ') '.! !AvSensor subclass: #AvGyroSensor	instanceVariableNames: 'rawValue value bias orientation'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvGyroSensor commentStamp: '<historical>' prior: 0!An AvGyroSensor represents a single rate gyro, in some orientation.Instance Variables:	rawValue:		<Integer>	value:			<Integer>	bias:			<Integer>	orientation:	<Symbol>rawValue	- contains the raw gyro readingvalue	- contains the gyro reading after the bias correction has been applied to itbias	- a fixed correction to compensate for driftorientation	- contains one of #pitch, #roll, #yaw!!AvGyroSensor methodsFor: 'accessing' stamp: 'Jon 11/24/2004 21:16'!bias	^ bias! !!AvGyroSensor methodsFor: 'accessing' stamp: 'Jon 11/24/2004 21:17'!bias: aNumber	bias := aNumber! !!AvGyroSensor methodsFor: 'accessing' stamp: 'Jon 11/24/2004 21:16'!orientation	^ orientation! !!AvGyroSensor methodsFor: 'accessing' stamp: 'Jon 11/24/2004 21:17'!orientation: aSymbol	orientation := aSymbol! !!AvGyroSensor methodsFor: 'accessing' stamp: 'Jon 11/24/2004 21:16'!rawValue	^ rawValue! !!AvGyroSensor methodsFor: 'accessing' stamp: 'Jon 11/24/2004 21:17'!rawValue: aNumber	rawValue := aNumber! !!AvGyroSensor methodsFor: 'accessing' stamp: 'Jon 11/24/2004 21:17'!value	^ value! !!AvGyroSensor methodsFor: 'accessing' stamp: 'Jon 11/24/2004 21:17'!value: aNumber	value := aNumber! !!AvGyroSensor methodsFor: 'api' stamp: 'Jon 11/24/2004 21:24'!handleResponse	"The device sends this when we have a complete response or push command received."	self triggerEvent: #sensorChanged! !!AvGyroSensor methodsFor: 'api' stamp: 'Jon 11/24/2004 21:24'!synchronize	"Synchronize the receiver with the serial port."	self hardwareInterface synchronizeFrom: [:serialPort |		self synchronizeOn: serialPort]! !!AvGyroSensor methodsFor: 'api' stamp: 'Jon 11/24/2004 21:24'!synchronizeOn: serialPort	| lastTime timeout done |	[serialPort readByteArray isEmpty] whileTrue: [Processor yield].	lastTime := Time millisecondClockValue.	timeout := 500.	done := false.	[done] whileFalse: [		| bytes |		Processor yield.		bytes := [serialPort readByteArray] on: Error do: [:exception | serialPort close. self error: 'Error reading serial port...'].		bytes notEmpty			ifTrue: [lastTime := Time millisecondClockValue].		done := (Time millisecondsSince: lastTime) > timeout].! !AvSensor subclass: #AvIndirectGpsSensor	instanceVariableNames: 'gpsCoordinate'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvIndirectGpsSensor commentStamp: 'Jon 1/1/2006 12:32' prior: 0!An AvGpsIndirectSensor reads quasi-NMEA sentence data from a PIC connected to a Garmin GPS receiver.It can answer the current (latest) GPS coordinate.It requires the data in a single sentence, which is formatted like this:$AVPIC,ddmm.mmmmN,dddmm.mmmmW,nn.nn,VIn the above sentence format:	- dd is degrees, and is exactly 2 digits for latitude, 3 digits for longitude	- N is the N/S indicator, and can be either N or S	- W is the E/W indicator, and can be either E or W	- mm.mmmm is minutes	- nn.nn is uncertainty (extracted from the $PGRME sentence)	- V is the valid/invalid indicatorInstance Variables:	gpsCoordinate:	<AvGpsCoordinate>gpsCoordinate	- the most recent GPS coordinate returned by the physical sensor!!AvIndirectGpsSensor methodsFor: 'accessing' stamp: 'Jon 12/31/2005 07:54'!gpsCoordinate	^gpsCoordinate! !!AvIndirectGpsSensor methodsFor: 'accessing' stamp: 'Jon 12/31/2005 07:56'!sentence: aString	gpsCoordinate := self processSentence: aString! !!AvIndirectGpsSensor methodsFor: 'printing' stamp: 'Jon 12/31/2005 07:56'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self name;		nextPutAll: ' - ';		print: self gpsCoordinate;		nextPutAll: ')'! !!AvIndirectGpsSensor methodsFor: 'private' stamp: 'Jon 1/1/2006 12:31'!processSentence: sentenceString	"Answer a new instance of AvGpsCoordinate, parsed from the given custom format NMEA sentence."	| tokenStream stream degreesLatitude degreesLongitude minutes invalid uncertainty |	tokenStream := ReadStream on: (self subStringsFrom: sentenceString using: ',').	tokenStream next = '$AVPIC'		ifFalse: [^nil].	stream := ReadStream on: tokenStream next.	degreesLatitude := (stream next: 2) asNumber.	minutes := Number readFrom: stream.	degreesLatitude := degreesLatitude + (minutes / 60.0).	tokenStream next = 'S'		ifTrue: [degreesLatitude := degreesLatitude negated].	stream := ReadStream on: tokenStream next.	degreesLongitude := (stream next: 3) asNumber.	minutes := Number readFrom: stream.	degreesLongitude := degreesLongitude + (minutes / 60.0).	tokenStream next = 'W'		ifTrue: [degreesLongitude := degreesLongitude negated].	uncertainty := tokenStream next asNumber.	invalid := tokenStream next = 'V'.	^(AvGpsCoordinate latitude: degreesLatitude longitude: degreesLongitude)		valid: invalid not;		uncertainty: uncertainty;		yourself! !AvSensor subclass: #AvInertialSensor	instanceVariableNames: 'pitchGyro rollGyro yawGyro accererationForwards accererationRight accererationUp temperature'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvInertialSensor commentStamp: 'jon 10/20/2004 22:13' prior: 0!An AvInertialSensor is a sensor that measures inertial motion.Instance Variables:	pitchGyro:					<AvGyroSensor>	rollGyro:					<AvGyroSensor>	yawGyro:					<AvGyroSensor>	accererationForwards:		<Integer>	accererationRight:			<Integer>	accererationUp:			<Integer>	temperature:				<Integer>pitchGyro, rollGyro, yawGyro	- contain the gyro sensorsaccererationForwards, accererationRight, accererationUp	- contain the accelerometer readings	- when the vehicle is stopped, these values give very accurate readings for the vehicle pitch & rolltemperature	- used to compensate the gyro & accelerometer readings	- reads in degrees centigrade!!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!accererationForwards	^ accererationForwards! !!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!accererationForwards: anObject	accererationForwards _ anObject! !!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!accererationRight	^ accererationRight! !!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!accererationRight: anObject	accererationRight _ anObject! !!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!accererationUp	^ accererationUp! !!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!accererationUp: anObject	accererationUp _ anObject! !!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!pitchGyro	^ pitchGyro! !!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!pitchGyro: anObject	pitchGyro _ anObject! !!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!rollGyro	^ rollGyro! !!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!rollGyro: anObject	rollGyro _ anObject! !!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!temperature	^ temperature! !!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!temperature: anObject	temperature _ anObject! !!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!yawGyro	^ yawGyro! !!AvInertialSensor methodsFor: 'accessing' stamp: 'jon 11/22/2004 12:04'!yawGyro: anObject	yawGyro _ anObject! !!AvInertialSensor methodsFor: 'api' stamp: 'jon 11/23/2004 13:28'!handleResponse	"The device sends this when we have a complete response or push command received."	self triggerEvent: #sensorChanged! !!AvInertialSensor methodsFor: 'api' stamp: 'Jon 11/24/2004 20:06'!synchronize	"Synchronize the receiver with the serial port."	self hardwareInterface synchronizeFrom: [:serialPort |		self synchronizeOn: serialPort]! !!AvInertialSensor methodsFor: 'api' stamp: 'Jon 11/24/2004 20:08'!synchronizeOn: serialPort	| lastTime timeout done |	[serialPort readByteArray isEmpty] whileTrue: [Processor yield].	lastTime := Time millisecondClockValue.	timeout := 500.	done := false.	[done] whileFalse: [		| bytes |		Processor yield.		bytes := [serialPort readByteArray] on: Error do: [:exception | serialPort close. self error: 'Error reading serial port...'].		bytes notEmpty			ifTrue: [lastTime := Time millisecondClockValue].		done := (Time millisecondsSince: lastTime) > timeout].! !AvSensor subclass: #AvMasterPicSensor	instanceVariableNames: 'ack syncReceived'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvMasterPicSensor methodsFor: 'accessing' stamp: 'Jon 1/1/2006 21:05'!ack	^ack! !!AvMasterPicSensor methodsFor: 'accessing' stamp: 'Jon 1/23/2006 16:04'!ack: aNumber	ack := aNumber.	syncReceived := true.! !!AvMasterPicSensor methodsFor: 'accessing' stamp: 'Jon 1/23/2006 16:01'!syncTimeout	"Answer the number of milliseconds to wait for a synchronize response from the hardware."	^2000! !!AvMasterPicSensor methodsFor: 'synchronization' stamp: 'Jon 1/2/2006 15:03'!doneMission	self sendCommand: 'Done'.! !!AvMasterPicSensor methodsFor: 'synchronization' stamp: 'Jon 1/2/2006 15:07'!finishCycle	self sendCommand: 'FinishCycle'.! !!AvMasterPicSensor methodsFor: 'synchronization' stamp: 'Jon 1/2/2006 14:55'!keepAlive	self sendCommand: 'KeepAlive'.! !!AvMasterPicSensor methodsFor: 'synchronization' stamp: 'Jon 1/1/2006 14:50'!synchronize	"Synchronize the receiver with the serial port."	self hardwareInterface synchronizeFrom: [:serialPort |		self synchronizeOn: serialPort]! !!AvMasterPicSensor methodsFor: 'synchronization' stamp: 'Jon 1/23/2006 16:28'!synchronizeOn: serialPort	| startTime |	syncReceived := false.	[serialPort readByteArray isEmpty] whileFalse: [Processor yield].	self sendCommand: 'Synchronize'."	startTime := Time millisecondClockValue.	[syncReceived | ((Time millisecondsSince: startTime) > self syncTimeout)] whileFalse: [		(Delay forMilliseconds: 10) wait.		Processor yield].	syncReceived		ifFalse: [AvSystem handleMissionFailed: 'No response from Master PIC device...']."! !!AvMasterPicSensor methodsFor: 'logging' stamp: 'Jon 1/27/2006 11:56'!logCurrentInformationTo: stream! !AvSensor subclass: #AvRangeFinderPairSensor	instanceVariableNames: 'leftRange rightRange'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvRangeFinderPairSensor methodsFor: 'accessing' stamp: 'Jon 1/3/2006 17:51'!leftRange	^leftRange! !!AvRangeFinderPairSensor methodsFor: 'accessing' stamp: 'Jon 1/5/2006 15:31'!leftRange: rangeInInches	"The hardware sensor measures in inches. Convert to meters..."	leftRange := rangeInInches * 0.0254! !!AvRangeFinderPairSensor methodsFor: 'accessing' stamp: 'Jon 1/3/2006 17:52'!rightRange	^rightRange! !!AvRangeFinderPairSensor methodsFor: 'accessing' stamp: 'Jon 1/5/2006 15:31'!rightRange: rangeInInches	"The hardware sensor measures in inches. Convert to meters..."	rightRange := rangeInInches * 0.0254! !!AvRangeFinderPairSensor methodsFor: 'logging' stamp: 'Jon 1/27/2006 11:56'!logCurrentInformationTo: stream	stream		nextPutAll: '(leftRange: ';		print: leftRange;		nextPutAll: ' rightRange: ';		print: rightRange;		nextPutAll: ') '.! !AvSensor subclass: #AvRangeFinderSensor	instanceVariableNames: 'rangeValue'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvRangeFinderSensor commentStamp: '<historical>' prior: 0!An AvRangeFinderSensor is a sensor that can detect the range of an object in front of it.Instance Variables:	rangeValue:		<Integer>rangeValue	- the range to the detected object, in centimeters	- if there is no object detected, rangeValue is nil!AvSensor subclass: #AvRolloverSensor	instanceVariableNames: 'tiltValue'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvRolloverSensor commentStamp: '<historical>' prior: 0!An AvRolloverSensor is a sensor, like the Sharp GP1S036HEZ Tilt Sensor, that can tell whether or not the vehicle has rolled onto its side or back.Instance Variables:	tiltValue:		<Symbol>tiltValue	- contains one of: #normal, #onLeftSide, #onRightSide, #upsideDown!AvSensor subclass: #AvRotationEncoderPairSensor	instanceVariableNames: 'leftTicks rightTicks tracker'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvRotationEncoderPairSensor methodsFor: 'accessing' stamp: 'Jon 1/5/2006 15:32'!handleResponse	"We have a new pair of encoder values from the hardware sensors. Tell the tracker about it..."	tracker updateEncodersFrom: leftTicks and: rightTicks! !!AvRotationEncoderPairSensor methodsFor: 'accessing' stamp: 'Jon 1/4/2006 15:45'!leftTicks	^leftTicks! !!AvRotationEncoderPairSensor methodsFor: 'accessing' stamp: 'Jon 1/4/2006 15:46'!leftTicks: aNumber	leftTicks := aNumber! !!AvRotationEncoderPairSensor methodsFor: 'accessing' stamp: 'Jon 1/4/2006 15:45'!rightTicks	^rightTicks! !!AvRotationEncoderPairSensor methodsFor: 'accessing' stamp: 'Jon 1/4/2006 15:46'!rightTicks: aNumber	 rightTicks := aNumber! !!AvRotationEncoderPairSensor methodsFor: 'accessing' stamp: 'Jon 1/14/2006 17:08'!tracker: avTracker	tracker := avTracker! !!AvRotationEncoderPairSensor methodsFor: 'logging' stamp: 'Jon 1/27/2006 11:57'!logCurrentInformationTo: stream! !AvSensor subclass: #AvRotationEncoderSensor	instanceVariableNames: 'revolutionsPerMinute'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvRotationEncoderSensor commentStamp: '<historical>' prior: 0!An AvRotationEncoderSensor represents an encoder that measures the speed of a rotating assembly.Instance Variables:	revolutionsPerMinute:	<Integer>revolutionsPerMinute	- holds the number of RPMs the assembly is turning!Object subclass: #AvSensorModel	instanceVariableNames: 'sensors poseFilter hardwareInterfaces'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvSensorModel commentStamp: '<historical>' prior: 0!An AvSensorModel is the class that holds onto all the sensors that the vehicle has.It handles extracting sensor data from raw byte-level data (via the sensors), talking to the hardware interface to get this raw data, and doing high-level filtering on the sensor data.Instance Variables:	sensors:				<Dictionary key: <String> value: <AvSensor>>	hardwareInterfaces:	<Dictionary key: <String> value: <AvHardwareInterface>>sensors	- dictionary keyed on sensor name, with values of the sensors themselves	- each sensor represents (and holds the values from) a single sensor on the vehicle	- if the vehicle has two range finder sensors, there would be one entry in this dictionary for each of themhardwareInterfaces	- the collection of communications links with the devices we talk to, keyed by device name	- the same hardware interfaces are shared by the sensor model and the actuator model!!AvSensorModel methodsFor: 'initializing' stamp: 'Jon 12/23/2005 16:47'!initialize	sensors := Dictionary new.	hardwareInterfaces := Dictionary new.	poseFilter := AvSimplePoseFilter new.	super initialize.! !!AvSensorModel methodsFor: 'accessing' stamp: 'jon 10/23/2004 16:19'!addSensor: avSensor	self sensors		at: avSensor name		put: avSensor.	avSensor model: self! !!AvSensorModel methodsFor: 'accessing' stamp: 'jon 10/27/2004 12:03'!hardwareInterfaces: aDictionary	hardwareInterfaces := aDictionary! !!AvSensorModel methodsFor: 'accessing' stamp: 'Jon 12/23/2005 16:48'!heading	^poseFilter heading! !!AvSensorModel methodsFor: 'accessing' stamp: 'Jon 12/23/2005 16:47'!poseFilter	^poseFilter! !!AvSensorModel methodsFor: 'accessing' stamp: 'jon 11/23/2004 14:00'!sensorNamed: sensorName	^sensors		detect: [:each | each name = sensorName]		ifNone: [nil].! !!AvSensorModel methodsFor: 'accessing' stamp: 'jon 10/20/2004 18:31'!sensors	^sensors! !!AvSensorModel methodsFor: 'api' stamp: 'jon 10/27/2004 21:04'!start	hardwareInterfaces do: [:eachInterface |		self start: eachInterface].! !!AvSensorModel methodsFor: 'api' stamp: 'jon 10/27/2004 22:32'!stop	hardwareInterfaces do: [:eachInterface |		eachInterface stop].! !!AvSensorModel methodsFor: 'building' stamp: 'Jon 12/23/2005 16:50'!buildSensorsFrom: sensorData	sensors := sensorData collect: [:each |		| deviceName className |		deviceName := each at: #device.		className := (each at: #class) asSymbol.		(Smalltalk at: className) new			name: (each at: #name);			hardwareInterface: (hardwareInterfaces at: deviceName);			yourself].	poseFilter setupFrom: self.! !!AvSensorModel methodsFor: 'execution' stamp: 'Jon 12/23/2005 16:49'!execute	poseFilter execute! !!AvSensorModel methodsFor: 'printing' stamp: 'jon 10/28/2004 12:28'!printOn: aStream	aStream		print: self class;		nextPutAll: ' ('.	hardwareInterfaces keys asSortedCollection		do: [:each | aStream nextPutAll: each]		separatedBy: [aStream nextPutAll: ', '].	aStream nextPut: $)! !!AvSensorModel methodsFor: 'private' stamp: 'jon 10/27/2004 18:13'!sensorsForInterface: hardwareInterface	^self sensors select: [:each | each hardwareInterface == hardwareInterface].! !!AvSensorModel methodsFor: 'private' stamp: 'jon 10/27/2004 22:03'!start: hardwareInterface	(self sensorsForInterface: hardwareInterface) do: [:each |		each synchronize.		hardwareInterface registerResponder: each].	hardwareInterface start! !!AvSensorModel methodsFor: 'logging' stamp: 'Jon 1/27/2006 11:54'!logCurrentInformationTo: stream	sensors do: [:each | each logCurrentInformationTo: stream].! !AvPoseFilter subclass: #AvSimplePoseFilter	instanceVariableNames: 'compass heading pitch roll history'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvSimplePoseFilter commentStamp: 'Jon 12/29/2005 20:50' prior: 0!An AvSimplePoseFilter is a much simpler pose filter, that keeps track of heading, pitch and roll.Instance Variables	compass:		<AvCompassSensor>	heading:		<Number>	pitch:			<Number>	roll:				<Number>compass	- is the object that interfaces to the physical compass sensor	- always has the latest heading, pitch, and rollheading	- a number between 0 and 359pitch	- a number between -90 and 90roll	- a number between -90 and 90!!AvSimplePoseFilter methodsFor: 'initializing' stamp: 'Jon 1/30/2006 12:25'!initialize	super initialize.	heading := 0.	pitch := 0.	roll := 0.	history := AvRingBuffer new: 50.! !!AvSimplePoseFilter methodsFor: 'accessing' stamp: 'Jon 1/30/2006 12:36'!heading	"Answer the filtered heading. We look at the last 5 readings, and average them. If the current reading is within 15 degrees	of the average, then it should be good. If it isn't, check and see if it is within 15 degrees of the last reading. If it is, return	it, otherwise, answer the previous average, with the current reading factored in."	| count sum previousAverage previousHeading |	history size < 5		ifTrue: [^heading].	"Find the average heading over the last 5 readings..."	count := 0.	sum := 0.0.	history last: 5 do: [:each |		count := count + 1.		sum := sum + each].	previousAverage := (sum / count) asFloat.	previousHeading := history last.	^(heading - previousAverage) abs < 15		ifTrue: [heading]		ifFalse: [			(heading - previousHeading) abs < 15				ifTrue: [heading]				ifFalse: [((previousAverage * count + heading) / (count + 1)) asFloat]].! !!AvSimplePoseFilter methodsFor: 'accessing' stamp: 'Jon 12/23/2005 16:49'!pitch	^pitch! !!AvSimplePoseFilter methodsFor: 'accessing' stamp: 'Jon 12/23/2005 16:49'!roll	^roll! !!AvSimplePoseFilter methodsFor: 'building' stamp: 'Jon 12/23/2005 16:51'!setupFrom: aSensorModel	compass := aSensorModel sensorNamed: 'compass'.	compass isNil		ifTrue: [self error: 'No compass for simple pose filter...'].! !!AvSimplePoseFilter methodsFor: 'execution' stamp: 'Jon 1/30/2006 12:25'!execute	"This is where the filter is implemented - for now, just get the values directly from the sensor."	self saveHistory.	heading := compass heading.	pitch := compass pitch.	roll := compass roll.! !!AvSimplePoseFilter methodsFor: 'private' stamp: 'Jon 1/30/2006 12:25'!saveHistory	history addLast: heading.! !Object subclass: #AvYawFilter	instanceVariableNames: 'gyro zeroValue scaleFactor heading updateCount'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Sensors'!!AvYawFilter methodsFor: 'initializing' stamp: 'Jon 11/24/2004 19:44'!initialize	scaleFactor := self cycleMultiplier.	heading := 0.	zeroValue := 511.	updateCount := 0.! !!AvYawFilter methodsFor: 'accessing' stamp: 'Jon 11/24/2004 21:18'!gyro	^ gyro! !!AvYawFilter methodsFor: 'accessing' stamp: 'Jon 11/24/2004 21:19'!gyro: anAvGyroSensor	gyro := anAvGyroSensor.	gyro		when: #sensorChanged		send: #updateFilter		to: self! !!AvYawFilter methodsFor: 'accessing' stamp: 'jon 11/23/2004 13:29'!heading	^ heading! !!AvYawFilter methodsFor: 'accessing' stamp: 'jon 11/23/2004 13:29'!heading: aNumber	heading := aNumber! !!AvYawFilter methodsFor: 'accessing' stamp: 'jon 11/23/2004 13:25'!scaleFactor	^ scaleFactor! !!AvYawFilter methodsFor: 'accessing' stamp: 'jon 11/23/2004 13:25'!scaleFactor: aNumber	scaleFactor := aNumber! !!AvYawFilter methodsFor: 'accessing' stamp: 'Jon 11/24/2004 19:45'!updateCount	^updateCount! !!AvYawFilter methodsFor: 'accessing' stamp: 'Jon 11/24/2004 19:45'!updateCount: anInteger	updateCount := anInteger! !!AvYawFilter methodsFor: 'accessing' stamp: 'jon 11/23/2004 13:25'!zeroValue	^ zeroValue! !!AvYawFilter methodsFor: 'accessing' stamp: 'jon 11/23/2004 13:25'!zeroValue: aNumber	zeroValue := aNumber! !!AvYawFilter methodsFor: 'api' stamp: 'Jon 11/24/2004 21:19'!setZero	zeroValue := gyro value.! !!AvYawFilter methodsFor: 'api' stamp: 'Jon 11/27/2004 19:50'!updateFilter	heading := (heading + (scaleFactor * (zeroValue - gyro value)))  \\ 360.	updateCount := updateCount + 1.! !!AvYawFilter methodsFor: 'private-scale factor' stamp: 'Jon 11/24/2004 14:08'!analogCenter	"Answer the value the A/D converter will return from the ratiometric output of the gyro	when it is not moving."	^((2 raisedToInteger: self analogToDigitalResolution) - 1) * (self voltageCenter / self voltage)! !!AvYawFilter methodsFor: 'private-scale factor' stamp: 'Jon 11/24/2004 13:55'!analogMax	"Answer the value the A/D converter will return from the ratiometric output of the gyro	when it is rotating at its max rate."	^((2 raisedToInteger: self analogToDigitalResolution) - 1) * (self voltageMax / self voltage)! !!AvYawFilter methodsFor: 'private-scale factor' stamp: 'Jon 11/24/2004 13:41'!analogToDigitalResolution	"Answer the resolution, in bits."	^10! !!AvYawFilter methodsFor: 'private-scale factor' stamp: 'Jon 11/24/2004 20:12'!calibrationFactor	"Answer a derived calibration factor."	^90.0 / 105.0! !!AvYawFilter methodsFor: 'private-scale factor' stamp: 'Jon 11/24/2004 20:21'!cycleMultiplier	"Answer the value we multiply the gyro output voltage by to get the number of degrees it has	rotated since the last cycle."	| scale |	scale := (self analogMax - self analogCenter) / self degreesPerCycleAtMaxRate.	^(-1.0 / scale) * self calibrationFactor! !!AvYawFilter methodsFor: 'private-scale factor' stamp: 'Jon 11/24/2004 13:53'!degreesPerCycleAtMaxRate	"Answer the number of degrees the gyro can handle at max rate over one cycle, which is 1/50 second."	^self maxRate / self updateRate! !!AvYawFilter methodsFor: 'private-scale factor' stamp: 'Jon 11/24/2004 13:41'!maxRate	"Answer the max rotation rate of the gyro, in degrees per second."	^75.0! !!AvYawFilter methodsFor: 'private-scale factor' stamp: 'Jon 11/24/2004 13:45'!updateRate	"Answer the update rate, in Hertz."	^50! !!AvYawFilter methodsFor: 'private-scale factor' stamp: 'Jon 11/24/2004 14:07'!voltage	"Answer the supply voltage provided to the gyro, in volts."	^5.0! !!AvYawFilter methodsFor: 'private-scale factor' stamp: 'Jon 11/24/2004 14:08'!voltageCenter	"Answer the ratiometric centerof the gyro output in volts."	^2.5! !!AvYawFilter methodsFor: 'private-scale factor' stamp: 'Jon 11/24/2004 13:52'!voltageMax	"Answer the ratiometric max of the gyro output in volts."	^4.75! !!AvYawFilter methodsFor: 'private-scale factor' stamp: 'Jon 11/24/2004 13:52'!voltageMin	"Answer the ratiometric min of the gyro output in volts."	^0.25! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvYawFilter class	instanceVariableNames: ''!!AvYawFilter class methodsFor: 'instance creation' stamp: 'Jon 11/24/2004 21:20'!on: anAvGyroSensor	^self new		gyro: anAvGyroSensor;		yourself! !Object subclass: #AvActuator	instanceVariableNames: 'name hardwareInterface command'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Actuators'!!AvActuator methodsFor: 'accessing' stamp: 'Jon 12/23/2005 14:50'!command	^command! !!AvActuator methodsFor: 'accessing' stamp: 'Jon 12/23/2005 14:50'!command: aString	command := aString! !!AvActuator methodsFor: 'accessing' stamp: 'jon 10/27/2004 12:48'!hardwareInterface	^ hardwareInterface! !!AvActuator methodsFor: 'accessing' stamp: 'jon 10/27/2004 12:49'!hardwareInterface: anAvHardwareInterface	hardwareInterface := anAvHardwareInterface! !!AvActuator methodsFor: 'accessing' stamp: 'jon 10/27/2004 12:35'!name	^name! !!AvActuator methodsFor: 'accessing' stamp: 'jon 10/27/2004 12:35'!name: aString	name := aString! !!AvActuator methodsFor: 'api' stamp: 'jon 10/27/2004 22:27'!handleResponse	"The device sends this when we have a complete response received."! !!AvActuator methodsFor: 'api' stamp: 'Jon 12/23/2005 16:09'!sendValues	"Send the receiver's values to the device."	hardwareInterface sendCommand: self command for: self! !!AvActuator methodsFor: 'printing' stamp: 'jon 10/27/2004 12:37'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self name;		nextPutAll: ')'! !Object subclass: #AvActuatorModel	instanceVariableNames: 'actuators hardwareInterfaces'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Actuators'!!AvActuatorModel methodsFor: 'accessing' stamp: 'Jon 12/5/2004 09:43'!actuatorNamed: aString	^self actuators		detect: [:each | each name = aString]		ifNone: [nil].! !!AvActuatorModel methodsFor: 'accessing' stamp: 'jon 10/27/2004 12:35'!actuators	^ actuators! !!AvActuatorModel methodsFor: 'accessing' stamp: 'jon 10/27/2004 12:35'!actuators: aDictionary	actuators := aDictionary! !!AvActuatorModel methodsFor: 'accessing' stamp: 'jon 10/27/2004 12:35'!hardwareInterfaces: aDictionary	hardwareInterfaces := aDictionary! !!AvActuatorModel methodsFor: 'api' stamp: 'jon 10/27/2004 22:04'!start	hardwareInterfaces do: [:eachInterface |		self start: eachInterface].! !!AvActuatorModel methodsFor: 'api' stamp: 'jon 10/27/2004 22:32'!stop	hardwareInterfaces do: [:eachInterface |		eachInterface stop].! !!AvActuatorModel methodsFor: 'building' stamp: 'Jon 12/23/2005 14:51'!buildActuatorsFrom: actuatorData	actuators := actuatorData collect: [:each |		| deviceName className |		deviceName := each at: #device.		className := (each at: #class) asSymbol.		(Smalltalk at: className) new			name: (each at: #name);			command: (each at: #command);			hardwareInterface: (hardwareInterfaces at: deviceName);			yourself].! !!AvActuatorModel methodsFor: 'printing' stamp: 'jon 10/28/2004 12:36'!printOn: aStream	aStream		print: self class;		nextPutAll: ' ('.	hardwareInterfaces keys asSortedCollection		do: [:each | aStream nextPutAll: each]		separatedBy: [aStream nextPutAll: ', '].	aStream nextPut: $)! !!AvActuatorModel methodsFor: 'private' stamp: 'jon 10/27/2004 22:01'!actuatorsForInterface: hardwareInterface	^self actuators select: [:each | each hardwareInterface == hardwareInterface].! !!AvActuatorModel methodsFor: 'private' stamp: 'jon 10/27/2004 22:03'!start: hardwareInterface	(self actuatorsForInterface: hardwareInterface) do: [:eachActuator |		hardwareInterface registerResponder: eachActuator].	hardwareInterface start.! !!AvActuatorModel methodsFor: 'logging' stamp: 'Jon 1/27/2006 11:57'!logCurrentInformationTo: stream	actuators do: [:each | each logCurrentInformationTo: stream].! !AvActuator subclass: #AvGHM07MotorActuator	instanceVariableNames: 'revolutionsPerMinute'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Actuators'!!AvGHM07MotorActuator commentStamp: 'Jon 12/23/2005 16:25' prior: 0!An AvGHM07MotorActuator is an actuator that interfaces to a Lynxmotion GHM-07 gearmotor.The specifications on the GHM-07 are:	12 volts DC	595 RPM	21:1 gear ratioInstance Variables	revolutionsPerMinute:		<Number>revolutionsPerMinute	- the number of rpm the motor should be turning	- a number between -600.0 and 600.0, where positive implies forward motion of the robot!!AvGHM07MotorActuator methodsFor: 'sending values' stamp: 'Jon 1/2/2006 15:14'!setRPM: rpm	"Set the receiver's rpm, and then send the new value to the device."	| changed |	changed := revolutionsPerMinute ~= rpm.	revolutionsPerMinute := (rpm max: -600) min: 600.	changed		ifTrue: [self sendValues].! !!AvGHM07MotorActuator methodsFor: 'accessing' stamp: 'Jon 1/3/2006 14:27'!speedByte	"Answer a byte between 0 and 255 inclusive to represent the abs (receiver's speed), which is between 0 and 600 RPM.	Basically, normalize the RPM to between 0.0 and 1.0, and then multiply that value by 255, which gives a value	between 0 and 255 as the final value."	^((revolutionsPerMinute abs / 600.0) * 255) asInteger! !!AvGHM07MotorActuator methodsFor: 'accessing' stamp: 'Jon 12/31/2005 07:43'!speedDirection	"Answer 1 if the speed is negative, otherwise answer 0."	^revolutionsPerMinute negative		ifTrue: [1]		ifFalse: [0].! !!AvGHM07MotorActuator methodsFor: 'logging' stamp: 'Jon 1/27/2006 11:58'!logCurrentInformationTo: stream	stream		nextPutAll: '(';		nextPutAll: self name;		nextPutAll: ': ';		print: revolutionsPerMinute rounded;		nextPutAll: ') '.! !!AvGHM07MotorActuator methodsFor: 'printing' stamp: 'Jon 1/23/2006 20:10'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self name;		nextPutAll: ' - rpm: ';		print: revolutionsPerMinute;		nextPut: $).! !AvActuator subclass: #AvLEDActuator	instanceVariableNames: 'on'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Actuators'!AvActuator subclass: #AvServoActuator	instanceVariableNames: 'angle'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Actuators'!!AvServoActuator methodsFor: 'accessing' stamp: 'Jon 1/2/2006 15:12'!angle	^angle! !!AvServoActuator methodsFor: 'accessing' stamp: 'Jon 1/2/2006 15:12'!angleByte	^angle! !!AvServoActuator methodsFor: 'accessing' stamp: 'Jon 1/2/2006 15:14'!setAngle: anInteger	| changed |	changed := angle ~= anInteger.	angle := anInteger.	changed		ifTrue: [self sendValues].! !!AvServoActuator methodsFor: 'logging' stamp: 'Jon 1/27/2006 11:59'!logCurrentInformationTo: stream	stream		nextPutAll: '(';		nextPutAll: self name;		nextPutAll: ': ';		print: (angle isNil ifTrue: [0] ifFalse: [angle]) rounded;		nextPutAll: ') '.! !Object subclass: #AvHardwareInterface	instanceVariableNames: 'device inPackets outPackets pendingBytes running'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Hardware Interface'!!AvHardwareInterface methodsFor: 'initializing' stamp: 'jon 10/27/2004 22:40'!initialize	pendingBytes := ByteArray new.	running := false.	super initialize! !!AvHardwareInterface methodsFor: 'accessing' stamp: 'Jon 1/23/2006 20:07'!addIncomingPacket: packet	Transcript cr; show: 'Got Packet: ', packet printString.	inPackets nextPut: packet.! !!AvHardwareInterface methodsFor: 'accessing' stamp: 'jon 10/22/2004 19:08'!allInPackets	| all |	all := OrderedCollection new.	[inPackets isEmpty] whileFalse: [		all add: inPackets next].	^all! !!AvHardwareInterface methodsFor: 'accessing' stamp: 'jon 10/23/2004 16:22'!device	^device! !!AvHardwareInterface methodsFor: 'api' stamp: 'Jon 12/23/2005 15:00'!addOutPacket: anObject	outPackets nextPut: anObject.! !!AvHardwareInterface methodsFor: 'api' stamp: 'jon 10/27/2004 22:30'!registerResponder: responder	"Register the given responder, which should be an AvSensor or AvActuator, with the device."	device registerResponder: responder! !!AvHardwareInterface methodsFor: 'api' stamp: 'Jon 1/24/2006 12:27'!sendCommand: commandName for: anActuator	device sendCommand: commandName for: anActuator! !!AvHardwareInterface methodsFor: 'api' stamp: 'jon 10/27/2004 22:39'!start	self isRunning		ifTrue: [^self].	self isWriteOnly		ifFalse: [self initializeInProcess].	self isReadOnly		ifFalse: [self initializeOutProcess].	running := true.! !!AvHardwareInterface methodsFor: 'api' stamp: 'jon 11/22/2004 12:15'!stop	self isRunning		ifFalse: [^self].	running := false.	"We need this next line to release the handler process waiting on the shared queue..."	inPackets nextPut: #() asByteArray! !!AvHardwareInterface methodsFor: 'testing' stamp: 'jon 10/27/2004 18:09'!isConnected	^self subclassResponsibility! !!AvHardwareInterface methodsFor: 'testing' stamp: 'jon 10/27/2004 15:14'!isReadOnly	^device isReadOnly! !!AvHardwareInterface methodsFor: 'testing' stamp: 'jon 10/27/2004 15:14'!isReadWrite	^device isReadWrite! !!AvHardwareInterface methodsFor: 'testing' stamp: 'jon 10/27/2004 20:53'!isRunning	^running! !!AvHardwareInterface methodsFor: 'testing' stamp: 'jon 10/27/2004 15:14'!isWriteOnly	^device isWriteOnly! !!AvHardwareInterface methodsFor: 'printing' stamp: 'jon 10/27/2004 12:51'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self device name;		nextPut: $)! !!AvHardwareInterface methodsFor: 'private' stamp: 'jon 10/27/2004 20:57'!close! !!AvHardwareInterface methodsFor: 'private' stamp: 'jon 10/27/2004 23:21'!handleIncomingPacket	| next |	next := inPackets next.	(self isRunning and: [next notEmpty])		ifTrue: [device handleIncomingPacket: next]! !!AvHardwareInterface methodsFor: 'private' stamp: 'jon 10/27/2004 21:07'!inHandlerProcessName	^device name, ' HW Handler (in)'! !!AvHardwareInterface methodsFor: 'private' stamp: 'jon 10/24/2004 08:59'!inProcessName	^device name, ' HW Interface (in)'! !!AvHardwareInterface methodsFor: 'private' stamp: 'Jon 11/24/2004 20:09'!initializeInProcess	inPackets := SharedQueue new.	[self runInProcess] forkAt: self processPriority named: self inProcessName.	[self runHandlerProcess] forkAt: self processPriority named: self inHandlerProcessName.! !!AvHardwareInterface methodsFor: 'private' stamp: 'jon 10/27/2004 16:45'!initializeOutProcess	outPackets := SharedQueue new.	"outProcess := [self runOutProcess] forkAt: self processPriority named: self outProcessName"! !!AvHardwareInterface methodsFor: 'private' stamp: 'jon 10/24/2004 08:58'!outProcessName	^device name, ' HW Interface (out)'! !!AvHardwareInterface methodsFor: 'private' stamp: 'jon 10/27/2004 16:28'!processIncomingData	self device isLineBased		ifTrue: [^self processIncomingLine].	self device isPacketBased		ifTrue: [^self processIncomingPacket].! !!AvHardwareInterface methodsFor: 'private' stamp: 'Jon 1/15/2006 15:05'!processPriority	^Processor userSchedulingPriority! !!AvHardwareInterface methodsFor: 'private' stamp: 'jon 10/27/2004 21:07'!runHandlerProcess	[self isRunning] whileTrue: [		self handleIncomingPacket.		(Delay forMilliseconds: 10) wait.		Processor yield].! !!AvHardwareInterface methodsFor: 'private' stamp: 'jon 10/27/2004 20:57'!runInProcess	[self isRunning] whileTrue: [		self processIncomingData.		(Delay forMilliseconds: 10) wait.		Processor yield].	self close! !!AvHardwareInterface methodsFor: 'private' stamp: 'jon 10/27/2004 15:21'!setDevice: avDevice	device := avDevice.! !Object subclass: #AvSerialPacket	instanceVariableNames: 'command length rawBytes'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Hardware Interface'!!AvSerialPacket methodsFor: 'accessing' stamp: 'jon 10/15/2004 21:12'!byteAt: index	"Answer the byte (8 bits) at the given index. The index is 1-relative, and looks at the data portion of the packet."	^rawBytes byteAt: index + 2! !!AvSerialPacket methodsFor: 'accessing' stamp: 'jon 10/15/2004 21:10'!command	^command! !!AvSerialPacket methodsFor: 'accessing' stamp: 'jon 10/15/2004 21:10'!length	^length! !!AvSerialPacket methodsFor: 'private' stamp: 'jon 10/15/2004 21:10'!initializeFrom: aByteArray	command := aByteArray first.	length := aByteArray at: 2.	rawBytes := aByteArray.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvSerialPacket class	instanceVariableNames: ''!!AvSerialPacket class methodsFor: 'instance creation' stamp: 'jon 10/15/2004 21:09'!newFrom: byteArray	^self new		initializeFrom: byteArray;		yourself! !AvHardwareInterface subclass: #AvSerialPortInterface	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Hardware Interface'!!AvSerialPortInterface commentStamp: 'Jon 1/16/2005 09:31' prior: 0!An AvSerialPortInterface is a subclass of AvHardwareInterface that handles interfacing with standard RS-232 serial ports.!!AvSerialPortInterface methodsFor: 'accessing' stamp: 'jon 10/27/2004 15:23'!serialPort	^device serialPort! !!AvSerialPortInterface methodsFor: 'api' stamp: 'jon 10/27/2004 20:59'!close	self device close! !!AvSerialPortInterface methodsFor: 'api' stamp: 'jon 10/27/2004 16:21'!synchronizeFrom: syncBlock	"Synchronize the receiver so data from the serial port is ready."	syncBlock value: self serialPort! !!AvSerialPortInterface methodsFor: 'testing' stamp: 'jon 10/27/2004 18:10'!isConnected	^self serialPort notNil and: [self serialPort isConnected]! !!AvSerialPortInterface methodsFor: 'private' stamp: 'jon 10/27/2004 21:01'!processIncomingLine	| lineStream done gotLine |	lineStream := WriteStream with: pendingBytes.	done := self isRunning not.	gotLine := false.	[done] whileFalse: [		| bytes |		lineStream nextPutAll: (bytes := self readSerialBytes).		((pendingBytes includes: 13) or: [bytes includes: 13])			ifTrue: [				lineStream := ReadStream on: lineStream contents.				self addIncomingPacket: (lineStream upTo: 13) asString withBlanksTrimmed.				pendingBytes := lineStream upToEnd.				gotLine := true].		done := self isRunning not or: [gotLine]].	Processor yield.! !!AvSerialPortInterface methodsFor: 'private' stamp: 'jon 11/22/2004 12:08'!processIncomingPacket	| command packetLength dataStream done gotPacket |	[self isRunning and: [pendingBytes size < 2]]		whileTrue: [			Processor yield.			pendingBytes := pendingBytes, self readSerialBytes].	self isRunning		ifFalse: [^self].	command := pendingBytes first.	packetLength := pendingBytes second.	dataStream := WriteStream with: pendingBytes.	done := self isRunning not.	gotPacket := false.	[done] whileFalse: [		| bytes |		dataStream nextPutAll: (bytes := self readSerialBytes).		((pendingBytes size + bytes size) >= (packetLength + 2))			ifTrue: [				dataStream := ReadStream on: dataStream contents.				self addIncomingPacket: (dataStream next: packetLength + 2).				pendingBytes := dataStream upToEnd.				gotPacket := true].		done := self isRunning not or: [gotPacket]].	Processor yield.! !!AvSerialPortInterface methodsFor: 'private' stamp: 'Jon 12/23/2005 15:23'!readSerialBytes	^[self device accessSerialPortWhile: [:serialPort | serialPort readByteArray]]		on: Error		do: [:exception | self serialPort close. self error: 'Error reading serial port...'].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvSerialPortInterface class	instanceVariableNames: ''!!AvSerialPortInterface class methodsFor: 'instance creation' stamp: 'jon 10/27/2004 15:17'!on: aDevice	^self new		setDevice: aDevice;		yourself! !Object subclass: #AvDevice	instanceVariableNames: 'vendor name commands readable writeable dataFormat responders pendingCommand responses'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDevice commentStamp: 'Jon 3/20/2003 22:14' prior: 0!AvDeviceAvDevice is a class that represents an abstract device that this autonomous controller can connect to.The device may be a sensor, a motor, a micro-controller, or anything else that the computer connects toand can send commands to, and (optionally) get responses back from.Instance Variables:	vendor		<String>				The name of the company that builds this device	name		<String>				The name of this device	commands	<Dictionary key: <Symbol> value: <AvDeviceCommand>>				A collection of commands that this device responds to, keyed on command name.!!AvDevice methodsFor: 'initializing' stamp: 'jon 10/27/2004 22:05'!initialize	readable := true.	writeable := true.	responders := Dictionary new.	super initialize.! !!AvDevice methodsFor: 'accessing' stamp: 'Jon 3/24/2003 09:15'!commands	^commands! !!AvDevice methodsFor: 'accessing' stamp: 'jon 10/23/2004 15:41'!commands: aDictionary	commands := aDictionary! !!AvDevice methodsFor: 'accessing' stamp: 'Jon 3/24/2003 09:14'!name	^name! !!AvDevice methodsFor: 'accessing' stamp: 'Jon 3/24/2003 09:14'!name: aString	name := aString! !!AvDevice methodsFor: 'accessing' stamp: 'Jon 10/26/2005 21:46'!pendingCommand	^pendingCommand! !!AvDevice methodsFor: 'accessing' stamp: 'Jon 10/26/2005 21:46'!pendingCommand: aString	pendingCommand := aString! !!AvDevice methodsFor: 'accessing' stamp: 'Jon 1/2/2006 15:55'!registerResponder: responder	commands do: [:eachCommand |		eachCommand responderName = responder name			ifTrue: [				responders					at: eachCommand responseCommand					put: (responder -> eachCommand).				eachCommand removeResponderCommand]]! !!AvDevice methodsFor: 'accessing' stamp: 'Jon 3/24/2003 09:15'!vendor	^vendor! !!AvDevice methodsFor: 'accessing' stamp: 'Jon 3/24/2003 09:15'!vendor: aString	vendor := aString! !!AvDevice methodsFor: 'commands' stamp: 'Jon 1/3/2006 16:24'!avrcamhandleIncomingPacket: aByteArray	"A command/response has come from the device. Handle it."	| responderPair count |	pendingCommand isNil		ifTrue: [^self error: 'Got unexpected incoming packet...'].	responderPair := responders		at: pendingCommand 		ifAbsent: [^self error: 'no responder for command: ', pendingCommand].	count := responderPair value responseSize.	responses add: aByteArray.	responses size = count		ifTrue: [			| totalResponse |			totalResponse := count = 1				ifTrue: [aByteArray]				ifFalse: [					(responses						inject: (WriteStream on: (String new: 20))						into: [:sum :each | sum nextPutAll: each asString; cr; yourself]) contents].			responderPair value handleCommand: totalResponse for: responderPair key].! !!AvDevice methodsFor: 'commands' stamp: 'Jon 1/24/2006 12:28'!handleIncomingPacket: aByteArray	"A command/response has come from the device. Handle it."	| responderPair |	AvSystem showIncomingPacketsOnTranscript		ifTrue: [Transcript cr; show: (pendingCommand isNil ifTrue: ['push: '] ifFalse: ['']), aByteArray printString].	"If we're not waiting on a command, we're looking at a push command."	pendingCommand isNil		ifTrue: [pendingCommand := aByteArray first].	responderPair := responders		at: pendingCommand 		ifAbsent: [^self error: 'no responder for command: ', pendingCommand].	pendingCommand := nil.	responderPair value handleCommand: aByteArray for: responderPair key.! !!AvDevice methodsFor: 'commands' stamp: 'Jon 12/23/2005 15:12'!sendCommand: commandName	self sendCommand: commandName for: nil! !!AvDevice methodsFor: 'commands' stamp: 'Jon 1/2/2006 16:23'!sendCommand: commandName for: anActuator	| command commandBytes |	command := self commandNamed: commandName.	commandBytes := command buildCommandBytesFor: anActuator.	self sendCommandBytes: commandBytes.	command hasResponse		ifTrue: [			pendingCommand := responders keys anyOne isString				ifTrue: [commandBytes asString withBlanksTrimmed]				ifFalse: [commandBytes asByteArray first].			responses := OrderedCollection new].! !!AvDevice methodsFor: 'commands' stamp: 'jon 8/23/2004 15:09'!sendCommandBytes: commandBytes	"Send the given command bytes over whatever port receiver is connected to."	self subclassResponsibility! !!AvDevice methodsFor: 'testing' stamp: 'jon 10/27/2004 16:27'!isLineBased	^dataFormat == #line! !!AvDevice methodsFor: 'testing' stamp: 'jon 10/27/2004 16:28'!isPacketBased	^dataFormat == #packet! !!AvDevice methodsFor: 'testing' stamp: 'jon 10/27/2004 12:16'!isReadOnly	^readable & writeable not! !!AvDevice methodsFor: 'testing' stamp: 'jon 10/27/2004 12:16'!isReadWrite	^readable & writeable! !!AvDevice methodsFor: 'testing' stamp: 'jon 10/27/2004 12:16'!isWriteOnly	^readable not & writeable! !!AvDevice methodsFor: 'printing' stamp: 'Jon 3/24/2003 15:35'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self vendor;		nextPutAll: ' ';		nextPutAll: self name;		nextPut: $)! !!AvDevice methodsFor: 'private-building' stamp: 'jon 10/22/2004 22:28'!buildCommands: commandNames fromMap: map	commands := Dictionary new.	commandNames do: [:eachName |		commands at: eachName put: (AvDeviceCommand name: eachName buildFrom: (map at: eachName))]! !!AvDevice methodsFor: 'private-building' stamp: 'Jon 11/2/2005 12:57'!buildFromDeviceFileMap: map	| productInformation |	productInformation := map at: #ProductInformation.	self		vendor: (productInformation at: #VendorName ifAbsent: [self errorDeviceFileMissingToken: 'VendorName']);		name: (productInformation at: #ProductName ifAbsent: [self errorDeviceFileMissingToken: 'ProductName']);		setReadWriteFrom: (productInformation at: #ReadWrite ifAbsent: ['read write']);		setDataFormatFrom: (productInformation at: #DataFormat ifAbsent: [self errorDeviceFileMissingToken: 'DataFormat']).	self		buildCommands: (map keys select: [:each | each ~~ #ProductInformation])		fromMap: map! !!AvDevice methodsFor: 'private-building' stamp: 'jon 10/27/2004 16:27'!setDataFormatFrom: aString	(#('line' 'packet') includes: aString)		ifFalse: [self error: 'Bad DataFormat: ', aString].	dataFormat := aString asSymbol! !!AvDevice methodsFor: 'private-building' stamp: 'jon 10/27/2004 12:15'!setReadWriteFrom: aString	readable := aString asLowercase includesSubString: 'read'.	writeable := aString asLowercase includesSubString: 'write'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDevice class	instanceVariableNames: ''!!AvDevice class methodsFor: 'instance creation' stamp: 'Jon 3/25/2003 11:48'!fromFilename: filename	| file |	file := FileStream readOnlyFileNamed: filename.	^[AvDevice fromStream: file] ensure: [file close].! !!AvDevice class methodsFor: 'instance creation' stamp: 'Jon 3/24/2003 11:38'!fromStream: aStream	"Build a new instance of one of the receiver's subclasses, and populate it from the data contained in aStream."	^AvDeviceFileReader readFromStream: aStream! !!AvDevice class methodsFor: 'device file support' stamp: 'jon 10/20/2004 18:42'!deviceInterface	^'Indirect'! !!AvDevice class methodsFor: 'private' stamp: 'jon 10/20/2004 18:43'!concreteClassForDeviceInterface: deviceInterface ifNone: absentBlock	"Find the concrete subclass that handles devices with the given interface."	^self withAllSubclasses		detect: [:each | each deviceInterface asLowercase = deviceInterface asLowercase]		ifNone: absentBlock! !!AvDevice class methodsFor: 'private' stamp: 'jon 10/26/2004 22:49'!fromFileMap: map	| deviceInterface deviceClass productInformation |	productInformation := map at: #ProductInformation.	deviceInterface := productInformation at: #Interface ifAbsent: [self errorDeviceFileMissingToken: 'Interface'].	deviceClass := self concreteClassForDeviceInterface: deviceInterface ifNone: [^self errorBadDeviceInterface: deviceInterface].	^deviceClass new		buildFromDeviceFileMap: map;		yourself! !Object subclass: #AvDeviceCommand	instanceVariableNames: 'name responseCommand commandDescriptor responseDescriptor'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceCommand commentStamp: 'Jon 3/20/2003 22:20' prior: 0!AvDeviceCommandAvDeviceCommand is a class that represents the format of a single command, plus the response expected from that command.Instance Variables:	name				<String>						The command name	commandDescriptor	<AvDeviceDataDescriptor>						A set of mappings that describe the data in a command sent to the device	responseDescriptor	<AvDeviceDataDescriptor>						A set of mappings that describe the data in a response sent from the device!!AvDeviceCommand methodsFor: 'accessing' stamp: 'Jon 3/24/2003 14:33'!name	^name! !!AvDeviceCommand methodsFor: 'accessing' stamp: 'Jon 3/24/2003 14:33'!name: aSymbol	name := aSymbol! !!AvDeviceCommand methodsFor: 'accessing' stamp: 'Jon 10/26/2005 22:01'!removeResponderCommand	commandDescriptor removeMappingNamed: #responderName! !!AvDeviceCommand methodsFor: 'accessing' stamp: 'jon 10/27/2004 22:17'!responseCommand	^responseCommand! !!AvDeviceCommand methodsFor: 'commands' stamp: 'jon 10/28/2004 11:38'!handleCommand: aByteArray for: responder	"A command/response has come from the device. Handle it."	responseDescriptor extractFrom: aByteArray for: responder.	"We've extracted all the data, and given it to the responder. Now tell it we're done."	responder handleResponse! !!AvDeviceCommand methodsFor: 'extracting' stamp: 'Jon 3/25/2003 12:01'!extractResponseFrom: rawBytes	^responseDescriptor extractFrom: rawBytes! !!AvDeviceCommand methodsFor: 'building' stamp: 'Jon 12/23/2005 15:13'!buildCommandBytesFor: anObject	^commandDescriptor buildBytesFor: anObject! !!AvDeviceCommand methodsFor: 'testing' stamp: 'Jon 3/2/2005 12:32'!hasResponse	"Some commands get a response back again. Answer true if the receiver is one of those..."	^responseDescriptor notNil and: [responseDescriptor isEmpty not].! !!AvDeviceCommand methodsFor: 'testing' stamp: 'Jon 10/26/2005 23:26'!responseSize	^responseDescriptor isNil		ifTrue: [0]		ifFalse: [responseDescriptor mappingsCount]! !!AvDeviceCommand methodsFor: 'printing' stamp: 'jon 10/27/2004 22:15'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self name;		nextPut: $)! !!AvDeviceCommand methodsFor: 'private' stamp: 'jon 10/27/2004 22:14'!buildFrom: aDictionary	| commandMap |	commandMap := (aDictionary includesKey: #pushCommand)		ifTrue: [aDictionary at: #pushCommand]		ifFalse: [aDictionary at: #command].	commandDescriptor := AvDeviceDataDescriptor buildFrom: commandMap.	responseDescriptor := AvDeviceDataDescriptor buildFrom: (aDictionary at: #response).	commandDescriptor name: self name.	responseDescriptor name: self name.	self buildResponseHandler! !!AvDeviceCommand methodsFor: 'private' stamp: 'jon 10/27/2004 22:49'!buildResponseHandler	| commandMapping |	commandMapping := commandDescriptor command.	commandMapping isNil		ifTrue: [^self].	responseCommand := commandMapping defaultValue.	responseDescriptor fixSelectors! !!AvDeviceCommand methodsFor: 'private' stamp: 'Jon 1/1/2006 21:28'!responderName	| mapping |	mapping := commandDescriptor mappingForSelector: #responderName.	^mapping isNil		ifTrue: [nil]		ifFalse: [mapping defaultValue].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceCommand class	instanceVariableNames: ''!!AvDeviceCommand class methodsFor: 'instance creation' stamp: 'Jon 3/24/2003 14:33'!name: aSymbol buildFrom: aDictionary	^self new		name: aSymbol;		buildFrom: aDictionary;		yourself! !Object subclass: #AvDeviceData	instanceVariableNames: 'rawData data'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceData commentStamp: 'Jon 3/20/2003 22:24' prior: 0!AvDeviceDataAvDeviceData is a class that represents the actual data that is sent to or received from a device.Instance Variables:	rawData	<ByteArray or: String>				The raw bytes of the data, in device-native format	data		<Dictionary key: <Symbol> value: <Object>>				The data in Smalltalk format!Object subclass: #AvDeviceDataDescriptor	instanceVariableNames: 'name mappings'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataDescriptor methodsFor: 'accessing' stamp: 'jon 10/23/2004 16:13'!mappingForSelector: selector	^mappings		detect: [:each | each selector = selector]		ifNone: [nil]! !!AvDeviceDataDescriptor methodsFor: 'accessing' stamp: 'Jon 10/26/2005 23:26'!mappingsCount	^mappings size! !!AvDeviceDataDescriptor methodsFor: 'accessing' stamp: 'Jon 3/24/2003 15:39'!name	^name! !!AvDeviceDataDescriptor methodsFor: 'accessing' stamp: 'Jon 3/24/2003 15:40'!name: aSymbol	name := aSymbol! !!AvDeviceDataDescriptor methodsFor: 'accessing' stamp: 'Jon 10/26/2005 22:01'!removeMappingNamed: aString	mappings := mappings reject: [:each | each selector = aString]! !!AvDeviceDataDescriptor methodsFor: 'building' stamp: 'Jon 1/2/2006 15:38'!buildBytesFor: anObject	| stream |	stream := (ByteArray new: 10) writeStream.	mappings do: [:each |		each selector ~= #responderName			ifTrue: [each buildOn: stream for: anObject]].	^stream contents! !!AvDeviceDataDescriptor methodsFor: 'extracting' stamp: 'jon 10/23/2004 15:53'!command	"Answer the #command mapping."	^mappings		detect: [:each | each selector == #command]		ifNone: [nil]! !!AvDeviceDataDescriptor methodsFor: 'extracting' stamp: 'Jon 3/25/2003 12:18'!extractFrom: rawBytes	| object stream |	object := Dictionary new.	stream := rawBytes asByteArray readStream.	mappings do: [:each |		object			at: each selector			put: (each extractFrom: stream)].	^object! !!AvDeviceDataDescriptor methodsFor: 'extracting' stamp: 'jon 10/28/2004 11:37'!extractFrom: rawBytes for: responder	| stream |	stream := rawBytes asByteArray readStream.	mappings do: [:each |		responder perform: each selector with: (each extractFrom: stream)].! !!AvDeviceDataDescriptor methodsFor: 'extracting' stamp: 'jon 10/27/2004 22:50'!fixSelectors	mappings do: [:each |		each selector last = $:			ifFalse: [each selector: (each selector, ':') asSymbol]].! !!AvDeviceDataDescriptor methodsFor: 'testing' stamp: 'Jon 3/2/2005 12:32'!isEmpty	^mappings isEmpty! !!AvDeviceDataDescriptor methodsFor: 'printing' stamp: 'Jon 3/24/2003 15:36'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self name;		nextPut: $)! !!AvDeviceDataDescriptor methodsFor: 'private' stamp: 'jon 10/23/2004 16:30'!buildFrom: mappingArray	mappings := mappingArray collect: [:each |		| type defaultValue mapping |		type := each value first.		defaultValue := each value size = 1			ifTrue: [nil]			ifFalse: [each value last].		mapping := AvDeviceDataMapping type: type.		mapping isNil			ifTrue: [^self errorDeviceFileUnknownType: type forCommandName: name].		mapping			selector: each key;			setDefaultValueFrom: defaultValue;			yourself].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataDescriptor class	instanceVariableNames: ''!!AvDeviceDataDescriptor class methodsFor: 'instance creation' stamp: 'Jon 3/24/2003 14:37'!buildFrom: mappingArray	^self new		buildFrom: mappingArray;		yourself! !Object subclass: #AvDeviceDataMapping	instanceVariableNames: 'selector defaultValue'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataMapping methodsFor: 'initializing' stamp: 'Jon 3/25/2003 12:08'!initialize! !!AvDeviceDataMapping methodsFor: 'accessing' stamp: 'Jon 3/25/2003 11:49'!byteSize	^self subclassResponsibility! !!AvDeviceDataMapping methodsFor: 'accessing' stamp: 'Jon 3/24/2003 14:45'!defaultValue	^defaultValue! !!AvDeviceDataMapping methodsFor: 'accessing' stamp: 'Jon 3/24/2003 14:45'!defaultValue: anObject	defaultValue := anObject! !!AvDeviceDataMapping methodsFor: 'accessing' stamp: 'jon 10/23/2004 16:33'!offset	^0! !!AvDeviceDataMapping methodsFor: 'accessing' stamp: 'Jon 3/24/2003 14:44'!selector	^selector! !!AvDeviceDataMapping methodsFor: 'accessing' stamp: 'Jon 3/24/2003 14:45'!selector: aSymbol	selector := aSymbol! !!AvDeviceDataMapping methodsFor: 'building' stamp: 'Jon 12/23/2005 15:13'!buildOn: aStream for: anObject	self subclassResponsibility! !!AvDeviceDataMapping methodsFor: 'extracting' stamp: 'Jon 3/25/2003 12:03'!extractFrom: rawBytes	self subclassResponsibility! !!AvDeviceDataMapping methodsFor: 'printing' stamp: 'Jon 3/25/2003 11:47'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self selector.	self defaultValue isNil		ifFalse: [aStream nextPutAll: ': ', self defaultValue printString].	aStream nextPut: $)! !!AvDeviceDataMapping methodsFor: 'private' stamp: 'jon 10/22/2004 22:10'!setDefaultValueFrom: aString	| value |	(aString isNil or: [aString isEmpty])		ifTrue: [^self defaultValue: nil].	value := [Compiler evaluate: aString] ifError: [:error :receiver | nil].	(value isString and: [value size = 1])		ifTrue: [value := value first asciiValue].	self defaultValue: value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataMapping class	instanceVariableNames: ''!!AvDeviceDataMapping class methodsFor: 'private' stamp: 'Jon 3/22/2003 21:47'!concreteClassForType: type ifNone: absentBlock	"Find the concrete subclass that handles devices with the given type."	^self allSubclasses		detect: [:each | each type asLowercase = type asLowercase]		ifNone: absentBlock! !!AvDeviceDataMapping class methodsFor: 'instance creation' stamp: 'Jon 3/25/2003 12:08'!type: aString	^((self concreteClassForType: aString ifNone: [^nil]) new)		initialize;		yourself! !!AvDeviceDataMapping class methodsFor: 'type' stamp: 'Jon 3/24/2003 19:51'!type	^''! !AvDeviceDataMapping subclass: #AvDeviceDataFloatMapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!AvDeviceDataFloatMapping subclass: #AvDeviceDataDoublePrecisionFloatMapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataDoublePrecisionFloatMapping methodsFor: 'accessing' stamp: 'Jon 3/25/2003 11:49'!byteSize	^8! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataDoublePrecisionFloatMapping class	instanceVariableNames: ''!!AvDeviceDataDoublePrecisionFloatMapping class methodsFor: 'type' stamp: 'Jon 3/22/2003 21:48'!type	^'Double'! !AvDeviceDataMapping subclass: #AvDeviceDataIntegerMapping	instanceVariableNames: 'signed byteOrder'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataIntegerMapping methodsFor: 'initializing' stamp: 'Jon 3/25/2003 12:06'!initialize	super initialize.	signed := false! !!AvDeviceDataIntegerMapping methodsFor: 'accessing' stamp: 'Jon 3/25/2003 12:06'!signed	^signed! !!AvDeviceDataIntegerMapping methodsFor: 'accessing' stamp: 'Jon 3/25/2003 12:06'!signed: aBoolean	signed := aBoolean! !!AvDeviceDataIntegerMapping methodsFor: 'extrating' stamp: 'Jon 3/25/2003 12:17'!extractFrom: stream	^(stream next: self byteSize)		integerAt: 1		size: self byteSize		signed: self signed! !AvDeviceDataIntegerMapping subclass: #AvDeviceDataInteger16Mapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataInteger16Mapping methodsFor: 'building' stamp: 'Jon 3/25/2003 12:53'!buildOn: aStream	self signed		ifTrue: [aStream int16: self defaultValue]		ifFalse: [aStream uint16: self defaultValue]! !!AvDeviceDataInteger16Mapping methodsFor: 'accessing' stamp: 'Jon 3/25/2003 11:50'!byteSize	^2! !!AvDeviceDataInteger16Mapping methodsFor: 'extrating' stamp: 'jon 8/27/2004 13:17'!extractFrom: aStream	^(aStream next: 2)		unsignedShortAt: 1 bigEndian: false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataInteger16Mapping class	instanceVariableNames: ''!!AvDeviceDataInteger16Mapping class methodsFor: 'type' stamp: 'Jon 3/22/2003 21:49'!type	^'Integer16'! !AvDeviceDataIntegerMapping subclass: #AvDeviceDataInteger32Mapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataInteger32Mapping methodsFor: 'accessing' stamp: 'Jon 3/25/2003 11:50'!byteSize	^4! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataInteger32Mapping class	instanceVariableNames: ''!!AvDeviceDataInteger32Mapping class methodsFor: 'type' stamp: 'Jon 3/22/2003 21:49'!type	^'Integer32'! !AvDeviceDataIntegerMapping subclass: #AvDeviceDataInteger64Mapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataInteger64Mapping methodsFor: 'accessing' stamp: 'Jon 3/25/2003 11:50'!byteSize	^8! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataInteger64Mapping class	instanceVariableNames: ''!!AvDeviceDataInteger64Mapping class methodsFor: 'type' stamp: 'Jon 3/22/2003 21:49'!type	^'Integer64'! !AvDeviceDataIntegerMapping subclass: #AvDeviceDataInteger8Mapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataInteger8Mapping methodsFor: 'accessing' stamp: 'Jon 3/25/2003 11:50'!byteSize	^1! !!AvDeviceDataInteger8Mapping methodsFor: 'building' stamp: 'Jon 12/23/2005 15:16'!buildOn: aStream for: anObject	aStream nextPut:  (self defaultValue isNil		ifTrue: [anObject perform: selector]		ifFalse: [self defaultValue]).! !!AvDeviceDataInteger8Mapping methodsFor: 'extracting' stamp: 'jon 8/27/2004 13:14'!extractFrom: aStream	^aStream next! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataInteger8Mapping class	instanceVariableNames: ''!!AvDeviceDataInteger8Mapping class methodsFor: 'type' stamp: 'Jon 3/22/2003 21:49'!type	^'Integer8'! !AvDeviceDataFloatMapping subclass: #AvDeviceDataSinglePrecisionFloatMapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataSinglePrecisionFloatMapping methodsFor: 'accessing' stamp: 'Jon 3/25/2003 11:49'!byteSize	^4! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataSinglePrecisionFloatMapping class	instanceVariableNames: ''!!AvDeviceDataSinglePrecisionFloatMapping class methodsFor: 'type' stamp: 'Jon 3/22/2003 21:48'!type	^'Single'! !AvDeviceDataMapping subclass: #AvDeviceDataStringMapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataStringMapping methodsFor: 'accessing' stamp: 'Jon 3/25/2003 11:50'!byteSize	^0! !!AvDeviceDataStringMapping methodsFor: 'building' stamp: 'Jon 12/23/2005 15:17'!buildOn: aStream for: anObject	aStream nextPutAll: (self defaultValue isNil		ifTrue: [anObject perform: self selector]		ifFalse: [self defaultValue asByteArray]).! !AvDeviceDataStringMapping subclass: #AvDeviceDataDelimitedStringMapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataDelimitedStringMapping methodsFor: 'extracting' stamp: 'Jon 3/25/2003 12:16'!extractFrom: stream	^(stream upTo: self defaultValue) asString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataDelimitedStringMapping class	instanceVariableNames: ''!!AvDeviceDataDelimitedStringMapping class methodsFor: 'type' stamp: 'Jon 3/25/2003 12:14'!type	^'DelimitedString'! !AvDeviceDataDelimitedStringMapping subclass: #AvDeviceDataDelimitedAsciiNumberMapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataDelimitedAsciiNumberMapping methodsFor: 'extracting' stamp: 'Jon 3/25/2003 12:23'!extractFrom: stream	^(super extractFrom: stream) asNumber! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataDelimitedAsciiNumberMapping class	instanceVariableNames: ''!!AvDeviceDataDelimitedAsciiNumberMapping class methodsFor: 'type' stamp: 'Jon 3/25/2003 12:22'!type	^'DelimitedAsciiNumber'! !AvDeviceDataDelimitedStringMapping subclass: #AvDeviceDataDelimitedByteMapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataDelimitedByteMapping methodsFor: 'extracting' stamp: 'Jon 3/3/2005 12:50'!extractFrom: stream	^(stream upTo: self defaultValue) asByteArray! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataDelimitedByteMapping class	instanceVariableNames: ''!!AvDeviceDataDelimitedByteMapping class methodsFor: 'type' stamp: 'Jon 3/3/2005 12:51'!type	^'DelimitedBytes'! !AvDeviceDataStringMapping subclass: #AvDeviceDataLineDelimitedStringMapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvDeviceDataLineDelimitedStringMapping methodsFor: 'extracting' stamp: 'Jon 10/26/2005 23:47'!extractFrom: stream	stream next: self offset.	^(stream upTo: 13) asString! !!AvDeviceDataLineDelimitedStringMapping methodsFor: 'building' stamp: 'Jon 12/23/2005 15:19'!buildOn: aStream for: anObject	aStream nextPutAll: (self defaultValue isNil		ifTrue: [anObject perform: self selector]		ifFalse: [self defaultValue asByteArray]).	aStream nextPut: 13.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataLineDelimitedStringMapping class	instanceVariableNames: ''!!AvDeviceDataLineDelimitedStringMapping class methodsFor: 'type' stamp: 'Jon 3/24/2003 19:50'!type	^'StringLine'! !AvDeviceDataStringMapping subclass: #AvDeviceDataSizePrefixedStringMapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataSizePrefixedStringMapping class	instanceVariableNames: ''!!AvDeviceDataSizePrefixedStringMapping class methodsFor: 'type' stamp: 'Jon 3/22/2003 21:50'!type	^'String'! !AvDeviceDataStringMapping subclass: #AvDeviceDataZeroDelimitedStringMapping	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceDataZeroDelimitedStringMapping class	instanceVariableNames: ''!!AvDeviceDataZeroDelimitedStringMapping class methodsFor: 'type' stamp: 'Jon 3/22/2003 21:50'!type	^'StringZ'! !Object subclass: #AvFileReader	instanceVariableNames: ''	classVariableNames: 'TokenDelimiters'	poolDictionaries: ''	category: 'Av-Device Interface'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvFileReader class	instanceVariableNames: ''!!AvFileReader class methodsFor: 'private' stamp: 'jon 10/26/2004 22:07'!ensureNextToken: token is: aString	self ensureNextToken: token isOneOf: (Array with: aString)! !!AvFileReader class methodsFor: 'private' stamp: 'jon 10/26/2004 22:07'!ensureNextToken: token isOneOf: aCollection	((aCollection collect: [:each | each asLowercase]) includes: token asLowercase)		ifFalse: [			(AvBadDeviceFileException new				messageText: 'Expected to find one of: ', aCollection asArray printString, ' instead found ', token printString) signal]! !!AvFileReader class methodsFor: 'private' stamp: 'jon 10/26/2004 22:06'!initializeTokenDelimiters	"AvDevice initializeTokenDelimiters"	TokenDelimiters := (WriteStream on: (String new: 10))		nextPut: Character space;		nextPut: Character tab;		nextPut: Character cr;		nextPut: Character lf;		contents! !!AvFileReader class methodsFor: 'private' stamp: 'jon 10/26/2004 22:58'!spacedStringFrom: tokens	"Answer a string with the given set of tokens in it, with each token separated by a space."	| stream |	stream := WriteStream on: (String new: 10).	tokens		do: [:eachPart | stream nextPutAll: eachPart]		separatedBy: [stream space].	^stream contents! !!AvFileReader class methodsFor: 'constants' stamp: 'jon 10/26/2004 22:06'!tokenDelimiters	"AvDevice tokenDelimiters"	TokenDelimiters isNil		ifTrue: [self initializeTokenDelimiters].	^TokenDelimiters! !!AvFileReader class methodsFor: 'reading' stamp: 'jon 10/26/2004 22:08'!readFromStream: aStream	"Build a new instance of one of the receiver's subclasses, and populate it from the data contained in aStream."	^self fileObjectClass fromFileMap: (self buildObjectMapFrom: aStream)! !!AvFileReader class methodsFor: 'private-reading' stamp: 'jon 10/26/2004 22:09'!readSubMapFrom: tokenStream into: map until: endString	self readSubMapFrom: tokenStream into: map untilOneOf: (Array with: endString)! !!AvFileReader class methodsFor: 'private-reading' stamp: 'jon 10/26/2004 22:09'!readSubMapFrom: tokenStream into: map untilOneOf: endCollection	[tokenStream atEnd or: [endCollection includes: tokenStream peek first]] whileFalse: [		| tokens value |		tokens := tokenStream next.		value := (tokens copyFrom: 2 to: tokens size) asArray.		map add: tokens first asSymbol -> value].! !!AvFileReader class methodsFor: 'private-reading' stamp: 'jon 10/26/2004 22:10'!tokenizeByLine: inStream	| results |	results := OrderedCollection new.	[inStream skipSeparators; atEnd] whileFalse: [		| line |		line := inStream nextLine withBlanksTrimmed.		line isEmpty | (line first = $#)			ifFalse: [				| tokens |				tokens := line findTokens: self tokenDelimiters.				results add: tokens]].	^results! !AvFileReader subclass: #AvDeviceFileReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvDeviceFileReader class	instanceVariableNames: ''!!AvDeviceFileReader class methodsFor: 'private' stamp: 'Jon 3/24/2003 11:31'!concreteClassForDeviceInterface: deviceInterface ifNone: absentBlock	"Find the concrete subclass that handles devices with the given interface."	^self allSubclasses		detect: [:each | each deviceInterface asLowercase = deviceInterface asLowercase]		ifNone: absentBlock! !!AvDeviceFileReader class methodsFor: 'private' stamp: 'Jon 3/24/2003 11:31'!errorBadDeviceInterface: deviceInterface	(AvBadDeviceFileException new messageText: 'Unable to find Device subclass for Interface ', deviceInterface printString) signal! !!AvDeviceFileReader class methodsFor: 'private' stamp: 'jon 10/26/2004 22:11'!fileObjectClass	^AvDevice! !!AvDeviceFileReader class methodsFor: 'private-reading' stamp: 'jon 10/26/2004 22:50'!buildObjectMapFrom: aStream	| tokens tokenStream map |	tokens := self tokenizeByLine: aStream.	tokenStream := tokens readStream.	map := Dictionary new.	self		readProductInformationFrom: tokenStream into: map;		readCommandsFrom: tokenStream into: map.	^map! !!AvDeviceFileReader class methodsFor: 'private-reading' stamp: 'jon 10/22/2004 22:32'!readCommandsFrom: tokenStream into: map	[tokenStream atEnd] whileFalse: [		| header commandSelector commandName commandMap responseName responseMap |		header := tokenStream next.		self ensureNextToken: header first isOneOf: #('PushCommand' 'Command').		commandSelector := header first = 'PushCommand'			ifTrue: [#pushCommand]			ifFalse: [#command].		commandName := header last.		commandMap := OrderedCollection new.		self readSubMapFrom: tokenStream into: commandMap until: 'Response'.		header := tokenStream next.		self ensureNextToken: header first is: 'Response'.		responseName := header last.		responseName = commandName			ifFalse: [].		responseMap := OrderedCollection new.		self readSubMapFrom: tokenStream into: responseMap untilOneOf: #('PushCommand' 'Command').		map			at: commandName asSymbol			put: (Dictionary new				at: commandSelector put: commandMap asArray;				at: #response put: responseMap asArray;				yourself)].! !!AvDeviceFileReader class methodsFor: 'private-reading' stamp: 'jon 10/26/2004 22:59'!readProductInformationFrom: tokenStream into: map	| subMap |	self ensureNextToken: tokenStream next first is: 'ProductInformation'.	subMap := OrderedCollection new.	self readSubMapFrom: tokenStream into: subMap untilOneOf: #('PushCommand' 'Command').	map		at: #ProductInformation		put: (subMap			inject: Dictionary new			into: [:sum :each |				sum					at: each key put: (self spacedStringFrom: each value);					yourself])! !AvDevice subclass: #AvSerialDevice	instanceVariableNames: 'protocol byteOrder serialPort accessSemaphore'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvSerialDevice commentStamp: '<historical>' prior: 0!AvSerialDeviceAvSerialDevice is a class that represents a serial device that this autonomous controller can connect to.Instance Variables:	protocol		<AvSerialProtocol>				The communications protocol used to talk to this deviceIn general, instances of AvSerialDevice are fully specified and created from the information in a device file.An example device file, for an IMU sensor made by Microstrain:Microstrain_3DM-G.txtProductInformation	VendorName	MicroStrain	ProductName	3DM-G	Type		Serial	Protocol		RS232	BaudRate	38400	Parity		none	DataBits	8	StopBits		1	ByteOrder	MsbFirstCommand: SendGyroStabilizedQuaternion	Integer8		command		0x05Response: SendGyroStabilizedQuaternion	Integer8		command	Integer16	quaternion0	Integer16	quaternion1	Integer16	quaternion2	Integer16	quaternion3	Integer16	timerTicks	Integer16	checksumCommand: SendFirmwareVersionNumber	Integer8		command		0xF0Response: SendFirmwareVersionNumber	Integer8		command		Integer16	version	Integer16	checksum!!AvSerialDevice methodsFor: 'initializing' stamp: 'Jon 12/23/2005 15:20'!initialize	super initialize.	accessSemaphore := Semaphore forMutualExclusion! !!AvSerialDevice methodsFor: 'accessing' stamp: 'Jon 1/1/2006 21:29'!accessSerialPortWhile: aBlock	^accessSemaphore critical: [aBlock value: serialPort]! !!AvSerialDevice methodsFor: 'accessing' stamp: 'jon 10/27/2004 22:38'!close	(serialPort notNil and: [serialPort isConnected])		ifTrue: [serialPort close].! !!AvSerialDevice methodsFor: 'accessing' stamp: 'Jon 3/25/2003 12:00'!commandNamed: aSymbol	^commands at: aSymbol ifAbsent: [nil]! !!AvSerialDevice methodsFor: 'accessing' stamp: 'Jon 3/24/2003 11:41'!protocol	^protocol! !!AvSerialDevice methodsFor: 'accessing' stamp: 'Jon 3/24/2003 11:41'!protocol: aSerialProtocol	protocol := aSerialProtocol! !!AvSerialDevice methodsFor: 'accessing' stamp: 'jon 10/22/2004 22:53'!serialPort	^serialPort! !!AvSerialDevice methodsFor: 'extracting' stamp: 'Jon 3/25/2003 12:45'!extractResponseFrom: rawBytes forCommandNamed: commandName	| command |	command := self commandNamed: commandName.	^command extractResponseFrom: rawBytes! !!AvSerialDevice methodsFor: 'commands' stamp: 'Jon 1/24/2006 12:29'!sendCommandBytes: commandBytes	"Send the given command bytes over the serial port the receiver is connected to."	self isConnected		ifFalse: [^nil].	AvSystem showOutgoingCommandsOnTranscript		ifTrue: [Transcript cr; show: 'sending: ', commandBytes printString].	accessSemaphore critical: [		serialPort nextPutAll: commandBytes].! !!AvSerialDevice methodsFor: 'interfaces' stamp: 'jon 10/27/2004 15:17'!newInterface	^AvSerialPortInterface on: self! !!AvSerialDevice methodsFor: 'private' stamp: 'jon 8/23/2004 15:11'!isConnected	^serialPort isConnected! !!AvSerialDevice methodsFor: 'private' stamp: 'jon 8/27/2004 13:24'!setByteOrderFrom: aString	"Set the byte ordering of the receiver. Valid values are:		'MsbFirst'		'LsbFirst'	"	aString asLowercase = 'msbfirst'		ifTrue: [^byteOrder := #msbFirst].	aString asLowercase = 'lsbfirst'		ifTrue: [^byteOrder := #lsbFirst].	aString asLowercase = 'none'		ifTrue: [^byteOrder := #none].	self errorDeviceFileBadField: 'ByteOrder' value: aString! !!AvSerialDevice methodsFor: 'private-building' stamp: 'jon 10/22/2004 22:55'!buildFromDeviceFileMap: map	| protocolName productInformation |	super buildFromDeviceFileMap: map.	productInformation := map at: #ProductInformation.	protocolName := productInformation at: #Protocol ifAbsent: [self errorDeviceFileMissingToken: 'Protocol'].	self protocol: (AvSerialProtocol newFor: protocolName ifNone: [self errorDeviceFileUnknownProtocol: protocolName]).	protocol buildFromProductInformationMap: productInformation.	self setByteOrderFrom: (productInformation at: #ByteOrder ifAbsent: ['none']).	serialPort := protocol openSerialPort.! !!AvSerialDevice methodsFor: 'private-exceptions' stamp: 'Jon 3/21/2003 12:49'!errorDeviceFileBadField: fieldName value: aString	"A device file has an bad field value. Signal an exception."	^(AvBadDeviceFileException new messageText: 'Unknown value for field: ', fieldName, ' -> ', aString) signal! !!AvSerialDevice methodsFor: 'private-exceptions' stamp: 'Jon 3/21/2003 12:38'!errorDeviceFileMissingToken: aString	"A device file is missing an expected piece. Signal an exception."	^(AvBadDeviceFileException new messageText: 'Expected to find: ', aString) signal! !!AvSerialDevice methodsFor: 'private-exceptions' stamp: 'Jon 3/21/2003 12:39'!errorDeviceFileUnknownProtocol: aString	"A device file has an unknown protocol. Signal an exception."	^(AvBadDeviceFileException new messageText: 'Unknown protocol: ', aString) signal! !!AvSerialDevice methodsFor: 'private-exceptions' stamp: 'Jon 3/22/2003 21:58'!errorDeviceFileUnknownType: type forCommandName: commandName	"A device file has an unknown type. Signal an exception."	^(AvBadDeviceFileException new messageText: 'Unknown type: ', type, ' in command: ', commandName) signal! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvSerialDevice class	instanceVariableNames: ''!!AvSerialDevice class methodsFor: 'device file support' stamp: 'Jon 3/21/2003 12:23'!deviceInterface	^'Serial'! !Object subclass: #AvSerialProtocol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvSerialProtocol class	instanceVariableNames: ''!!AvSerialProtocol class methodsFor: 'private' stamp: 'Jon 3/21/2003 12:43'!concreteClassForDeviceInterface: protocolName ifNone: absentBlock	"Find the concrete subclass that handles devices with the given protocol."	^self allSubclasses		detect: [:each | each protocolName asLowercase = protocolName asLowercase]		ifNone: absentBlock! !!AvSerialProtocol class methodsFor: 'instance creation' stamp: 'Jon 3/21/2003 12:44'!newFor: protocolName ifNone: absentBlock	"Return a new instance of the approriate subclass of the receiver for the given protocol."	^(self concreteClassForDeviceInterface: protocolName ifNone: absentBlock) new! !AvSerialProtocol subclass: #AvI2CSerialProtocol	instanceVariableNames: 'comPort'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvI2CSerialProtocol methodsFor: 'serial port access' stamp: 'jon 10/22/2004 21:41'!openSerialPort	"Open and answer an instance of I2CPort, setup as per the receiver."	^nil! !!AvI2CSerialProtocol methodsFor: 'printing' stamp: 'jon 10/22/2004 21:37'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		print: comPort;		nextPut: $)! !!AvI2CSerialProtocol methodsFor: 'private' stamp: 'jon 10/22/2004 21:37'!setComPortFrom: aString	comPort := aString asNumber! !!AvI2CSerialProtocol methodsFor: 'private-building' stamp: 'jon 10/22/2004 21:36'!buildFromProductInformationMap: productInformation	self		setComPortFrom: (productInformation at: #ComPort ifAbsent: [self errorDeviceFileMissingToken: 'ComPort'])! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvI2CSerialProtocol class	instanceVariableNames: ''!!AvI2CSerialProtocol class methodsFor: 'constants' stamp: 'jon 10/22/2004 21:38'!protocolName	^'I2C'! !AvSerialProtocol subclass: #AvRs232SerialProtocol	instanceVariableNames: 'baudRate dataBits parity stopBits comPort'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!!AvRs232SerialProtocol methodsFor: 'serial port access' stamp: 'jon 11/9/2004 12:07'!openSerialPort	"Open and answer an instance of SerialPort, setup as per the receiver."	| port |	port := SerialPort new		baudRate: baudRate;		dataBits: dataBits;		stopBitsType: self stopBitsType;		parityType: self parityType;		yourself.	(port openPort: comPort) isNil		ifTrue: [self error: 'Serial Port ', comPort printString, ' Unavailable...'].	^port! !!AvRs232SerialProtocol methodsFor: 'printing' stamp: 'Jon 2/20/2004 13:37'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		print: baudRate;		nextPutAll: ' - ';		print: dataBits;		nextPut: self parityCharacter;		print: stopBits;		nextPut: $)! !!AvRs232SerialProtocol methodsFor: 'private' stamp: 'Jon 2/20/2004 13:36'!parityCharacter	^parity == #none		ifTrue: [$N]		ifFalse: [			parity == #even				ifTrue: [$E]				ifFalse: [$O]]! !!AvRs232SerialProtocol methodsFor: 'private' stamp: 'jon 8/26/2004 12:14'!parityType	"Asnwer parity, in the form SerialPort uses. See SerialPort >> #parityType: "	^Dictionary new		at: #none put: 0;		at: #odd put: 1;		at: #even put: 2;		at: parity ifAbsent: [0]! !!AvRs232SerialProtocol methodsFor: 'private' stamp: 'Jon 3/24/2003 15:00'!setBaudRateFrom: aString	baudRate := aString asNumber! !!AvRs232SerialProtocol methodsFor: 'private' stamp: 'Jon 3/24/2003 15:08'!setComPortFrom: aString	comPort := aString asNumber! !!AvRs232SerialProtocol methodsFor: 'private' stamp: 'Jon 3/24/2003 15:01'!setDataBitsFrom: aString	dataBits := aString asNumber! !!AvRs232SerialProtocol methodsFor: 'private' stamp: 'Jon 3/24/2003 15:01'!setParityFrom: aString	parity := aString asSymbol! !!AvRs232SerialProtocol methodsFor: 'private' stamp: 'Jon 3/24/2003 15:08'!setStopBitsFrom: aString	stopBits := aString asNumber! !!AvRs232SerialProtocol methodsFor: 'private' stamp: 'jon 8/26/2004 12:14'!stopBitsType	"Asnwer stop bits, in the form SerialPort uses. See SerialPort >> #stopBitsType: "	^Dictionary new		at: 1 put: 1;		at: 1.5 put: 0;		at: 2 put: 2;		at: stopBits ifAbsent: [1]! !!AvRs232SerialProtocol methodsFor: 'private-building' stamp: 'Jon 3/24/2003 15:00'!buildFromProductInformationMap: productInformation	self		setBaudRateFrom: (productInformation at: #BaudRate ifAbsent: [self errorDeviceFileMissingToken: 'BaudRate']);		setParityFrom: (productInformation at: #Parity ifAbsent: [self errorDeviceFileMissingToken: 'Parity']);		setDataBitsFrom: (productInformation at: #DataBits ifAbsent: [self errorDeviceFileMissingToken: 'DataBits']);		setStopBitsFrom: (productInformation at: #StopBits ifAbsent: [self errorDeviceFileMissingToken: 'StopBits']);		setComPortFrom: (productInformation at: #ComPort ifAbsent: [self errorDeviceFileMissingToken: 'ComPort'])! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvRs232SerialProtocol class	instanceVariableNames: ''!!AvRs232SerialProtocol class methodsFor: 'constants' stamp: 'Jon 3/24/2003 09:17'!protocolName	^'Rs232'! !AvFileReader subclass: #AvVehicleFileReader	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Device Interface'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvVehicleFileReader class	instanceVariableNames: ''!!AvVehicleFileReader class methodsFor: 'private-reading' stamp: 'jon 10/26/2004 23:17'!buildObjectMapFrom: aStream	| tokens tokenStream map |	tokens := self tokenizeByLine: aStream.	tokenStream := tokens readStream.	map := Dictionary new.	self		readHeaderInformationFrom: tokenStream into: map;		readSensorsFrom: tokenStream into: map;		readActuatorsFrom: tokenStream into: map.	^map! !!AvVehicleFileReader class methodsFor: 'private-reading' stamp: 'jon 10/26/2004 23:17'!readActuatorsFrom: tokenStream into: map	| actuators |	actuators := Dictionary new.	map at: #actuators put: actuators.	[tokenStream atEnd] whileFalse: [		| actuatorData |		tokenStream next.		actuatorData := OrderedCollection new.		self readSubMapFrom: tokenStream into: actuatorData until: 'Actuator'.		actuatorData := actuatorData			inject: Dictionary new			into: [:sum :each |				sum					at: each key put: (self spacedStringFrom: each value);					yourself].		actuators at: (actuatorData at: 'name') put: actuatorData].! !!AvVehicleFileReader class methodsFor: 'private-reading' stamp: 'jon 10/26/2004 23:15'!readHeaderInformationFrom: tokenStream into: map	| devices line |	line := tokenStream next.	self ensureNextToken: line first is: 'VendorName'.	map at: #vendorName put: (self spacedStringFrom: line allButFirst).		line := tokenStream next.	self ensureNextToken: line first is: 'ProductName'.	map at: #productName put: (self spacedStringFrom: line allButFirst).		devices := OrderedCollection new.	self readSubMapFrom: tokenStream into: devices untilOneOf: #('Sensor' 'Actuator').	devices := devices collect: [:each | each value first].	map at: #deviceFilenames put: devices! !!AvVehicleFileReader class methodsFor: 'private-reading' stamp: 'jon 10/27/2004 12:40'!readSensorsFrom: tokenStream into: map	| sensors |	sensors := Dictionary new.	map at: #sensors put: sensors.	[tokenStream atEnd] whileFalse: [		| line sensorData |		line := tokenStream peek.		line first = 'Actuator'			ifTrue: [^self].		tokenStream next.		sensorData := OrderedCollection new.		self readSubMapFrom: tokenStream into: sensorData untilOneOf: #('Sensor' 'Actuator').		sensorData := sensorData			inject: Dictionary new			into: [:sum :each |				sum					at: each key put: (self spacedStringFrom: each value);					yourself].		sensors at: (sensorData at: 'name') put: sensorData].! !!AvVehicleFileReader class methodsFor: 'private' stamp: 'jon 10/26/2004 22:35'!fileObjectClass	^AvVehicle! !Error subclass: #AvBadDeviceFileException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Exceptions'!Object subclass: #AvEditorCommand	instanceVariableNames: 'name undoBlock redoBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!!AvEditorCommand commentStamp: 'Jon 1/14/2005 12:14' prior: 0!An AvEditorCommand is an object that is used to support undo/redo.Instance Variables	name:			<String>	redoBlock:		<BlockContext>	undoBlock:		<BlockContext>name	- a label associated with the command to be undone/redoneredoBlock	- a zero-argument block that applies the command to the editorundoBlock	- a zero-argument block that applies the negation of the command to the editor!!AvEditorCommand methodsFor: 'accessing' stamp: 'jon 11/12/2004 13:50'!name	^name! !!AvEditorCommand methodsFor: 'accessing' stamp: 'jon 11/12/2004 13:50'!name: aString	name := aString! !!AvEditorCommand methodsFor: 'accessing' stamp: 'jon 11/12/2004 13:51'!redoBlock	^ redoBlock! !!AvEditorCommand methodsFor: 'accessing' stamp: 'jon 11/12/2004 13:51'!redoBlock: aBlock	redoBlock := aBlock! !!AvEditorCommand methodsFor: 'accessing' stamp: 'jon 11/12/2004 13:51'!undoBlock	^ undoBlock! !!AvEditorCommand methodsFor: 'accessing' stamp: 'jon 11/12/2004 13:51'!undoBlock: aBlock	undoBlock := aBlock! !!AvEditorCommand methodsFor: 'undo/redo' stamp: 'jon 11/12/2004 13:53'!redo	redoBlock value! !!AvEditorCommand methodsFor: 'undo/redo' stamp: 'jon 11/12/2004 13:53'!undo	undoBlock value! !!AvEditorCommand methodsFor: 'printing' stamp: 'jon 11/12/2004 13:52'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self name;		nextPut: $)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvEditorCommand class	instanceVariableNames: ''!!AvEditorCommand class methodsFor: 'instance creation' stamp: 'jon 11/12/2004 13:51'!named: aString undoWith: undoBlock redoWith: redoBlock	^self new		name: aString;		undoBlock: undoBlock;		redoBlock: redoBlock;		yourself! !Object subclass: #AvExecutionBlock	instanceVariableNames: 'name block'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!!AvExecutionBlock commentStamp: 'Jon 1/14/2005 12:11' prior: 0!An AvExecutionBlock is named wrapper for a block.Instance Variables	block:		<BlockContext>	name:		<Stri ng>block	- a zero-argument block to be evaluated each time the object is sent #executename	- the name of the execution block!!AvExecutionBlock methodsFor: 'accessing' stamp: 'Jon 12/5/2004 09:37'!block	^ block! !!AvExecutionBlock methodsFor: 'accessing' stamp: 'Jon 12/5/2004 09:38'!block: aBlock	block := aBlock! !!AvExecutionBlock methodsFor: 'accessing' stamp: 'Jon 12/5/2004 09:38'!name	^ name! !!AvExecutionBlock methodsFor: 'accessing' stamp: 'Jon 12/5/2004 09:37'!name: aString	name := aString! !!AvExecutionBlock methodsFor: 'execution' stamp: 'Jon 12/5/2004 09:39'!execute	^block value! !!AvExecutionBlock methodsFor: 'printing' stamp: 'Jon 12/5/2004 09:38'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: self name;		nextPut: $).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvExecutionBlock class	instanceVariableNames: ''!!AvExecutionBlock class methodsFor: 'instance creation' stamp: 'Jon 12/5/2004 09:37'!named: aString with: aBlock	^self new		name: aString;		block: aBlock;		yourself.! !Object subclass: #AvGpsCoordinate	instanceVariableNames: 'latitude longitude uncertainty valid'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!!AvGpsCoordinate commentStamp: 'Jon 1/14/2005 12:12' prior: 0!An AvGpsCoordinate represents a global absolute position.Instance Variables:	latitude:		<Float>	longitude:		<Float>	uncertainty:	<SmallInteger>	valid:			<Boolean>latitude	- the latitude, in degrees (and fractional degrees) north	- this is extracted from the $GPGLL sentencelongitude	- the longitude, in degrees (and fractional degrees) west	- this is extracted from the $GPGLL sentenceuncertainty	- the uncertainty of the measurement, in metres.	- this is the estimated position error from the $PGRME sentence (Garmin-specific)valid	- contains true if the coordinate was a valid position fix, false otherwise	- this is extracted from the $GPGSA sentence!!AvGpsCoordinate methodsFor: 'accessing' stamp: 'jon 10/10/2004 20:28'!latitude	^ latitude! !!AvGpsCoordinate methodsFor: 'accessing' stamp: 'jon 10/10/2004 20:28'!latitude: aNumber	"Set the value of latitude to the given number, which is degrees north."	latitude := aNumber! !!AvGpsCoordinate methodsFor: 'accessing' stamp: 'jon 10/10/2004 20:36'!latitudeDegrees	^latitude asInteger! !!AvGpsCoordinate methodsFor: 'accessing' stamp: 'jon 10/10/2004 20:39'!latitudeMinutes	^(latitude - self latitudeDegrees) * 60.0	! !!AvGpsCoordinate methodsFor: 'accessing' stamp: 'jon 10/10/2004 20:28'!longitude	^ longitude! !!AvGpsCoordinate methodsFor: 'accessing' stamp: 'jon 10/10/2004 20:29'!longitude: aNumber	"Set the value of longitude to the given number, which is degrees east."	longitude := aNumber! !!AvGpsCoordinate methodsFor: 'accessing' stamp: 'jon 10/10/2004 20:37'!longitudeDegrees	^longitude asInteger! !!AvGpsCoordinate methodsFor: 'accessing' stamp: 'jon 10/10/2004 20:39'!longitudeMinutes	^(longitude - self longitudeDegrees) * 60.0	! !!AvGpsCoordinate methodsFor: 'accessing' stamp: 'jon 10/20/2004 09:52'!makeInvalid	valid := false! !!AvGpsCoordinate methodsFor: 'accessing' stamp: 'jon 10/20/2004 09:52'!makeValid	valid := true! !!AvGpsCoordinate methodsFor: 'accessing' stamp: 'Jon 11/26/2004 15:48'!offsetByMeters: offset	| newCoordinate ratio |	newCoordinate := self class new		latitude: self latitude + (offset y / 111000.0);		yourself.	ratio := newCoordinate latitude degreesToRadians cos.	^newCoordinate		longitude: self longitude - (offset x / (111000.0 * ratio));		uncertainty: self uncertainty;		yourself.! !!AvGpsCoordinate methodsFor: 'accessing' stamp: 'jon 10/10/2004 20:29'!uncertainty	^ uncertainty! !!AvGpsCoordinate methodsFor: 'accessing' stamp: 'jon 10/10/2004 20:29'!uncertainty: aNumber	"Set the value of uncertainty to the given number, in metres."	uncertainty := aNumber! !!AvGpsCoordinate methodsFor: 'accessing' stamp: 'jon 10/22/2004 20:11'!valid: aBoolean	valid := aBoolean! !!AvGpsCoordinate methodsFor: 'printing' stamp: 'jon 10/23/2004 08:47'!latitudeString	^(WriteStream on: (String new: 20))		print: self latitudeDegrees abs;		nextPutAll: ' ';		print: (self latitudeMinutes roundTo: 0.0001) abs;		nextPutAll: ''' ';		nextPutAll: self northSouthIndicatorString;		contents! !!AvGpsCoordinate methodsFor: 'printing' stamp: 'jon 10/23/2004 08:47'!longitudeString	^(WriteStream on: (String new: 20))		print: self longitudeDegrees abs;		nextPutAll: ' ';		print: (self longitudeMinutes roundTo: 0.0001) abs;		nextPutAll: ''' ';		nextPutAll: self eastWestIndicatorString;		contents! !!AvGpsCoordinate methodsFor: 'printing' stamp: 'jon 10/27/2004 22:55'!printOn: aStream	aStream nextPutAll: '('.	self isValid		ifFalse: [aStream nextPutAll: 'INVALID - '].	aStream		print: self latitudeDegrees abs;		nextPutAll: ' ';		print: (self latitudeMinutes roundTo: 0.0001) abs;		nextPutAll: ''' ';		nextPutAll: self northSouthIndicatorString;		nextPutAll: ' | ';		print: self longitudeDegrees abs;		nextPutAll: ' ';		print: (self longitudeMinutes roundTo: 0.0001) abs;		nextPutAll: ''' ';		nextPutAll: self eastWestIndicatorString;		nextPutAll: ' - ';		print: (self uncertainty roundTo: 0.1);		nextPut: $)! !!AvGpsCoordinate methodsFor: 'printing' stamp: 'Jon 11/26/2004 15:00'!simplePrintString	^(WriteStream on: (String new: 20))		nextPutAll: '(';		print: self latitudeDegrees abs;		nextPutAll: ' ';		print: (self latitudeMinutes roundTo: 0.0001) abs;		nextPutAll: ''' ';		nextPutAll: self northSouthIndicatorString;		nextPutAll: ' | ';		print: self longitudeDegrees abs;		nextPutAll: ' ';		print: (self longitudeMinutes roundTo: 0.0001) abs;		nextPutAll: ''' ';		nextPutAll: self eastWestIndicatorString;		nextPut: $);		contents! !!AvGpsCoordinate methodsFor: 'distance/bearing' stamp: 'jon 10/16/2004 18:12'!bearingTo: aCoordinate	"Answer the bearing, in degrees, between the two given positions.	Each position is an instance of AvGpsCoordinate.	Based on the formula at: http://www.movable-type.co.uk/scripts/LatLong.html "	| firstPart secondPart deltaLongitude |	deltaLongitude := aCoordinate longitude - self longitude.	firstPart := deltaLongitude degreesToRadians sin negated * aCoordinate latitude degreesToRadians cos.	secondPart := (self latitude degreesToRadians cos * aCoordinate latitude degreesToRadians sin)		- (self latitude degreesToRadians sin			* aCoordinate latitude degreesToRadians cos			* deltaLongitude degreesToRadians cos).	^(firstPart arcTan: secondPart) radiansToDegrees! !!AvGpsCoordinate methodsFor: 'distance/bearing' stamp: 'jon 10/16/2004 18:11'!distanceTo: aCoordinate	"Answer the distance, in meters, between the two given positions.	Each coordinate is an instance of AvGpsCoordinate.	Based on the Haversine formula: http://www.movable-type.co.uk/scripts/LatLong.html "	| radius deltaLatitude deltaLongitude alpha km |	radius := 6371.	deltaLatitude := aCoordinate latitude - self latitude.	deltaLongitude := aCoordinate longitude - self longitude.	alpha := (deltaLatitude / 2) degreesToRadians sin squared		+ (self latitude degreesToRadians cos			* aCoordinate latitude degreesToRadians cos			* (deltaLongitude / 2) degreesToRadians sin squared).	km := 2.0 * radius * (alpha sqrt arcTan: (1 - alpha) sqrt).	^km * 1000.0! !!AvGpsCoordinate methodsFor: 'testing' stamp: 'jon 10/20/2004 09:52'!isValid	^valid! !!AvGpsCoordinate methodsFor: 'private' stamp: 'Jon 2/22/2005 09:51'!eastWestIndicatorString	^self longitude positive		ifTrue: ['W']		ifFalse: ['E'].! !!AvGpsCoordinate methodsFor: 'private' stamp: 'jon 10/10/2004 20:32'!northSouthIndicatorString	^self latitude positive		ifTrue: ['N']		ifFalse: ['S'].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvGpsCoordinate class	instanceVariableNames: ''!!AvGpsCoordinate class methodsFor: 'instance creation' stamp: 'jon 10/10/2004 20:10'!latitude: latitudeNumber longitude: longitudeNumber	"Answer an initialized instance of the receiver, with the given coordinates."	^self		latitude: latitudeNumber		longitude: longitudeNumber		uncertainty: 0! !!AvGpsCoordinate class methodsFor: 'instance creation' stamp: 'jon 10/20/2004 09:53'!latitude: latitudeNumber longitude: longitudeNumber uncertainty: uncertaintyNumber	"Answer an initialized instance of the receiver, with the given coordinates and uncertainty."	^super new		makeValid;		latitude: latitudeNumber;		longitude: longitudeNumber;		uncertainty: uncertaintyNumber;		yourself! !Magnitude subclass: #AvHeading	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!!AvHeading methodsFor: 'accessing' stamp: 'jon 10/17/2004 08:39'!hash	^value hash! !!AvHeading methodsFor: 'arithmetic' stamp: 'jon 10/17/2004 08:36'!* aNumber	^self class on: (value * aNumber)! !!AvHeading methodsFor: 'arithmetic' stamp: 'jon 10/17/2004 08:36'!+ aNumber	^self class on: (value + aNumber)! !!AvHeading methodsFor: 'arithmetic' stamp: 'jon 10/17/2004 08:36'!- aNumber	^self class on: (value - aNumber)! !!AvHeading methodsFor: 'arithmetic' stamp: 'jon 10/17/2004 08:36'!/ aNumber	^self class on: (value / aNumber)! !!AvHeading methodsFor: 'arithmetic' stamp: 'jon 10/17/2004 08:36'!// aNumber	^self class on: (value // aNumber)! !!AvHeading methodsFor: 'comparing' stamp: 'jon 10/17/2004 08:38'!< anAvHeading	^value < anAvHeading privateValue! !!AvHeading methodsFor: 'comparing' stamp: 'jon 10/17/2004 08:39'!= anObject	^anObject isNumber		ifTrue: [value = anObject]		ifFalse: [value = anObject privateValue]! !!AvHeading methodsFor: 'printing' stamp: 'jon 10/17/2004 08:32'!printOn: aStream	aStream		print: (value roundTo: 0.1);		nextPutAll: ' '! !!AvHeading methodsFor: 'private' stamp: 'jon 10/17/2004 08:31'!keepValueInRange	"We always want the heading to be between 0 and 359.9999..."	value := value \\ 360! !!AvHeading methodsFor: 'private' stamp: 'jon 10/17/2004 08:31'!on: heading	value := heading.	self keepValueInRange! !!AvHeading methodsFor: 'private' stamp: 'jon 10/17/2004 08:38'!privateValue	^value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvHeading class	instanceVariableNames: ''!!AvHeading class methodsFor: 'instance creation' stamp: 'jon 10/17/2004 08:30'!on: heading	^self new on: heading! !Magnitude subclass: #AvHeadingOffset	instanceVariableNames: 'value'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!Object subclass: #AvLogger	instanceVariableNames: 'logFilename logEntries accessSemaphore'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!!AvLogger commentStamp: 'Jon 1/12/2006 11:02' prior: 0!An AvLogger is an object that logs strings to a file.Instance Variables	logFilename:		<String>logFilename	- the name of the file to log to!!AvLogger methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:03'!logFilename	^logFilename! !!AvLogger methodsFor: 'accessing' stamp: 'Jon 1/12/2006 11:03'!logFilename: aString	logFilename := aString! !!AvLogger methodsFor: 'logging' stamp: 'Jon 1/25/2006 21:06'!log: aString	| file date time elapsed |	accessSemaphore critical: [		file := FileStream fileNamed: logFilename.		date := Date today yyyymmdd.		time := Time now print24.		elapsed := AvSystem current isNil			ifTrue: ['not running']			ifFalse: [AvSystem current missionElapsedTime asStringWithCommas].		file			setToEnd;			nextPutAll: date; tab;			nextPutAll: time; tab;			nextPutAll: elapsed; tab;			nextPutAll: aString;			cr;			flush;			close.		logEntries add: (time, ' (', elapsed, ') - ', aString)].! !!AvLogger methodsFor: 'initializing' stamp: 'Jon 1/25/2006 20:06'!initializeLog	logEntries := OrderedCollection new: 100.	accessSemaphore := Semaphore forMutualExclusion! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvLogger class	instanceVariableNames: ''!!AvLogger class methodsFor: 'instance creation' stamp: 'Jon 1/12/2006 11:03'!on: filename	^self new		logFilename: filename;		yourself! !Object subclass: #AvOrientation	instanceVariableNames: 'pitch roll yaw'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!Object subclass: #AvPosition	instanceVariableNames: 'mapPoint'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!!AvPosition commentStamp: 'Jon 1/14/2005 12:08' prior: 0!An AvPosition represents a two-dimensional mapPoint in space, relative to the mission start location.Instance Variables:	mapPoint:	<Point>mapPoint	- contains the x & y coordinate of the current mapPoint, in metres, relative to the SW corner of the map.	- x increases to the east, y increases to the north!!AvPosition methodsFor: 'arithmetic' stamp: 'jon 8/6/2004 17:08'!* anObject	^self class fromPoint: mapPoint * anObject! !!AvPosition methodsFor: 'arithmetic' stamp: 'jon 8/6/2004 17:08'!+ anObject	^self class fromPoint: mapPoint + anObject! !!AvPosition methodsFor: 'arithmetic' stamp: 'jon 8/6/2004 17:08'!- anObject	^self class fromPoint: mapPoint - anObject! !!AvPosition methodsFor: 'arithmetic' stamp: 'jon 8/6/2004 17:09'!/ anObject	^self class fromPoint: mapPoint / anObject! !!AvPosition methodsFor: 'arithmetic' stamp: 'jon 8/6/2004 17:09'!// anObject	^self class fromPoint: mapPoint // anObject! !!AvPosition methodsFor: 'arithmetic' stamp: 'jon 8/6/2004 17:09'!\\ anObject	^self class fromPoint: mapPoint \\ anObject! !!AvPosition methodsFor: 'arithmetic' stamp: 'jon 8/6/2004 17:09'!abs	^self class fromPoint: mapPoint abs! !!AvPosition methodsFor: 'arithmetic' stamp: 'Jon 11/28/2004 09:55'!max: anAvPosition 		^self class fromPoint: (self mapPoint max: anAvPosition mapPoint)! !!AvPosition methodsFor: 'arithmetic' stamp: 'Jon 11/28/2004 09:54'!min: anAvPosition 		^self class fromPoint: (self mapPoint min: anAvPosition mapPoint)! !!AvPosition methodsFor: 'printing' stamp: 'Jon 1/23/2006 19:36'!printOn: aStream	aStream nextPut: ${;		nextPutAll: (mapPoint x printShowingDecimalPlaces: 2);		nextPutAll: ' @ ';		nextPutAll: (mapPoint y printShowingDecimalPlaces: 2);		nextPut: $}.! !!AvPosition methodsFor: 'accessing' stamp: 'Jon 1/15/2006 21:21'!bearingTo: aPosition	"Answer the bearing, in a compass coordinate sense, from the receiver to the given position.	Keep in mind we're using a bottom-left origin map coordinate system, with north pointing up."	| deltaX deltaY  |	deltaX := aPosition mapPoint x -  self mapPoint x.	deltaY := aPosition mapPoint y - self mapPoint y.	deltaX abs < 0.001		ifTrue: [^deltaY > 0 ifTrue: [0] ifFalse: [180]].	^((deltaX < 0 ifTrue: [270] ifFalse: [90]) - (deltaY / deltaX) arcTan radiansToDegrees) rounded \\ 360! !!AvPosition methodsFor: 'accessing' stamp: 'jon 11/20/2004 21:41'!distanceTo: aPosition	^mapPoint dist: aPosition mapPoint! !!AvPosition methodsFor: 'accessing' stamp: 'jon 8/6/2004 16:47'!mapPoint	"Answer the value of mapPoint, in metres."	^ mapPoint! !!AvPosition methodsFor: 'accessing' stamp: 'jon 8/6/2004 16:47'!mapPoint: aPoint	"Set the value of mapPoint to the given point, which is in metres."	mapPoint := aPoint! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvPosition class	instanceVariableNames: ''!!AvPosition class methodsFor: 'instance creation' stamp: 'jon 8/6/2004 17:03'!fromPoint: aPoint	^self x: aPoint x y: aPoint y! !!AvPosition class methodsFor: 'instance creation' stamp: 'jon 8/6/2004 17:03'!x: x y: y	^self new		mapPoint: x asFloat @ y asFloat;		yourself! !!AvPosition class methodsFor: 'instance creation' stamp: 'jon 8/6/2004 17:03'!zero	^self x: 0.0 y: 0.0! !Object subclass: #AvPreferences	instanceVariableNames: 'preferences'	classVariableNames: 'Current'	poolDictionaries: ''	category: 'Av-Support'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvPreferences class	instanceVariableNames: ''!!AvPreferences class methodsFor: 'accessing' stamp: 'jon 10/20/2004 18:53'!current	"AvPreferences current"	Current isNil		ifTrue: [self initializeCurrent].	^Current! !!AvPreferences class methodsFor: 'accessing' stamp: 'jon 10/20/2004 19:08'!doesNotUnderstand: aMessage	(self current includesKey: aMessage selector asString)		ifTrue: [^self current at: aMessage selector asString].	^super doesNotUnderstand: aMessage! !!AvPreferences class methodsFor: 'accessing' stamp: 'jon 10/20/2004 18:54'!initializeCurrent	"AvPreferences initializeCurrent"	Current := self readFromPreferencesFileNamed: 'avPrefs.txt'.! !!AvPreferences class methodsFor: 'private' stamp: 'jon 10/20/2004 19:03'!fixPreferenceNamed: preferenceName from: preferenceValue	preferenceValue isEmpty		ifTrue: [^''].	preferenceValue first isDigit		ifTrue: [^preferenceValue asNumber].	^preferenceValue! !!AvPreferences class methodsFor: 'private' stamp: 'jon 10/20/2004 19:06'!readFromPreferencesFileNamed: filename	| preferences file |	preferences := Dictionary new.	file := FileStream readOnlyFileNamed: filename.	[file atEnd] whileFalse: [		| line |		line := ReadStream on: file nextLine withBlanksTrimmed.		(line atEnd or: [line peek = $#])			ifFalse: [				| preferenceName value |				preferenceName := (line upTo: $=) withBlanksTrimmed.				value := self fixPreferenceNamed: preferenceName from: line upToEnd withBlanksTrimmed.				preferences at: preferenceName put: value]].	^preferences! !Object subclass: #AvQuaternion	instanceVariableNames: 'w x y z'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!!AvQuaternion methodsFor: 'initializing' stamp: 'jon 10/30/2004 08:35'!initialize	w := 0.0.	x := 0.0.	y := 0.0.	z := 0.0.! !!AvQuaternion methodsFor: 'accessing' stamp: 'jon 10/30/2004 08:57'!magnitude	^((w * w) + (x * x) + (y * y) + (z * z)) sqrt! !!AvQuaternion methodsFor: 'accessing' stamp: 'jon 10/30/2004 08:39'!w	^w! !!AvQuaternion methodsFor: 'accessing' stamp: 'jon 10/30/2004 08:39'!x	^x! !!AvQuaternion methodsFor: 'accessing' stamp: 'jon 10/30/2004 08:39'!y	^y! !!AvQuaternion methodsFor: 'accessing' stamp: 'jon 10/30/2004 08:39'!z	^z! !!AvQuaternion methodsFor: 'converting' stamp: 'jon 10/30/2004 09:21'!asRotationMatrix	"Answer the receiver converted to a rotation matrix. This matrix follows the OpenGL/D3D model	of row/column order."	| xx xy xz xw yy yz yw zz zw |	xx := x * x.	xy := x * y.	xz := x * z.	xw := x * w.	yy := y * y.	yz := y * z.	yw := y * w.	zz := z * z.	zw := z * w.	^(Array new: 16)		at: 1 put: 1 - 2 * (yy + zz);		at: 2 put: 2 * (xy - zw);		at: 3 put: 2 * (xz + yw);		at: 4 put: 0.0;		at: 5 put: 2 * (xy + zw);		at: 6 put: 1 - 2 * (xx + zz);		at: 7 put: 2 * (yz - xw);		at: 8 put: 0.0;		at: 9 put: 2 * (xz - yw);		at: 10 put: 2 * (yz + xw);		at: 11 put: 1 - 2 * (xx + yy);		at: 12 put: 0.0;		at: 13 put: 0.0;		at: 14 put: 0.0;		at: 15 put: 0.0;		at: 16 put: 1.0;		yourself! !!AvQuaternion methodsFor: 'arithmetic' stamp: 'jon 10/30/2004 09:06'!* aQuaternion	"Answer a new quaternion that represents the combined rotation of the receiver and the argument."	^self class		w: (w * aQuaternion w) - (x * aQuaternion x) - (y * aQuaternion y) - (z* aQuaternion z)		x: (w * aQuaternion x) + (x * aQuaternion w) + (y * aQuaternion z) - (z * aQuaternion y)		y: (w * aQuaternion y) + (y * aQuaternion w) + (z * aQuaternion x) - (x * aQuaternion z)		z: (w * aQuaternion z) + (z * aQuaternion w) + (x * aQuaternion y) - (y * aQuaternion x)! !!AvQuaternion methodsFor: 'transforming' stamp: 'jon 10/30/2004 08:40'!conjugate	"Answer a new quaternion which is the conjugate of the receiver."	^self class		w: w		x: x negated		y: y negated		z: z negated! !!AvQuaternion methodsFor: 'transforming' stamp: 'jon 10/30/2004 08:41'!inverted	"The inverse of a quaternion is simply its conjugate."	^self conjugate! !!AvQuaternion methodsFor: 'transforming' stamp: 'jon 10/30/2004 09:00'!normalized	"Answer a normalized quaternion, with magnitude equal to one."	| magnitude |	magnitude := self magnitude.	^self class		w: w / magnitude		x: x / magnitude		y: y / magnitude		z: z / magnitude! !!AvQuaternion methodsFor: 'printing' stamp: 'jon 10/30/2004 08:39'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		print: w;		nextPutAll: ' ,';		print: x;		nextPutAll: ' ,';		print: y;		nextPutAll: ' ,';		print: z;		nextPut: $)! !!AvQuaternion methodsFor: 'private' stamp: 'jon 10/30/2004 09:51'!fromAxis: axis andAngle: angle	| normalizedAxis radians sinAngle |	normalizedAxis := self normalize3Vector: axis.	radians := angle degreesToRadians.	sinAngle := radians sin.	^self class		w: radians cos		x: (normalizedAxis at: 1) * sinAngle		y: (normalizedAxis at: 2) * sinAngle		z: (normalizedAxis at: 3) * sinAngle! !!AvQuaternion methodsFor: 'private' stamp: 'jon 10/30/2004 13:24'!fromPitch: pitch roll: roll yaw: yaw	"Private - set the receiver's value to correspond with the given pitch, roll, & yaw."	| pitchRadians rollRadians yawRadians qx qy qz |	pitchRadians := pitch degreesToRadians / 2.0.	rollRadians := pitch degreesToRadians / 2.0.	yawRadians := pitch degreesToRadians / 2.0.	qx := self class w: 0.0 x: pitchRadians cos y: pitchRadians sin z: 0.0.	qy := self class w: 0.0 x: yawRadians cos y: 0.0 z: yawRadians sin.	qz := self class w: rollRadians sin x: rollRadians cos y: 0.0 z: 0.0.	^qx * qy * qz! !!AvQuaternion methodsFor: 'private' stamp: 'jon 10/30/2004 09:44'!fromRotationMatrix: rotationMatrix	| trace s |	trace := 1.0 + (rotationMatrix at: 1) + (rotationMatrix at: 6) + (rotationMatrix at: 11).	"If the trace is zero or close to that, we do it this way to avoid large distortions..."	trace > 0.00000001		ifTrue: [			s := trace sqrt * 2.0.			^self class				w: 0.25 * s				x: ((rotationMatrix at: 10) - (rotationMatrix at: 7)) / s				y: ((rotationMatrix at: 3) - (rotationMatrix at: 9)) / s				z: ((rotationMatrix at: 5) - (rotationMatrix at: 2)) / s].	"If the trace of the matrix is more or less zero, we need to identify which major	diagonal element has the greatest value."	((rotationMatrix at: 1) > (rotationMatrix at: 6) and: [(rotationMatrix at: 1) > (rotationMatrix at: 11)])		ifTrue: [			s := (1.0 + (rotationMatrix at: 1) - (rotationMatrix at: 6) - (rotationMatrix at: 11)) sqrt * 2.0.			^self class				w: ((rotationMatrix at: 5) - (rotationMatrix at: 2)) / s				x: 0.25 * s				y: ((rotationMatrix at: 3) + (rotationMatrix at: 9)) / s				z: ((rotationMatrix at: 10) + (rotationMatrix at: 7)) / s].	(rotationMatrix at: 6) > (rotationMatrix at: 11)		ifTrue: [			s := (1.0 + (rotationMatrix at: 6) - (rotationMatrix at: 1) - (rotationMatrix at: 11)) sqrt * 2.0.			^self class				w: ((rotationMatrix at: 3) + (rotationMatrix at: 9)) / s				x: ((rotationMatrix at: 5) + (rotationMatrix at: 2)) / s				y: 0.25 * s				z: ((rotationMatrix at: 10) + (rotationMatrix at: 7)) / s].	s := (1.0 + (rotationMatrix at: 11) - (rotationMatrix at: 1) - (rotationMatrix at: 6)) sqrt * 2.0.	^self class		w: ((rotationMatrix at: 5) - (rotationMatrix at: 2)) / s		x: ((rotationMatrix at: 3) + (rotationMatrix at: 9)) / s		y: ((rotationMatrix at: 10) + (rotationMatrix at: 7)) / s		z: 0.25 * s! !!AvQuaternion methodsFor: 'private' stamp: 'jon 10/30/2004 09:52'!normalize3Vector: axis	| magnitude |	magnitude := ((axis first * axis first) + (axis second * axis second) + (axis third * axis third)) sqrt.	^Array		with: axis first / magnitude		with: axis second / magnitude		with: axis third / magnitude! !!AvQuaternion methodsFor: 'private' stamp: 'jon 10/30/2004 08:38'!w: wValue x: xValue y: yValue z: zValue	w := wValue.	x := xValue.	y := yValue.	z := zValue.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvQuaternion class	instanceVariableNames: ''!!AvQuaternion class methodsFor: 'instance creation' stamp: 'jon 10/30/2004 09:48'!fromAxis: axis andAngle: angle	^self new		fromAxis: axis andAngle: angle;		yourself! !!AvQuaternion class methodsFor: 'instance creation' stamp: 'jon 10/30/2004 13:27'!fromPitch: pitch roll: roll yaw: yaw	^self new		fromPitch: pitch roll: roll yaw: yaw;		yourself! !!AvQuaternion class methodsFor: 'instance creation' stamp: 'jon 10/30/2004 09:24'!fromRotationMatrix: rotationMatrix	^self new		fromRotationMatrix: rotationMatrix;		yourself! !!AvQuaternion class methodsFor: 'instance creation' stamp: 'jon 10/30/2004 08:40'!w: wValue x: xValue y: yValue z: zValue	^self new		w: wValue x: xValue y: yValue z: zValue;		yourself! !Collection subclass: #AvRingBuffer	instanceVariableNames: 'contents startIndex nextSlot endIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!!AvRingBuffer methodsFor: 'accessing' stamp: 'JON 12/24/2000 10:17'!first	self isEmpty		ifTrue: [self error: 'Ring Buffer is empty.'].	^contents at: startIndex! !!AvRingBuffer methodsFor: 'accessing' stamp: 'JON 1/20/2001 08:58'!last	self isEmpty		ifTrue: [self error: 'Ring Buffer is empty.'].	^contents at: endIndex! !!AvRingBuffer methodsFor: 'accessing' stamp: 'Jon 1/29/2001 00:08'!size	^startIndex isNil		ifTrue: [0]		ifFalse: [			endIndex >= startIndex				ifTrue: [endIndex - startIndex + 1]				ifFalse: [contents size - startIndex + endIndex]]! !!AvRingBuffer methodsFor: 'adding' stamp: 'Jon 1/29/2001 00:05'!addLast: anObject	| firstTime |	firstTime := false.	endIndex isNil		ifTrue: [			startIndex := 1.			endIndex := 0.			firstTime := true.].	endIndex := endIndex \\ contents size + 1.	contents at: endIndex put: anObject.	endIndex = startIndex & firstTime not		ifTrue: [startIndex := startIndex \\ contents size + 1]! !!AvRingBuffer methodsFor: 'enumerating' stamp: 'JON 1/20/2001 09:05'!do: aBlock	| intervals |	self isEmpty		ifTrue: [^self].	intervals := endIndex >= startIndex		ifTrue: [Array with: (startIndex to: endIndex)]		ifFalse: [Array with: (startIndex to: contents size) with: (1 to: endIndex)].	intervals do: [:each |		each do: [:eachIndex |			aBlock value: (contents at: eachIndex)]]! !!AvRingBuffer methodsFor: 'enumerating' stamp: 'Jon 1/29/2001 00:07'!last: count do: aBlock	| intervals first size |	"Iterate over the last count items in the receiver."	self isEmpty | (count = 0)		ifTrue: [^self].	size := self size.	count >= size		ifTrue: [^self do: aBlock].	first := endIndex - count + 1.	first < 1		ifTrue: [first := size + first].	intervals := first > endIndex		ifTrue: [Array with: (first to: size) with: (1 to: (count - (size - first + 1)))]		ifFalse: [Array with: (first to: first + count - 1)].	intervals do: [:each |		each do: [:eachIndex |			aBlock value: (contents at: eachIndex)]]! !!AvRingBuffer methodsFor: 'private' stamp: 'JON 1/20/2001 09:07'!makeEmpty	startIndex := nil.	endIndex := nil! !!AvRingBuffer methodsFor: 'private' stamp: 'JON 12/24/2000 10:12'!setSize: size	contents := Array new: size.	self makeEmpty! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvRingBuffer class	instanceVariableNames: ''!!AvRingBuffer class methodsFor: 'instance creation' stamp: 'JON 12/24/2000 08:48'!new	^self error: 'Use #new: to build Ring Buffers...'! !!AvRingBuffer class methodsFor: 'instance creation' stamp: 'JON 12/24/2000 08:48'!new: size	^super new setSize: size! !!AvRingBuffer class methodsFor: 'test cases' stamp: 'Jon 1/30/2006 12:24'!test01	"RingBuffer test01"	| new |	new := AvRingBuffer new: 10.	1 to: 13 do: [:index | new addLast: index].	new last: 5 do: [:each | Transcript cr; show: each printString]! !Object subclass: #AvStateHandler	instanceVariableNames: 'entrySelector executeSelector exitSelector timeoutValue timeoutState'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!!AvStateHandler methodsFor: 'accessing' stamp: 'Jon 11/27/2004 21:31'!executeSelector	^ executeSelector! !!AvStateHandler methodsFor: 'accessing' stamp: 'Jon 11/27/2004 21:31'!executeSelector: aSymbol	executeSelector := aSymbol! !!AvStateHandler methodsFor: 'accessing' stamp: 'Jon 11/27/2004 21:31'!exitSelector	^ exitSelector! !!AvStateHandler methodsFor: 'accessing' stamp: 'Jon 11/27/2004 21:32'!exitSelector: aSymbol	exitSelector := aSymbol! !!AvStateHandler methodsFor: 'accessing' stamp: 'Jon 11/27/2004 21:31'!initializeSelector	^ initializeSelector! !!AvStateHandler methodsFor: 'accessing' stamp: 'Jon 11/27/2004 21:32'!initializeSelector: aSymbol	initializeSelector := aSymbol! !!AvStateHandler methodsFor: 'accessing' stamp: 'Jon 12/4/2004 08:51'!timeout: milliseconds switchingTo: timeoutStateName	"Set the timeout value (in milliseconds) for this state. If the FSM is in this state for more	than timeoutValue, then set it up to automatically switch to the timeout state provided."	timeoutValue := milliseconds.	timeoutState := timeoutStateName.! !!AvStateHandler methodsFor: 'accessing' stamp: 'Jon 12/4/2004 08:27'!timeoutState	^timeoutState! !!AvStateHandler methodsFor: 'accessing' stamp: 'Jon 12/4/2004 08:27'!timeoutValue	^timeoutValue! !!AvStateHandler methodsFor: 'execution' stamp: 'Jon 11/27/2004 22:02'!executeEntryFor: target	entrySelector notNil		ifTrue: [target perform: entrySelector].! !!AvStateHandler methodsFor: 'execution' stamp: 'Jon 11/27/2004 22:02'!executeExitFor: target	exitSelector notNil		ifTrue: [target perform: exitSelector].! !!AvStateHandler methodsFor: 'execution' stamp: 'Jon 11/27/2004 22:02'!executeFor: target	target perform: executeSelector.! !!AvStateHandler methodsFor: 'printing' stamp: 'Jon 11/27/2004 21:47'!printOn: aStream	aStream		print: self class;		nextPutAll: ' (';		nextPutAll: (entrySelector isNil			ifTrue: ['']			ifFalse: ['entry: #', entrySelector, ' - ']);		nextPutAll: (executeSelector isNil			ifTrue: ['']			ifFalse: ['execute: #', executeSelector, ' - ']);		nextPutAll: (exitSelector isNil			ifTrue: ['']			ifFalse: ['exit: #', exitSelector, ' - ']);		nextPut: $)! !Object subclass: #AvStateMachine	instanceVariableNames: 'name currentState nextState millisecondsAtStateSwitch stateHandlerMap target'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!!AvStateMachine methodsFor: 'initializing' stamp: 'Jon 11/27/2004 21:44'!initialize	stateHandlerMap := Dictionary new.! !!AvStateMachine methodsFor: 'accessing' stamp: 'Jon 11/27/2004 21:32'!currentState	^ currentState! !!AvStateMachine methodsFor: 'accessing' stamp: 'Jon 12/4/2004 08:50'!currentStateHandler	^self stateHandlerFor: currentState! !!AvStateMachine methodsFor: 'accessing' stamp: 'Jon 12/4/2004 08:23'!millisecondsInCurrentState	"Answer the number of milliseconds the receiver has been in the current state."	^Time millisecondsSince: millisecondsAtStateSwitch! !!AvStateMachine methodsFor: 'accessing' stamp: 'Jon 11/27/2004 21:48'!name	^ name! !!AvStateMachine methodsFor: 'accessing' stamp: 'Jon 11/27/2004 21:48'!name: aString	name := aString! !!AvStateMachine methodsFor: 'accessing' stamp: 'Jon 11/27/2004 21:32'!nextState	^ nextState! !!AvStateMachine methodsFor: 'accessing' stamp: 'Jon 11/27/2004 21:38'!nextState: stateObject	nextState := stateObject! !!AvStateMachine methodsFor: 'accessing' stamp: 'Jon 12/4/2004 08:49'!setTimeout: timeInMilliseconds for: state to: timeoutState	(self stateHandlerFor: state)		timeout: timeInMilliseconds		switchingTo: timeoutState.! !!AvStateMachine methodsFor: 'building' stamp: 'Jon 11/27/2004 22:16'!addStateHandler: stateHandler for: state	stateHandlerMap at: state put: stateHandler! !!AvStateMachine methodsFor: 'execution' stamp: 'Jon 12/4/2004 08:27'!execute	| stateHandler |	currentState = nextState		ifTrue: [stateHandler := self currentStateHandler]		ifFalse: [			self switchToNextState.			(stateHandler := self currentStateHandler) executeEntryFor: target].	stateHandler executeFor: target.	currentState = nextState		ifTrue: [self checkTimeoutFor: stateHandler]		ifFalse: [stateHandler executeExitFor: target].! !!AvStateMachine methodsFor: 'private' stamp: 'Jon 12/4/2004 08:29'!checkTimeoutFor: stateHandler	"Check and see if we've timed out -- if so, handle it appropriately."	stateHandler timeoutValue isNil		ifTrue: [^self].	self millisecondsInCurrentState >= stateHandler timeoutValue		ifTrue: [self nextState: stateHandler timeoutState].! !!AvStateMachine methodsFor: 'private' stamp: 'Jon 12/4/2004 08:34'!on: targetObject	target := targetObject.! !!AvStateMachine methodsFor: 'private' stamp: 'Jon 12/4/2004 08:49'!stateHandlerFor: state	^stateHandlerMap at: state! !!AvStateMachine methodsFor: 'private' stamp: 'Jon 12/4/2004 08:22'!switchToNextState	currentState := nextState.	millisecondsAtStateSwitch := Time millisecondClockValue.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvStateMachine class	instanceVariableNames: ''!!AvStateMachine class methodsFor: 'instance creation' stamp: 'Jon 11/27/2004 21:50'!on: target	^self new		on: target;		yourself! !Object subclass: #AvTrigonometryHelper	instanceVariableNames: ''	classVariableNames: 'CosTable SinTable TanTable'	poolDictionaries: ''	category: 'Av-Support'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvTrigonometryHelper class	instanceVariableNames: ''!!AvTrigonometryHelper class methodsFor: 'trigonometry' stamp: 'Jon 1/26/2006 12:21'!cosOf: aScaledDecimal	"Answer the cos of the given number. Use a lookup table for speed."	| roundedValue |	roundedValue := ((aScaledDecimal * 10) truncated) \\ 3600.	^self cosTable at: roundedValue + 1! !!AvTrigonometryHelper class methodsFor: 'trigonometry' stamp: 'Jon 1/26/2006 12:20'!sinOf: aScaledDecimal	"Answer the sin of the given number. Use a lookup table for speed."	| roundedValue |	roundedValue := ((aScaledDecimal * 10) truncated) \\ 3600.	^self sinTable at: roundedValue + 1! !!AvTrigonometryHelper class methodsFor: 'trigonometry' stamp: 'Jon 1/26/2006 12:21'!tanOf: aScaledDecimal	"Answer the tan of the given number. Use a lookup table for speed."	| roundedValue |	roundedValue := ((aScaledDecimal * 10) truncated) \\ 3600.	^self tanTable at: roundedValue + 1! !!AvTrigonometryHelper class methodsFor: 'trigonometry-support' stamp: 'Jon 1/26/2006 09:03'!cosTable	"AvTrigonometryHelper cosTable"	CosTable isNil		ifTrue: [self initializeCosTable].	^CosTable! !!AvTrigonometryHelper class methodsFor: 'trigonometry-support' stamp: 'Jon 1/26/2006 12:29'!dumpCosTable	"AvTrigonometryHelper dumpCosTable"	| stream |	stream := WriteStream on: (String new: 1000).	stream		nextPutAll: 'loadCosTable';		cr; tab; nextPutAll: '"AvTrigonometryHelper loadCosTable"';		cr; cr; tab; nextPutAll: 'CosTable := '.	CosTable printOn: stream.	^stream contents! !!AvTrigonometryHelper class methodsFor: 'trigonometry-support' stamp: 'Jon 1/26/2006 12:28'!dumpSinTable	"AvTrigonometryHelper dumpSinTable"	| stream |	stream := WriteStream on: (String new: 1000).	stream		nextPutAll: 'loadSinTable';		cr; tab; nextPutAll: '"AvTrigonometryHelper loadSinTable"';		cr; cr; tab; nextPutAll: 'SinTable := '.	SinTable printOn: stream.	^stream contents! !!AvTrigonometryHelper class methodsFor: 'trigonometry-support' stamp: 'Jon 1/26/2006 12:29'!dumpTanTable	"AvTrigonometryHelper dumpTanTable"	| stream |	stream := WriteStream on: (String new: 1000).	stream		nextPutAll: 'loadTanTable';		cr; tab; nextPutAll: '"AvTrigonometryHelper loadTanTable"';		cr; cr; tab; nextPutAll: 'TanTable := '.	TanTable printOn: stream.	^stream contents! !!AvTrigonometryHelper class methodsFor: 'trigonometry-support' stamp: 'Jon 1/26/2006 12:31'!initializeCosTable	"AvTrigonometryHelper initializeCosTable"	AvSystem current isEmbeddedSystem		ifTrue: [self loadCosTable]		ifFalse: [			CosTable := (0 to: 3599) collect: [:each |				(each / 10.0) degreesToRadians cos asScaledDecimal: 6]].! !!AvTrigonometryHelper class methodsFor: 'trigonometry-support' stamp: 'Jon 1/26/2006 12:32'!initializeSinTable	"AvTrigonometryHelper initializeSinTable"	AvSystem current isEmbeddedSystem		ifTrue: [self loadSinTable]		ifFalse: [			SinTable := (0 to: 3599) collect: [:each |				(each / 10.0) degreesToRadians sin asScaledDecimal: 6]].! !!AvTrigonometryHelper class methodsFor: 'trigonometry-support' stamp: 'Jon 1/26/2006 12:32'!initializeTanTable	"AvTrigonometryHelper initializeTanTable"	AvSystem current isEmbeddedSystem		ifTrue: [self loadTanTable]		ifFalse: [			TanTable := (0 to: 3599) collect: [:each |				(each / 10.0) degreesToRadians tan asScaledDecimal: 6]].! !!AvTrigonometryHelper class methodsFor: 'trigonometry-support' stamp: 'Jon 1/26/2006 12:29'!loadCosTable	"AvTrigonometryHelper loadCosTable"	CosTable := #(1.000000s6 0.999998s6 0.999993s6 0.999986s6 0.999975s6 0.999961s6 0.999945s6 0.999925s6 0.999902s6 0.999876s6 0.999847s6 0.999815s6 0.999780s6 0.999742s6 0.999701s6 0.999657s6 0.999610s6 0.999559s6 0.999506s6 0.999450s6 0.999390s6 0.999328s6 0.999262s6 0.999194s6 0.999122s6 0.999048s6 0.998970s6 0.998889s6 0.998806s6 0.998719s6 0.998629s6 0.998536s6 0.998440s6 0.998341s6 0.998239s6 0.998134s6 0.998026s6 0.997915s6 0.997801s6 0.997684s6 0.997564s6 0.997440s6 0.997314s6 0.997185s6 0.997052s6 0.996917s6 0.996778s6 0.996637s6 0.996492s6 0.996345s6 0.996194s6 0.996041s6 0.995884s6 0.995724s6 0.995561s6 0.995396s6 0.995227s6 0.995055s6 0.994880s6 0.994702s6 0.994521s6 0.994337s6 0.994150s6 0.993960s6 0.993767s6 0.993571s6 0.993372s6 0.993170s6 0.992965s6 0.992757s6 0.992546s6 0.992331s6 0.992114s6 0.991894s6 0.991671s6 0.991444s6 0.991215s6 0.990983s6 0.990747s6 0.990509s6 0.990268s6 0.990023s6 0.989776s6 0.989525s6 0.989272s6 0.989015s6 0.988756s6 0.988493s6 0.988228s6 0.987959s6 0.987688s6 0.987413s6 0.987136s6 0.986855s6 0.986572s6 0.986285s6 0.985996s6 0.985703s6 0.985407s6 0.985109s6 0.984807s6 0.984503s6 0.984195s6 0.983885s6 0.983571s6 0.983254s6 0.982935s6 0.982612s6 0.982287s6 0.981958s6 0.981627s6 0.981292s6 0.980955s6 0.980614s6 0.980271s6 0.979924s6 0.979575s6 0.979222s6 0.978867s6 0.978508s6 0.978147s6 0.977783s6 0.977415s6 0.977045s6 0.976672s6 0.976296s6 0.975916s6 0.975534s6 0.975149s6 0.974761s6 0.974370s6 0.973975s6 0.973578s6 0.973178s6 0.972775s6 0.972369s6 0.971961s6 0.971549s6 0.971134s6 0.970716s6 0.970295s6 0.969872s6 0.969445s6 0.969015s6 0.968583s6 0.968147s6 0.967709s6 0.967267s6 0.966823s6 0.966376s6 0.965925s6 0.965472s6 0.965016s6 0.964557s6 0.964095s6 0.963630s6 0.963162s6 0.962691s6 0.962217s6 0.961741s6 0.961261s6 0.960779s6 0.960293s6 0.959805s6 0.959313s6 0.958819s6 0.958322s6 0.957822s6 0.957319s6 0.956813s6 0.956304s6 0.955793s6 0.955278s6 0.954760s6 0.954240s6 0.953716s6 0.953190s6 0.952661s6 0.952129s6 0.951594s6 0.951056s6 0.950515s6 0.949972s6 0.949425s6 0.948876s6 0.948323s6 0.947768s6 0.947210s6 0.946649s6 0.946085s6 0.945518s6 0.944948s6 0.944376s6 0.943800s6 0.943222s6 0.942641s6 0.942057s6 0.941470s6 0.940880s6 0.940288s6 0.939692s6 0.939094s6 0.938493s6 0.937888s6 0.937281s6 0.936672s6 0.936059s6 0.935444s6 0.934825s6 0.934204s6 0.933580s6 0.932953s6 0.932323s6 0.931691s6 0.931055s6 0.930417s6 0.929776s6 0.929132s6 0.928485s6 0.927836s6 0.927183s6 0.926528s6 0.925870s6 0.925209s6 0.924546s6 0.923879s6 0.923210s6 0.922538s6 0.921863s6 0.921185s6 0.920504s6 0.919821s6 0.919135s6 0.918446s6 0.917754s6 0.917060s6 0.916362s6 0.915662s6 0.914959s6 0.914253s6 0.913545s6 0.912834s6 0.912120s6 0.911403s6 0.910683s6 0.909961s6 0.909236s6 0.908508s6 0.907777s6 0.907044s6 0.906307s6 0.905568s6 0.904827s6 0.904082s6 0.903335s6 0.902585s6 0.901832s6 0.901077s6 0.900318s6 0.899557s6 0.898794s6 0.898027s6 0.897258s6 0.896486s6 0.895711s6 0.894934s6 0.894154s6 0.893371s6 0.892585s6 0.891797s6 0.891006s6 0.890212s6 0.889416s6 0.888617s6 0.887815s6 0.887010s6 0.886203s6 0.885393s6 0.884580s6 0.883765s6 0.882947s6 0.882126s6 0.881303s6 0.880477s6 0.879648s6 0.878817s6 0.877982s6 0.877146s6 0.876306s6 0.875464s6 0.874619s6 0.873772s6 0.872922s6 0.872069s6 0.871213s6 0.870355s6 0.869494s6 0.868631s6 0.867765s6 0.866896s6 0.866025s6 0.865151s6 0.864274s6 0.863395s6 0.862513s6 0.861629s6 0.860742s6 0.859852s6 0.858959s6 0.858064s6 0.857167s6 0.856267s6 0.855364s6 0.854458s6 0.853550s6 0.852640s6 0.851726s6 0.850811s6 0.849892s6 0.848971s6 0.848048s6 0.847121s6 0.846193s6 0.845261s6 0.844327s6 0.843391s6 0.842452s6 0.841510s6 0.840566s6 0.839619s6 0.838670s6 0.837718s6 0.836764s6 0.835807s6 0.834847s6 0.833885s6 0.832921s6 0.831954s6 0.830984s6 0.830012s6 0.829037s6 0.828060s6 0.827080s6 0.826098s6 0.825113s6 0.824126s6 0.823136s6 0.822144s6 0.821149s6 0.820151s6 0.819152s6 0.818149s6 0.817144s6 0.816137s6 0.815127s6 0.814115s6 0.813100s6 0.812083s6 0.811063s6 0.810041s6 0.809016s6 0.807989s6 0.806960s6 0.805928s6 0.804893s6 0.803856s6 0.802817s6 0.801775s6 0.800731s6 0.799684s6 0.798635s6 0.797583s6 0.796529s6 0.795473s6 0.794414s6 0.793353s6 0.792289s6 0.791223s6 0.790155s6 0.789084s6 0.788010s6 0.786935s6 0.785856s6 0.784776s6 0.783693s6 0.782608s6 0.781520s6 0.780430s6 0.779337s6 0.778243s6 0.777145s6 0.776046s6 0.774944s6 0.773840s6 0.772733s6 0.771624s6 0.770513s6 0.769399s6 0.768283s6 0.767165s6 0.766044s6 0.764921s6 0.763796s6 0.762668s6 0.761538s6 0.760405s6 0.759271s6 0.758134s6 0.756995s6 0.755853s6 0.754709s6 0.753563s6 0.752414s6 0.751264s6 0.750111s6 0.748955s6 0.747798s6 0.746638s6 0.745475s6 0.744311s6 0.743144s6 0.741975s6 0.740804s6 0.739631s6 0.738455s6 0.737277s6 0.736097s6 0.734914s6 0.733729s6 0.732542s6 0.731353s6 0.730162s6 0.728968s6 0.727772s6 0.726574s6 0.725374s6 0.724171s6 0.722967s6 0.721760s6 0.720551s6 0.719339s6 0.718126s6 0.716910s6 0.715692s6 0.714472s6 0.713250s6 0.712026s6 0.710799s6 0.709570s6 0.708339s6 0.707106s6 0.705871s6 0.704634s6 0.703394s6 0.702153s6 0.700909s6 0.699663s6 0.698415s6 0.697165s6 0.695912s6 0.694658s6 0.693401s6 0.692143s6 0.690882s6 0.689619s6 0.688354s6 0.687087s6 0.685818s6 0.684547s6 0.683273s6 0.681998s6 0.680720s6 0.679441s6 0.678159s6 0.676875s6 0.675590s6 0.674302s6 0.673012s6 0.671720s6 0.670426s6 0.669130s6 0.667832s6 0.666532s6 0.665230s6 0.663926s6 0.662620s6 0.661311s6 0.660001s6 0.658689s6 0.657375s6 0.656059s6 0.654740s6 0.653420s6 0.652098s6 0.650774s6 0.649448s6 0.648119s6 0.646789s6 0.645457s6 0.644123s6 0.642787s6 0.641449s6 0.640109s6 0.638767s6 0.637423s6 0.636078s6 0.634730s6 0.633380s6 0.632029s6 0.630675s6 0.629320s6 0.627963s6 0.626603s6 0.625242s6 0.623879s6 0.622514s6 0.621147s6 0.619779s6 0.618408s6 0.617035s6 0.615661s6 0.614285s6 0.612907s6 0.611527s6 0.610145s6 0.608761s6 0.607375s6 0.605988s6 0.604599s6 0.603207s6 0.601815s6 0.600420s6 0.599023s6 0.597625s6 0.596224s6 0.594822s6 0.593418s6 0.592013s6 0.590605s6 0.589196s6 0.587785s6 0.586372s6 0.584957s6 0.583541s6 0.582122s6 0.580702s6 0.579281s6 0.577857s6 0.576432s6 0.575005s6 0.573576s6 0.572145s6 0.570713s6 0.569279s6 0.567843s6 0.566406s6 0.564967s6 0.563526s6 0.562083s6 0.560638s6 0.559192s6 0.557745s6 0.556295s6 0.554844s6 0.553391s6 0.551936s6 0.550480s6 0.549022s6 0.547563s6 0.546101s6 0.544639s6 0.543174s6 0.541708s6 0.540240s6 0.538770s6 0.537299s6 0.535826s6 0.534352s6 0.532876s6 0.531398s6 0.529919s6 0.528438s6 0.526955s6 0.525471s6 0.523985s6 0.522498s6 0.521009s6 0.519519s6 0.518027s6 0.516533s6 0.515038s6 0.513541s6 0.512042s6 0.510542s6 0.509041s6 0.507538s6 0.506033s6 0.504527s6 0.503019s6 0.501510s6 0.500000s6 0.498487s6 0.496973s6 0.495458s6 0.493941s6 0.492423s6 0.490903s6 0.489382s6 0.487859s6 0.486335s6 0.484809s6 0.483282s6 0.481753s6 0.480223s6 0.478691s6 0.477158s6 0.475624s6 0.474088s6 0.472550s6 0.471011s6 0.469471s6 0.467929s6 0.466386s6 0.464842s6 0.463296s6 0.461748s6 0.460199s6 0.458649s6 0.457097s6 0.455544s6 0.453990s6 0.452434s6 0.450877s6 0.449318s6 0.447759s6 0.446197s6 0.444635s6 0.443071s6 0.441505s6 0.439939s6 0.438371s6 0.436801s6 0.435231s6 0.433659s6 0.432085s6 0.430511s6 0.428935s6 0.427357s6 0.425779s6 0.424199s6 0.422618s6 0.421035s6 0.419452s6 0.417867s6 0.416280s6 0.414693s6 0.413104s6 0.411514s6 0.409923s6 0.408330s6 0.406736s6 0.405141s6 0.403545s6 0.401947s6 0.400349s6 0.398749s6 0.397147s6 0.395545s6 0.393941s6 0.392337s6 0.390731s6 0.389123s6 0.387515s6 0.385906s6 0.384295s6 0.382683s6 0.381070s6 0.379456s6 0.377840s6 0.376224s6 0.374606s6 0.372987s6 0.371367s6 0.369746s6 0.368124s6 0.366501s6 0.364876s6 0.363251s6 0.361624s6 0.359996s6 0.358367s6 0.356737s6 0.355106s6 0.353474s6 0.351841s6 0.350207s6 0.348572s6 0.346935s6 0.345298s6 0.343659s6 0.342020s6 0.340379s6 0.338737s6 0.337095s6 0.335451s6 0.333806s6 0.332161s6 0.330514s6 0.328866s6 0.327217s6 0.325568s6 0.323917s6 0.322265s6 0.320612s6 0.318959s6 0.317304s6 0.315649s6 0.313992s6 0.312334s6 0.310676s6 0.309016s6 0.307356s6 0.305695s6 0.304033s6 0.302369s6 0.300705s6 0.299040s6 0.297374s6 0.295708s6 0.294040s6 0.292371s6 0.290702s6 0.289031s6 0.287360s6 0.285688s6 0.284015s6 0.282341s6 0.280666s6 0.278991s6 0.277314s6 0.275637s6 0.273959s6 0.272280s6 0.270600s6 0.268919s6 0.267238s6 0.265556s6 0.263873s6 0.262189s6 0.260504s6 0.258819s6 0.257132s6 0.255445s6 0.253757s6 0.252069s6 0.250380s6 0.248689s6 0.246999s6 0.245307s6 0.243615s6 0.241921s6 0.240228s6 0.238533s6 0.236838s6 0.235142s6 0.233445s6 0.231747s6 0.230049s6 0.228350s6 0.226651s6 0.224951s6 0.223250s6 0.221548s6 0.219846s6 0.218143s6 0.216439s6 0.214735s6 0.213030s6 0.211324s6 0.209618s6 0.207911s6 0.206204s6 0.204496s6 0.202787s6 0.201077s6 0.199367s6 0.197657s6 0.195946s6 0.194234s6 0.192521s6 0.190808s6 0.189095s6 0.187381s6 0.185666s6 0.183951s6 0.182235s6 0.180519s6 0.178802s6 0.177084s6 0.175366s6 0.173648s6 0.171929s6 0.170209s6 0.168489s6 0.166768s6 0.165047s6 0.163325s6 0.161603s6 0.159881s6 0.158158s6 0.156434s6 0.154710s6 0.152985s6 0.151260s6 0.149535s6 0.147809s6 0.146083s6 0.144356s6 0.142628s6 0.140901s6 0.139173s6 0.137444s6 0.135715s6 0.133986s6 0.132256s6 0.130526s6 0.128795s6 0.127064s6 0.125333s6 0.123601s6 0.121869s6 0.120136s6 0.118403s6 0.116670s6 0.114937s6 0.113203s6 0.111468s6 0.109734s6 0.107999s6 0.106264s6 0.104528s6 0.102792s6 0.101056s6 0.099319s6 0.097582s6 0.095845s6 0.094108s6 0.092370s6 0.090632s6 0.088894s6 0.087155s6 0.085416s6 0.083677s6 0.081938s6 0.080198s6 0.078459s6 0.076719s6 0.074978s6 0.073238s6 0.071497s6 0.069756s6 0.068015s6 0.066273s6 0.064532s6 0.062790s6 0.061048s6 0.059306s6 0.057564s6 0.055821s6 0.054078s6 0.052335s6 0.050592s6 0.048849s6 0.047106s6 0.045362s6 0.043619s6 0.041875s6 0.040131s6 0.038387s6 0.036643s6 0.034899s6 0.033155s6 0.031410s6 0.029666s6 0.027921s6 0.026176s6 0.024432s6 0.022687s6 0.020942s6 0.019197s6 0.017452s6 0.015707s6 0.013962s6 0.012217s6 0.010471s6 0.008726s6 0.006981s6 0.005235s6 0.003490s6 0.001745s6 0.000000s6 -0.001745s6 -0.003490s6 -0.005235s6 -0.006981s6 -0.008726s6 -0.010471s6 -0.012217s6 -0.013962s6 -0.015707s6 -0.017452s6 -0.019197s6 -0.020942s6 -0.022687s6 -0.024432s6 -0.026176s6 -0.027921s6 -0.029666s6 -0.031410s6 -0.033155s6 -0.034899s6 -0.036643s6 -0.038387s6 -0.040131s6 -0.041875s6 -0.043619s6 -0.045362s6 -0.047106s6 -0.048849s6 -0.050592s6 -0.052335s6 -0.054078s6 -0.055821s6 -0.057564s6 -0.059306s6 -0.061048s6 -0.062790s6 -0.064532s6 -0.066273s6 -0.068015s6 -0.069756s6 -0.071497s6 -0.073238s6 -0.074978s6 -0.076719s6 -0.078459s6 -0.080198s6 -0.081938s6 -0.083677s6 -0.085416s6 -0.087155s6 -0.088894s6 -0.090632s6 -0.092370s6 -0.094108s6 -0.095845s6 -0.097582s6 -0.099319s6 -0.101056s6 -0.102792s6 -0.104528s6 -0.106264s6 -0.107999s6 -0.109734s6 -0.111468s6 -0.113203s6 -0.114937s6 -0.116670s6 -0.118403s6 -0.120136s6 -0.121869s6 -0.123601s6 -0.125333s6 -0.127064s6 -0.128795s6 -0.130526s6 -0.132256s6 -0.133986s6 -0.135715s6 -0.137444s6 -0.139173s6 -0.140901s6 -0.142628s6 -0.144356s6 -0.146083s6 -0.147809s6 -0.149535s6 -0.151260s6 -0.152985s6 -0.154710s6 -0.156434s6 -0.158158s6 -0.159881s6 -0.161603s6 -0.163325s6 -0.165047s6 -0.166768s6 -0.168489s6 -0.170209s6 -0.171929s6 -0.173648s6 -0.175366s6 -0.177084s6 -0.178802s6 -0.180519s6 -0.182235s6 -0.183951s6 -0.185666s6 -0.187381s6 -0.189095s6 -0.190808s6 -0.192521s6 -0.194234s6 -0.195946s6 -0.197657s6 -0.199367s6 -0.201077s6 -0.202787s6 -0.204496s6 -0.206204s6 -0.207911s6 -0.209618s6 -0.211324s6 -0.213030s6 -0.214735s6 -0.216439s6 -0.218143s6 -0.219846s6 -0.221548s6 -0.223250s6 -0.224951s6 -0.226651s6 -0.228350s6 -0.230049s6 -0.231747s6 -0.233445s6 -0.235142s6 -0.236838s6 -0.238533s6 -0.240228s6 -0.241921s6 -0.243615s6 -0.245307s6 -0.246999s6 -0.248689s6 -0.250380s6 -0.252069s6 -0.253757s6 -0.255445s6 -0.257132s6 -0.258819s6 -0.260504s6 -0.262189s6 -0.263873s6 -0.265556s6 -0.267238s6 -0.268919s6 -0.270600s6 -0.272280s6 -0.273959s6 -0.275637s6 -0.277314s6 -0.278991s6 -0.280666s6 -0.282341s6 -0.284015s6 -0.285688s6 -0.287360s6 -0.289031s6 -0.290702s6 -0.292371s6 -0.294040s6 -0.295708s6 -0.297374s6 -0.299040s6 -0.300705s6 -0.302369s6 -0.304033s6 -0.305695s6 -0.307356s6 -0.309016s6 -0.310676s6 -0.312334s6 -0.313992s6 -0.315649s6 -0.317304s6 -0.318959s6 -0.320612s6 -0.322265s6 -0.323917s6 -0.325568s6 -0.327217s6 -0.328866s6 -0.330514s6 -0.332161s6 -0.333806s6 -0.335451s6 -0.337095s6 -0.338737s6 -0.340379s6 -0.342020s6 -0.343659s6 -0.345298s6 -0.346935s6 -0.348572s6 -0.350207s6 -0.351841s6 -0.353474s6 -0.355106s6 -0.356737s6 -0.358367s6 -0.359996s6 -0.361624s6 -0.363251s6 -0.364876s6 -0.366501s6 -0.368124s6 -0.369746s6 -0.371367s6 -0.372987s6 -0.374606s6 -0.376224s6 -0.377840s6 -0.379456s6 -0.381070s6 -0.382683s6 -0.384295s6 -0.385906s6 -0.387515s6 -0.389123s6 -0.390731s6 -0.392337s6 -0.393941s6 -0.395545s6 -0.397147s6 -0.398749s6 -0.400349s6 -0.401947s6 -0.403545s6 -0.405141s6 -0.406736s6 -0.408330s6 -0.409923s6 -0.411514s6 -0.413104s6 -0.414693s6 -0.416280s6 -0.417867s6 -0.419452s6 -0.421035s6 -0.422618s6 -0.424199s6 -0.425779s6 -0.427357s6 -0.428935s6 -0.430511s6 -0.432085s6 -0.433659s6 -0.435231s6 -0.436801s6 -0.438371s6 -0.439939s6 -0.441505s6 -0.443071s6 -0.444635s6 -0.446197s6 -0.447759s6 -0.449318s6 -0.450877s6 -0.452434s6 -0.453990s6 -0.455544s6 -0.457097s6 -0.458649s6 -0.460199s6 -0.461748s6 -0.463296s6 -0.464842s6 -0.466386s6 -0.467929s6 -0.469471s6 -0.471011s6 -0.472550s6 -0.474088s6 -0.475624s6 -0.477158s6 -0.478691s6 -0.480223s6 -0.481753s6 -0.483282s6 -0.484809s6 -0.486335s6 -0.487859s6 -0.489382s6 -0.490903s6 -0.492423s6 -0.493941s6 -0.495458s6 -0.496973s6 -0.498487s6 -0.499999s6 -0.501510s6 -0.503019s6 -0.504527s6 -0.506033s6 -0.507538s6 -0.509041s6 -0.510542s6 -0.512042s6 -0.513541s6 -0.515038s6 -0.516533s6 -0.518027s6 -0.519519s6 -0.521009s6 -0.522498s6 -0.523985s6 -0.525471s6 -0.526955s6 -0.528438s6 -0.529919s6 -0.531398s6 -0.532876s6 -0.534352s6 -0.535826s6 -0.537299s6 -0.538770s6 -0.540240s6 -0.541708s6 -0.543174s6 -0.544639s6 -0.546101s6 -0.547563s6 -0.549022s6 -0.550480s6 -0.551936s6 -0.553391s6 -0.554844s6 -0.556295s6 -0.557745s6 -0.559192s6 -0.560638s6 -0.562083s6 -0.563526s6 -0.564967s6 -0.566406s6 -0.567843s6 -0.569279s6 -0.570713s6 -0.572145s6 -0.573576s6 -0.575005s6 -0.576432s6 -0.577857s6 -0.579281s6 -0.580702s6 -0.582122s6 -0.583541s6 -0.584957s6 -0.586372s6 -0.587785s6 -0.589196s6 -0.590605s6 -0.592013s6 -0.593418s6 -0.594822s6 -0.596224s6 -0.597625s6 -0.599023s6 -0.600420s6 -0.601815s6 -0.603207s6 -0.604599s6 -0.605988s6 -0.607375s6 -0.608761s6 -0.610145s6 -0.611527s6 -0.612907s6 -0.614285s6 -0.615661s6 -0.617035s6 -0.618408s6 -0.619779s6 -0.621147s6 -0.622514s6 -0.623879s6 -0.625242s6 -0.626603s6 -0.627963s6 -0.629320s6 -0.630675s6 -0.632029s6 -0.633380s6 -0.634730s6 -0.636078s6 -0.637423s6 -0.638767s6 -0.640109s6 -0.641449s6 -0.642787s6 -0.644123s6 -0.645457s6 -0.646789s6 -0.648119s6 -0.649448s6 -0.650774s6 -0.652098s6 -0.653420s6 -0.654740s6 -0.656059s6 -0.657375s6 -0.658689s6 -0.660001s6 -0.661311s6 -0.662620s6 -0.663926s6 -0.665230s6 -0.666532s6 -0.667832s6 -0.669130s6 -0.670426s6 -0.671720s6 -0.673012s6 -0.674302s6 -0.675590s6 -0.676875s6 -0.678159s6 -0.679441s6 -0.680720s6 -0.681998s6 -0.683273s6 -0.684547s6 -0.685818s6 -0.687087s6 -0.688354s6 -0.689619s6 -0.690882s6 -0.692143s6 -0.693401s6 -0.694658s6 -0.695912s6 -0.697165s6 -0.698415s6 -0.699663s6 -0.700909s6 -0.702153s6 -0.703394s6 -0.704634s6 -0.705871s6 -0.707106s6 -0.708339s6 -0.709570s6 -0.710799s6 -0.712026s6 -0.713250s6 -0.714472s6 -0.715692s6 -0.716910s6 -0.718126s6 -0.719339s6 -0.720551s6 -0.721760s6 -0.722967s6 -0.724171s6 -0.725374s6 -0.726574s6 -0.727772s6 -0.728968s6 -0.730162s6 -0.731353s6 -0.732542s6 -0.733729s6 -0.734914s6 -0.736097s6 -0.737277s6 -0.738455s6 -0.739631s6 -0.740804s6 -0.741975s6 -0.743144s6 -0.744311s6 -0.745475s6 -0.746638s6 -0.747798s6 -0.748955s6 -0.750111s6 -0.751264s6 -0.752414s6 -0.753563s6 -0.754709s6 -0.755853s6 -0.756995s6 -0.758134s6 -0.759271s6 -0.760405s6 -0.761538s6 -0.762668s6 -0.763796s6 -0.764921s6 -0.766044s6 -0.767165s6 -0.768283s6 -0.769399s6 -0.770513s6 -0.771624s6 -0.772733s6 -0.773840s6 -0.774944s6 -0.776046s6 -0.777145s6 -0.778243s6 -0.779337s6 -0.780430s6 -0.781520s6 -0.782608s6 -0.783693s6 -0.784776s6 -0.785856s6 -0.786935s6 -0.788010s6 -0.789084s6 -0.790155s6 -0.791223s6 -0.792289s6 -0.793353s6 -0.794414s6 -0.795473s6 -0.796529s6 -0.797583s6 -0.798635s6 -0.799684s6 -0.800731s6 -0.801775s6 -0.802817s6 -0.803856s6 -0.804893s6 -0.805928s6 -0.806960s6 -0.807989s6 -0.809016s6 -0.810041s6 -0.811063s6 -0.812083s6 -0.813100s6 -0.814115s6 -0.815127s6 -0.816137s6 -0.817144s6 -0.818149s6 -0.819152s6 -0.820151s6 -0.821149s6 -0.822144s6 -0.823136s6 -0.824126s6 -0.825113s6 -0.826098s6 -0.827080s6 -0.828060s6 -0.829037s6 -0.830012s6 -0.830984s6 -0.831954s6 -0.832921s6 -0.833885s6 -0.834847s6 -0.835807s6 -0.836764s6 -0.837718s6 -0.838670s6 -0.839619s6 -0.840566s6 -0.841510s6 -0.842452s6 -0.843391s6 -0.844327s6 -0.845261s6 -0.846193s6 -0.847121s6 -0.848048s6 -0.848971s6 -0.849892s6 -0.850811s6 -0.851726s6 -0.852640s6 -0.853550s6 -0.854458s6 -0.855364s6 -0.856267s6 -0.857167s6 -0.858064s6 -0.858959s6 -0.859852s6 -0.860742s6 -0.861629s6 -0.862513s6 -0.863395s6 -0.864274s6 -0.865151s6 -0.866025s6 -0.866896s6 -0.867765s6 -0.868631s6 -0.869494s6 -0.870355s6 -0.871213s6 -0.872069s6 -0.872922s6 -0.873772s6 -0.874619s6 -0.875464s6 -0.876306s6 -0.877146s6 -0.877982s6 -0.878817s6 -0.879648s6 -0.880477s6 -0.881303s6 -0.882126s6 -0.882947s6 -0.883765s6 -0.884580s6 -0.885393s6 -0.886203s6 -0.887010s6 -0.887815s6 -0.888617s6 -0.889416s6 -0.890212s6 -0.891006s6 -0.891797s6 -0.892585s6 -0.893371s6 -0.894154s6 -0.894934s6 -0.895711s6 -0.896486s6 -0.897258s6 -0.898027s6 -0.898794s6 -0.899557s6 -0.900318s6 -0.901077s6 -0.901832s6 -0.902585s6 -0.903335s6 -0.904082s6 -0.904827s6 -0.905568s6 -0.906307s6 -0.907044s6 -0.907777s6 -0.908508s6 -0.909236s6 -0.909961s6 -0.910683s6 -0.911403s6 -0.912120s6 -0.912834s6 -0.913545s6 -0.914253s6 -0.914959s6 -0.915662s6 -0.916362s6 -0.917060s6 -0.917754s6 -0.918446s6 -0.919135s6 -0.919821s6 -0.920504s6 -0.921185s6 -0.921863s6 -0.922538s6 -0.923210s6 -0.923879s6 -0.924546s6 -0.925209s6 -0.925870s6 -0.926528s6 -0.927183s6 -0.927836s6 -0.928485s6 -0.929132s6 -0.929776s6 -0.930417s6 -0.931055s6 -0.931691s6 -0.932323s6 -0.932953s6 -0.933580s6 -0.934204s6 -0.934825s6 -0.935444s6 -0.936059s6 -0.936672s6 -0.937281s6 -0.937888s6 -0.938493s6 -0.939094s6 -0.939692s6 -0.940288s6 -0.940880s6 -0.941470s6 -0.942057s6 -0.942641s6 -0.943222s6 -0.943800s6 -0.944376s6 -0.944948s6 -0.945518s6 -0.946085s6 -0.946649s6 -0.947210s6 -0.947768s6 -0.948323s6 -0.948876s6 -0.949425s6 -0.949972s6 -0.950515s6 -0.951056s6 -0.951594s6 -0.952129s6 -0.952661s6 -0.953190s6 -0.953716s6 -0.954240s6 -0.954760s6 -0.955278s6 -0.955793s6 -0.956304s6 -0.956813s6 -0.957319s6 -0.957822s6 -0.958322s6 -0.958819s6 -0.959313s6 -0.959805s6 -0.960293s6 -0.960779s6 -0.961261s6 -0.961741s6 -0.962217s6 -0.962691s6 -0.963162s6 -0.963630s6 -0.964095s6 -0.964557s6 -0.965016s6 -0.965472s6 -0.965925s6 -0.966376s6 -0.966823s6 -0.967267s6 -0.967709s6 -0.968147s6 -0.968583s6 -0.969015s6 -0.969445s6 -0.969872s6 -0.970295s6 -0.970716s6 -0.971134s6 -0.971549s6 -0.971961s6 -0.972369s6 -0.972775s6 -0.973178s6 -0.973578s6 -0.973975s6 -0.974370s6 -0.974761s6 -0.975149s6 -0.975534s6 -0.975916s6 -0.976296s6 -0.976672s6 -0.977045s6 -0.977415s6 -0.977783s6 -0.978147s6 -0.978508s6 -0.978867s6 -0.979222s6 -0.979575s6 -0.979924s6 -0.980271s6 -0.980614s6 -0.980955s6 -0.981292s6 -0.981627s6 -0.981958s6 -0.982287s6 -0.982612s6 -0.982935s6 -0.983254s6 -0.983571s6 -0.983885s6 -0.984195s6 -0.984503s6 -0.984807s6 -0.985109s6 -0.985407s6 -0.985703s6 -0.985996s6 -0.986285s6 -0.986572s6 -0.986855s6 -0.987136s6 -0.987413s6 -0.987688s6 -0.987959s6 -0.988228s6 -0.988493s6 -0.988756s6 -0.989015s6 -0.989272s6 -0.989525s6 -0.989776s6 -0.990023s6 -0.990268s6 -0.990509s6 -0.990747s6 -0.990983s6 -0.991215s6 -0.991444s6 -0.991671s6 -0.991894s6 -0.992114s6 -0.992331s6 -0.992546s6 -0.992757s6 -0.992965s6 -0.993170s6 -0.993372s6 -0.993571s6 -0.993767s6 -0.993960s6 -0.994150s6 -0.994337s6 -0.994521s6 -0.994702s6 -0.994880s6 -0.995055s6 -0.995227s6 -0.995396s6 -0.995561s6 -0.995724s6 -0.995884s6 -0.996041s6 -0.996194s6 -0.996345s6 -0.996492s6 -0.996637s6 -0.996778s6 -0.996917s6 -0.997052s6 -0.997185s6 -0.997314s6 -0.997440s6 -0.997564s6 -0.997684s6 -0.997801s6 -0.997915s6 -0.998026s6 -0.998134s6 -0.998239s6 -0.998341s6 -0.998440s6 -0.998536s6 -0.998629s6 -0.998719s6 -0.998806s6 -0.998889s6 -0.998970s6 -0.999048s6 -0.999122s6 -0.999194s6 -0.999262s6 -0.999328s6 -0.999390s6 -0.999450s6 -0.999506s6 -0.999559s6 -0.999610s6 -0.999657s6 -0.999701s6 -0.999742s6 -0.999780s6 -0.999815s6 -0.999847s6 -0.999876s6 -0.999902s6 -0.999925s6 -0.999945s6 -0.999961s6 -0.999975s6 -0.999986s6 -0.999993s6 -0.999998s6 -1.000000s6 -0.999998s6 -0.999993s6 -0.999986s6 -0.999975s6 -0.999961s6 -0.999945s6 -0.999925s6 -0.999902s6 -0.999876s6 -0.999847s6 -0.999815s6 -0.999780s6 -0.999742s6 -0.999701s6 -0.999657s6 -0.999610s6 -0.999559s6 -0.999506s6 -0.999450s6 -0.999390s6 -0.999328s6 -0.999262s6 -0.999194s6 -0.999122s6 -0.999048s6 -0.998970s6 -0.998889s6 -0.998806s6 -0.998719s6 -0.998629s6 -0.998536s6 -0.998440s6 -0.998341s6 -0.998239s6 -0.998134s6 -0.998026s6 -0.997915s6 -0.997801s6 -0.997684s6 -0.997564s6 -0.997440s6 -0.997314s6 -0.997185s6 -0.997052s6 -0.996917s6 -0.996778s6 -0.996637s6 -0.996492s6 -0.996345s6 -0.996194s6 -0.996041s6 -0.995884s6 -0.995724s6 -0.995561s6 -0.995396s6 -0.995227s6 -0.995055s6 -0.994880s6 -0.994702s6 -0.994521s6 -0.994337s6 -0.994150s6 -0.993960s6 -0.993767s6 -0.993571s6 -0.993372s6 -0.993170s6 -0.992965s6 -0.992757s6 -0.992546s6 -0.992331s6 -0.992114s6 -0.991894s6 -0.991671s6 -0.991444s6 -0.991215s6 -0.990983s6 -0.990747s6 -0.990509s6 -0.990268s6 -0.990023s6 -0.989776s6 -0.989525s6 -0.989272s6 -0.989015s6 -0.988756s6 -0.988493s6 -0.988228s6 -0.987959s6 -0.987688s6 -0.987413s6 -0.987136s6 -0.986855s6 -0.986572s6 -0.986285s6 -0.985996s6 -0.985703s6 -0.985407s6 -0.985109s6 -0.984807s6 -0.984503s6 -0.984195s6 -0.983885s6 -0.983571s6 -0.983254s6 -0.982935s6 -0.982612s6 -0.982287s6 -0.981958s6 -0.981627s6 -0.981292s6 -0.980955s6 -0.980614s6 -0.980271s6 -0.979924s6 -0.979575s6 -0.979222s6 -0.978867s6 -0.978508s6 -0.978147s6 -0.977783s6 -0.977415s6 -0.977045s6 -0.976672s6 -0.976296s6 -0.975916s6 -0.975534s6 -0.975149s6 -0.974761s6 -0.974370s6 -0.973975s6 -0.973578s6 -0.973178s6 -0.972775s6 -0.972369s6 -0.971961s6 -0.971549s6 -0.971134s6 -0.970716s6 -0.970295s6 -0.969872s6 -0.969445s6 -0.969015s6 -0.968583s6 -0.968147s6 -0.967709s6 -0.967267s6 -0.966823s6 -0.966376s6 -0.965925s6 -0.965472s6 -0.965016s6 -0.964557s6 -0.964095s6 -0.963630s6 -0.963162s6 -0.962691s6 -0.962217s6 -0.961741s6 -0.961261s6 -0.960779s6 -0.960293s6 -0.959805s6 -0.959313s6 -0.958819s6 -0.958322s6 -0.957822s6 -0.957319s6 -0.956813s6 -0.956304s6 -0.955793s6 -0.955278s6 -0.954760s6 -0.954240s6 -0.953716s6 -0.953190s6 -0.952661s6 -0.952129s6 -0.951594s6 -0.951056s6 -0.950515s6 -0.949972s6 -0.949425s6 -0.948876s6 -0.948323s6 -0.947768s6 -0.947210s6 -0.946649s6 -0.946085s6 -0.945518s6 -0.944948s6 -0.944376s6 -0.943800s6 -0.943222s6 -0.942641s6 -0.942057s6 -0.941470s6 -0.940880s6 -0.940288s6 -0.939692s6 -0.939094s6 -0.938493s6 -0.937888s6 -0.937281s6 -0.936672s6 -0.936059s6 -0.935444s6 -0.934825s6 -0.934204s6 -0.933580s6 -0.932953s6 -0.932323s6 -0.931691s6 -0.931055s6 -0.930417s6 -0.929776s6 -0.929132s6 -0.928485s6 -0.927836s6 -0.927183s6 -0.926528s6 -0.925870s6 -0.925209s6 -0.924546s6 -0.923879s6 -0.923210s6 -0.922538s6 -0.921863s6 -0.921185s6 -0.920504s6 -0.919821s6 -0.919135s6 -0.918446s6 -0.917754s6 -0.917060s6 -0.916362s6 -0.915662s6 -0.914959s6 -0.914253s6 -0.913545s6 -0.912834s6 -0.912120s6 -0.911403s6 -0.910683s6 -0.909961s6 -0.909236s6 -0.908508s6 -0.907777s6 -0.907044s6 -0.906307s6 -0.905568s6 -0.904827s6 -0.904082s6 -0.903335s6 -0.902585s6 -0.901832s6 -0.901077s6 -0.900318s6 -0.899557s6 -0.898794s6 -0.898027s6 -0.897258s6 -0.896486s6 -0.895711s6 -0.894934s6 -0.894154s6 -0.893371s6 -0.892585s6 -0.891797s6 -0.891006s6 -0.890212s6 -0.889416s6 -0.888617s6 -0.887815s6 -0.887010s6 -0.886203s6 -0.885393s6 -0.884580s6 -0.883765s6 -0.882947s6 -0.882126s6 -0.881303s6 -0.880477s6 -0.879648s6 -0.878817s6 -0.877982s6 -0.877146s6 -0.876306s6 -0.875464s6 -0.874619s6 -0.873772s6 -0.872922s6 -0.872069s6 -0.871213s6 -0.870355s6 -0.869494s6 -0.868631s6 -0.867765s6 -0.866896s6 -0.866025s6 -0.865151s6 -0.864274s6 -0.863395s6 -0.862513s6 -0.861629s6 -0.860742s6 -0.859852s6 -0.858959s6 -0.858064s6 -0.857167s6 -0.856267s6 -0.855364s6 -0.854458s6 -0.853550s6 -0.852640s6 -0.851726s6 -0.850811s6 -0.849892s6 -0.848971s6 -0.848048s6 -0.847121s6 -0.846193s6 -0.845261s6 -0.844327s6 -0.843391s6 -0.842452s6 -0.841510s6 -0.840566s6 -0.839619s6 -0.838670s6 -0.837718s6 -0.836764s6 -0.835807s6 -0.834847s6 -0.833885s6 -0.832921s6 -0.831954s6 -0.830984s6 -0.830012s6 -0.829037s6 -0.828060s6 -0.827080s6 -0.826098s6 -0.825113s6 -0.824126s6 -0.823136s6 -0.822144s6 -0.821149s6 -0.820151s6 -0.819152s6 -0.818149s6 -0.817144s6 -0.816137s6 -0.815127s6 -0.814115s6 -0.813100s6 -0.812083s6 -0.811063s6 -0.810041s6 -0.809016s6 -0.807989s6 -0.806960s6 -0.805928s6 -0.804893s6 -0.803856s6 -0.802817s6 -0.801775s6 -0.800731s6 -0.799684s6 -0.798635s6 -0.797583s6 -0.796529s6 -0.795473s6 -0.794414s6 -0.793353s6 -0.792289s6 -0.791223s6 -0.790155s6 -0.789084s6 -0.788010s6 -0.786935s6 -0.785856s6 -0.784776s6 -0.783693s6 -0.782608s6 -0.781520s6 -0.780430s6 -0.779337s6 -0.778243s6 -0.777145s6 -0.776046s6 -0.774944s6 -0.773840s6 -0.772733s6 -0.771624s6 -0.770513s6 -0.769399s6 -0.768283s6 -0.767165s6 -0.766044s6 -0.764921s6 -0.763796s6 -0.762668s6 -0.761538s6 -0.760405s6 -0.759271s6 -0.758134s6 -0.756995s6 -0.755853s6 -0.754709s6 -0.753563s6 -0.752414s6 -0.751264s6 -0.750111s6 -0.748955s6 -0.747798s6 -0.746638s6 -0.745475s6 -0.744311s6 -0.743144s6 -0.741975s6 -0.740804s6 -0.739631s6 -0.738455s6 -0.737277s6 -0.736097s6 -0.734914s6 -0.733729s6 -0.732542s6 -0.731353s6 -0.730162s6 -0.728968s6 -0.727772s6 -0.726574s6 -0.725374s6 -0.724171s6 -0.722967s6 -0.721760s6 -0.720551s6 -0.719339s6 -0.718126s6 -0.716910s6 -0.715692s6 -0.714472s6 -0.713250s6 -0.712026s6 -0.710799s6 -0.709570s6 -0.708339s6 -0.707106s6 -0.705871s6 -0.704634s6 -0.703394s6 -0.702153s6 -0.700909s6 -0.699663s6 -0.698415s6 -0.697165s6 -0.695912s6 -0.694658s6 -0.693401s6 -0.692143s6 -0.690882s6 -0.689619s6 -0.688354s6 -0.687087s6 -0.685818s6 -0.684547s6 -0.683273s6 -0.681998s6 -0.680720s6 -0.679441s6 -0.678159s6 -0.676875s6 -0.675590s6 -0.674302s6 -0.673012s6 -0.671720s6 -0.670426s6 -0.669130s6 -0.667832s6 -0.666532s6 -0.665230s6 -0.663926s6 -0.662620s6 -0.661311s6 -0.660001s6 -0.658689s6 -0.657375s6 -0.656059s6 -0.654740s6 -0.653420s6 -0.652098s6 -0.650774s6 -0.649448s6 -0.648119s6 -0.646789s6 -0.645457s6 -0.644123s6 -0.642787s6 -0.641449s6 -0.640109s6 -0.638767s6 -0.637423s6 -0.636078s6 -0.634730s6 -0.633380s6 -0.632029s6 -0.630675s6 -0.629320s6 -0.627963s6 -0.626603s6 -0.625242s6 -0.623879s6 -0.622514s6 -0.621147s6 -0.619779s6 -0.618408s6 -0.617035s6 -0.615661s6 -0.614285s6 -0.612907s6 -0.611527s6 -0.610145s6 -0.608761s6 -0.607375s6 -0.605988s6 -0.604599s6 -0.603207s6 -0.601815s6 -0.600420s6 -0.599023s6 -0.597625s6 -0.596224s6 -0.594822s6 -0.593418s6 -0.592013s6 -0.590605s6 -0.589196s6 -0.587785s6 -0.586372s6 -0.584957s6 -0.583541s6 -0.582122s6 -0.580702s6 -0.579281s6 -0.577857s6 -0.576432s6 -0.575005s6 -0.573576s6 -0.572145s6 -0.570713s6 -0.569279s6 -0.567843s6 -0.566406s6 -0.564967s6 -0.563526s6 -0.562083s6 -0.560638s6 -0.559192s6 -0.557745s6 -0.556295s6 -0.554844s6 -0.553391s6 -0.551936s6 -0.550480s6 -0.549022s6 -0.547563s6 -0.546101s6 -0.544639s6 -0.543174s6 -0.541708s6 -0.540240s6 -0.538770s6 -0.537299s6 -0.535826s6 -0.534352s6 -0.532876s6 -0.531398s6 -0.529919s6 -0.528438s6 -0.526955s6 -0.525471s6 -0.523985s6 -0.522498s6 -0.521009s6 -0.519519s6 -0.518027s6 -0.516533s6 -0.515038s6 -0.513541s6 -0.512042s6 -0.510542s6 -0.509041s6 -0.507538s6 -0.506033s6 -0.504527s6 -0.503019s6 -0.501510s6 -0.500000s6 -0.498487s6 -0.496973s6 -0.495458s6 -0.493941s6 -0.492423s6 -0.490903s6 -0.489382s6 -0.487859s6 -0.486335s6 -0.484809s6 -0.483282s6 -0.481753s6 -0.480223s6 -0.478691s6 -0.477158s6 -0.475624s6 -0.474088s6 -0.472550s6 -0.471011s6 -0.469471s6 -0.467929s6 -0.466386s6 -0.464842s6 -0.463296s6 -0.461748s6 -0.460199s6 -0.458649s6 -0.457097s6 -0.455544s6 -0.453990s6 -0.452434s6 -0.450877s6 -0.449318s6 -0.447759s6 -0.446197s6 -0.444635s6 -0.443071s6 -0.441505s6 -0.439939s6 -0.438371s6 -0.436801s6 -0.435231s6 -0.433659s6 -0.432085s6 -0.430511s6 -0.428935s6 -0.427357s6 -0.425779s6 -0.424199s6 -0.422618s6 -0.421035s6 -0.419452s6 -0.417867s6 -0.416280s6 -0.414693s6 -0.413104s6 -0.411514s6 -0.409923s6 -0.408330s6 -0.406736s6 -0.405141s6 -0.403545s6 -0.401947s6 -0.400349s6 -0.398749s6 -0.397147s6 -0.395545s6 -0.393941s6 -0.392337s6 -0.390731s6 -0.389123s6 -0.387515s6 -0.385906s6 -0.384295s6 -0.382683s6 -0.381070s6 -0.379456s6 -0.377840s6 -0.376224s6 -0.374606s6 -0.372987s6 -0.371367s6 -0.369746s6 -0.368124s6 -0.366501s6 -0.364876s6 -0.363251s6 -0.361624s6 -0.359996s6 -0.358367s6 -0.356737s6 -0.355106s6 -0.353474s6 -0.351841s6 -0.350207s6 -0.348572s6 -0.346935s6 -0.345298s6 -0.343659s6 -0.342020s6 -0.340379s6 -0.338737s6 -0.337095s6 -0.335451s6 -0.333806s6 -0.332161s6 -0.330514s6 -0.328866s6 -0.327217s6 -0.325568s6 -0.323917s6 -0.322265s6 -0.320612s6 -0.318959s6 -0.317304s6 -0.315649s6 -0.313992s6 -0.312334s6 -0.310676s6 -0.309016s6 -0.307356s6 -0.305695s6 -0.304033s6 -0.302369s6 -0.300705s6 -0.299040s6 -0.297374s6 -0.295708s6 -0.294040s6 -0.292371s6 -0.290702s6 -0.289031s6 -0.287360s6 -0.285688s6 -0.284015s6 -0.282341s6 -0.280666s6 -0.278991s6 -0.277314s6 -0.275637s6 -0.273959s6 -0.272280s6 -0.270600s6 -0.268919s6 -0.267238s6 -0.265556s6 -0.263873s6 -0.262189s6 -0.260504s6 -0.258819s6 -0.257132s6 -0.255445s6 -0.253757s6 -0.252069s6 -0.250380s6 -0.248689s6 -0.246999s6 -0.245307s6 -0.243615s6 -0.241921s6 -0.240228s6 -0.238533s6 -0.236838s6 -0.235142s6 -0.233445s6 -0.231747s6 -0.230049s6 -0.228350s6 -0.226651s6 -0.224951s6 -0.223250s6 -0.221548s6 -0.219846s6 -0.218143s6 -0.216439s6 -0.214735s6 -0.213030s6 -0.211324s6 -0.209618s6 -0.207911s6 -0.206204s6 -0.204496s6 -0.202787s6 -0.201077s6 -0.199367s6 -0.197657s6 -0.195946s6 -0.194234s6 -0.192521s6 -0.190808s6 -0.189095s6 -0.187381s6 -0.185666s6 -0.183951s6 -0.182235s6 -0.180519s6 -0.178802s6 -0.177084s6 -0.175366s6 -0.173648s6 -0.171929s6 -0.170209s6 -0.168489s6 -0.166768s6 -0.165047s6 -0.163325s6 -0.161603s6 -0.159881s6 -0.158158s6 -0.156434s6 -0.154710s6 -0.152985s6 -0.151260s6 -0.149535s6 -0.147809s6 -0.146083s6 -0.144356s6 -0.142628s6 -0.140901s6 -0.139173s6 -0.137444s6 -0.135715s6 -0.133986s6 -0.132256s6 -0.130526s6 -0.128795s6 -0.127064s6 -0.125333s6 -0.123601s6 -0.121869s6 -0.120136s6 -0.118403s6 -0.116670s6 -0.114937s6 -0.113203s6 -0.111468s6 -0.109734s6 -0.107999s6 -0.106264s6 -0.104528s6 -0.102792s6 -0.101056s6 -0.099319s6 -0.097582s6 -0.095845s6 -0.094108s6 -0.092370s6 -0.090632s6 -0.088894s6 -0.087155s6 -0.085416s6 -0.083677s6 -0.081938s6 -0.080198s6 -0.078459s6 -0.076719s6 -0.074978s6 -0.073238s6 -0.071497s6 -0.069756s6 -0.068015s6 -0.066273s6 -0.064532s6 -0.062790s6 -0.061048s6 -0.059306s6 -0.057564s6 -0.055821s6 -0.054078s6 -0.052335s6 -0.050592s6 -0.048849s6 -0.047106s6 -0.045362s6 -0.043619s6 -0.041875s6 -0.040131s6 -0.038387s6 -0.036643s6 -0.034899s6 -0.033155s6 -0.031410s6 -0.029666s6 -0.027921s6 -0.026176s6 -0.024432s6 -0.022687s6 -0.020942s6 -0.019197s6 -0.017452s6 -0.015707s6 -0.013962s6 -0.012217s6 -0.010471s6 -0.008726s6 -0.006981s6 -0.005235s6 -0.003490s6 -0.001745s6 -0.000000s6 0.001745s6 0.003490s6 0.005235s6 0.006981s6 0.008726s6 0.010471s6 0.012217s6 0.013962s6 0.015707s6 0.017452s6 0.019197s6 0.020942s6 0.022687s6 0.024432s6 0.026176s6 0.027921s6 0.029666s6 0.031410s6 0.033155s6 0.034899s6 0.036643s6 0.038387s6 0.040131s6 0.041875s6 0.043619s6 0.045362s6 0.047106s6 0.048849s6 0.050592s6 0.052335s6 0.054078s6 0.055821s6 0.057564s6 0.059306s6 0.061048s6 0.062790s6 0.064532s6 0.066273s6 0.068015s6 0.069756s6 0.071497s6 0.073238s6 0.074978s6 0.076719s6 0.078459s6 0.080198s6 0.081938s6 0.083677s6 0.085416s6 0.087155s6 0.088894s6 0.090632s6 0.092370s6 0.094108s6 0.095845s6 0.097582s6 0.099319s6 0.101056s6 0.102792s6 0.104528s6 0.106264s6 0.107999s6 0.109734s6 0.111468s6 0.113203s6 0.114937s6 0.116670s6 0.118403s6 0.120136s6 0.121869s6 0.123601s6 0.125333s6 0.127064s6 0.128795s6 0.130526s6 0.132256s6 0.133986s6 0.135715s6 0.137444s6 0.139173s6 0.140901s6 0.142628s6 0.144356s6 0.146083s6 0.147809s6 0.149535s6 0.151260s6 0.152985s6 0.154710s6 0.156434s6 0.158158s6 0.159881s6 0.161603s6 0.163325s6 0.165047s6 0.166768s6 0.168489s6 0.170209s6 0.171929s6 0.173648s6 0.175366s6 0.177084s6 0.178802s6 0.180519s6 0.182235s6 0.183951s6 0.185666s6 0.187381s6 0.189095s6 0.190808s6 0.192521s6 0.194234s6 0.195946s6 0.197657s6 0.199367s6 0.201077s6 0.202787s6 0.204496s6 0.206204s6 0.207911s6 0.209618s6 0.211324s6 0.213030s6 0.214735s6 0.216439s6 0.218143s6 0.219846s6 0.221548s6 0.223250s6 0.224951s6 0.226651s6 0.228350s6 0.230049s6 0.231747s6 0.233445s6 0.235142s6 0.236838s6 0.238533s6 0.240228s6 0.241921s6 0.243615s6 0.245307s6 0.246999s6 0.248689s6 0.250380s6 0.252069s6 0.253757s6 0.255445s6 0.257132s6 0.258819s6 0.260504s6 0.262189s6 0.263873s6 0.265556s6 0.267238s6 0.268919s6 0.270600s6 0.272280s6 0.273959s6 0.275637s6 0.277314s6 0.278991s6 0.280666s6 0.282341s6 0.284015s6 0.285688s6 0.287360s6 0.289031s6 0.290702s6 0.292371s6 0.294040s6 0.295708s6 0.297374s6 0.299040s6 0.300705s6 0.302369s6 0.304033s6 0.305695s6 0.307356s6 0.309016s6 0.310676s6 0.312334s6 0.313992s6 0.315649s6 0.317304s6 0.318959s6 0.320612s6 0.322265s6 0.323917s6 0.325568s6 0.327217s6 0.328866s6 0.330514s6 0.332161s6 0.333806s6 0.335451s6 0.337095s6 0.338737s6 0.340379s6 0.342020s6 0.343659s6 0.345298s6 0.346935s6 0.348572s6 0.350207s6 0.351841s6 0.353474s6 0.355106s6 0.356737s6 0.358367s6 0.359996s6 0.361624s6 0.363251s6 0.364876s6 0.366501s6 0.368124s6 0.369746s6 0.371367s6 0.372987s6 0.374606s6 0.376224s6 0.377840s6 0.379456s6 0.381070s6 0.382683s6 0.384295s6 0.385906s6 0.387515s6 0.389123s6 0.390731s6 0.392337s6 0.393941s6 0.395545s6 0.397147s6 0.398749s6 0.400349s6 0.401947s6 0.403545s6 0.405141s6 0.406736s6 0.408330s6 0.409923s6 0.411514s6 0.413104s6 0.414693s6 0.416280s6 0.417867s6 0.419452s6 0.421035s6 0.422618s6 0.424199s6 0.425779s6 0.427357s6 0.428935s6 0.430511s6 0.432085s6 0.433659s6 0.435231s6 0.436801s6 0.438371s6 0.439939s6 0.441505s6 0.443071s6 0.444635s6 0.446197s6 0.447759s6 0.449318s6 0.450877s6 0.452434s6 0.453990s6 0.455544s6 0.457097s6 0.458649s6 0.460199s6 0.461748s6 0.463296s6 0.464842s6 0.466386s6 0.467929s6 0.469471s6 0.471011s6 0.472550s6 0.474088s6 0.475624s6 0.477158s6 0.478691s6 0.480223s6 0.481753s6 0.483282s6 0.484809s6 0.486335s6 0.487859s6 0.489382s6 0.490903s6 0.492423s6 0.493941s6 0.495458s6 0.496973s6 0.498487s6 0.500000s6 0.501510s6 0.503019s6 0.504527s6 0.506033s6 0.507538s6 0.509041s6 0.510542s6 0.512042s6 0.513541s6 0.515038s6 0.516533s6 0.518027s6 0.519519s6 0.521009s6 0.522498s6 0.523985s6 0.525471s6 0.526955s6 0.528438s6 0.529919s6 0.531398s6 0.532876s6 0.534352s6 0.535826s6 0.537299s6 0.538770s6 0.540240s6 0.541708s6 0.543174s6 0.544639s6 0.546101s6 0.547563s6 0.549022s6 0.550480s6 0.551936s6 0.553391s6 0.554844s6 0.556295s6 0.557745s6 0.559192s6 0.560638s6 0.562083s6 0.563526s6 0.564967s6 0.566406s6 0.567843s6 0.569279s6 0.570713s6 0.572145s6 0.573576s6 0.575005s6 0.576432s6 0.577857s6 0.579281s6 0.580702s6 0.582122s6 0.583541s6 0.584957s6 0.586372s6 0.587785s6 0.589196s6 0.590605s6 0.592013s6 0.593418s6 0.594822s6 0.596224s6 0.597625s6 0.599023s6 0.600420s6 0.601815s6 0.603207s6 0.604599s6 0.605988s6 0.607375s6 0.608761s6 0.610145s6 0.611527s6 0.612907s6 0.614285s6 0.615661s6 0.617035s6 0.618408s6 0.619779s6 0.621147s6 0.622514s6 0.623879s6 0.625242s6 0.626603s6 0.627963s6 0.629320s6 0.630675s6 0.632029s6 0.633380s6 0.634730s6 0.636078s6 0.637423s6 0.638767s6 0.640109s6 0.641449s6 0.642787s6 0.644123s6 0.645457s6 0.646789s6 0.648119s6 0.649448s6 0.650774s6 0.652098s6 0.653420s6 0.654740s6 0.656059s6 0.657375s6 0.658689s6 0.660001s6 0.661311s6 0.662620s6 0.663926s6 0.665230s6 0.666532s6 0.667832s6 0.669130s6 0.670426s6 0.671720s6 0.673012s6 0.674302s6 0.675590s6 0.676875s6 0.678159s6 0.679441s6 0.680720s6 0.681998s6 0.683273s6 0.684547s6 0.685818s6 0.687087s6 0.688354s6 0.689619s6 0.690882s6 0.692143s6 0.693401s6 0.694658s6 0.695912s6 0.697165s6 0.698415s6 0.699663s6 0.700909s6 0.702153s6 0.703394s6 0.704634s6 0.705871s6 0.707106s6 0.708339s6 0.709570s6 0.710799s6 0.712026s6 0.713250s6 0.714472s6 0.715692s6 0.716910s6 0.718126s6 0.719339s6 0.720551s6 0.721760s6 0.722967s6 0.724171s6 0.725374s6 0.726574s6 0.727772s6 0.728968s6 0.730162s6 0.731353s6 0.732542s6 0.733729s6 0.734914s6 0.736097s6 0.737277s6 0.738455s6 0.739631s6 0.740804s6 0.741975s6 0.743144s6 0.744311s6 0.745475s6 0.746638s6 0.747798s6 0.748955s6 0.750111s6 0.751264s6 0.752414s6 0.753563s6 0.754709s6 0.755853s6 0.756995s6 0.758134s6 0.759271s6 0.760405s6 0.761538s6 0.762668s6 0.763796s6 0.764921s6 0.766044s6 0.767165s6 0.768283s6 0.769399s6 0.770513s6 0.771624s6 0.772733s6 0.773840s6 0.774944s6 0.776046s6 0.777145s6 0.778243s6 0.779337s6 0.780430s6 0.781520s6 0.782608s6 0.783693s6 0.784776s6 0.785856s6 0.786935s6 0.788010s6 0.789084s6 0.790155s6 0.791223s6 0.792289s6 0.793353s6 0.794414s6 0.795473s6 0.796529s6 0.797583s6 0.798635s6 0.799684s6 0.800731s6 0.801775s6 0.802817s6 0.803856s6 0.804893s6 0.805928s6 0.806960s6 0.807989s6 0.809016s6 0.810041s6 0.811063s6 0.812083s6 0.813100s6 0.814115s6 0.815127s6 0.816137s6 0.817144s6 0.818149s6 0.819152s6 0.820151s6 0.821149s6 0.822144s6 0.823136s6 0.824126s6 0.825113s6 0.826098s6 0.827080s6 0.828060s6 0.829037s6 0.830012s6 0.830984s6 0.831954s6 0.832921s6 0.833885s6 0.834847s6 0.835807s6 0.836764s6 0.837718s6 0.838670s6 0.839619s6 0.840566s6 0.841510s6 0.842452s6 0.843391s6 0.844327s6 0.845261s6 0.846193s6 0.847121s6 0.848048s6 0.848971s6 0.849892s6 0.850811s6 0.851726s6 0.852640s6 0.853550s6 0.854458s6 0.855364s6 0.856267s6 0.857167s6 0.858064s6 0.858959s6 0.859852s6 0.860742s6 0.861629s6 0.862513s6 0.863395s6 0.864274s6 0.865151s6 0.866025s6 0.866896s6 0.867765s6 0.868631s6 0.869494s6 0.870355s6 0.871213s6 0.872069s6 0.872922s6 0.873772s6 0.874619s6 0.875464s6 0.876306s6 0.877146s6 0.877982s6 0.878817s6 0.879648s6 0.880477s6 0.881303s6 0.882126s6 0.882947s6 0.883765s6 0.884580s6 0.885393s6 0.886203s6 0.887010s6 0.887815s6 0.888617s6 0.889416s6 0.890212s6 0.891006s6 0.891797s6 0.892585s6 0.893371s6 0.894154s6 0.894934s6 0.895711s6 0.896486s6 0.897258s6 0.898027s6 0.898794s6 0.899557s6 0.900318s6 0.901077s6 0.901832s6 0.902585s6 0.903335s6 0.904082s6 0.904827s6 0.905568s6 0.906307s6 0.907044s6 0.907777s6 0.908508s6 0.909236s6 0.909961s6 0.910683s6 0.911403s6 0.912120s6 0.912834s6 0.913545s6 0.914253s6 0.914959s6 0.915662s6 0.916362s6 0.917060s6 0.917754s6 0.918446s6 0.919135s6 0.919821s6 0.920504s6 0.921185s6 0.921863s6 0.922538s6 0.923210s6 0.923879s6 0.924546s6 0.925209s6 0.925870s6 0.926528s6 0.927183s6 0.927836s6 0.928485s6 0.929132s6 0.929776s6 0.930417s6 0.931055s6 0.931691s6 0.932323s6 0.932953s6 0.933580s6 0.934204s6 0.934825s6 0.935444s6 0.936059s6 0.936672s6 0.937281s6 0.937888s6 0.938493s6 0.939094s6 0.939692s6 0.940288s6 0.940880s6 0.941470s6 0.942057s6 0.942641s6 0.943222s6 0.943800s6 0.944376s6 0.944948s6 0.945518s6 0.946085s6 0.946649s6 0.947210s6 0.947768s6 0.948323s6 0.948876s6 0.949425s6 0.949972s6 0.950515s6 0.951056s6 0.951594s6 0.952129s6 0.952661s6 0.953190s6 0.953716s6 0.954240s6 0.954760s6 0.955278s6 0.955793s6 0.956304s6 0.956813s6 0.957319s6 0.957822s6 0.958322s6 0.958819s6 0.959313s6 0.959805s6 0.960293s6 0.960779s6 0.961261s6 0.961741s6 0.962217s6 0.962691s6 0.963162s6 0.963630s6 0.964095s6 0.964557s6 0.965016s6 0.965472s6 0.965925s6 0.966376s6 0.966823s6 0.967267s6 0.967709s6 0.968147s6 0.968583s6 0.969015s6 0.969445s6 0.969872s6 0.970295s6 0.970716s6 0.971134s6 0.971549s6 0.971961s6 0.972369s6 0.972775s6 0.973178s6 0.973578s6 0.973975s6 0.974370s6 0.974761s6 0.975149s6 0.975534s6 0.975916s6 0.976296s6 0.976672s6 0.977045s6 0.977415s6 0.977783s6 0.978147s6 0.978508s6 0.978867s6 0.979222s6 0.979575s6 0.979924s6 0.980271s6 0.980614s6 0.980955s6 0.981292s6 0.981627s6 0.981958s6 0.982287s6 0.982612s6 0.982935s6 0.983254s6 0.983571s6 0.983885s6 0.984195s6 0.984503s6 0.984807s6 0.985109s6 0.985407s6 0.985703s6 0.985996s6 0.986285s6 0.986572s6 0.986855s6 0.987136s6 0.987413s6 0.987688s6 0.987959s6 0.988228s6 0.988493s6 0.988756s6 0.989015s6 0.989272s6 0.989525s6 0.989776s6 0.990023s6 0.990268s6 0.990509s6 0.990747s6 0.990983s6 0.991215s6 0.991444s6 0.991671s6 0.991894s6 0.992114s6 0.992331s6 0.992546s6 0.992757s6 0.992965s6 0.993170s6 0.993372s6 0.993571s6 0.993767s6 0.993960s6 0.994150s6 0.994337s6 0.994521s6 0.994702s6 0.994880s6 0.995055s6 0.995227s6 0.995396s6 0.995561s6 0.995724s6 0.995884s6 0.996041s6 0.996194s6 0.996345s6 0.996492s6 0.996637s6 0.996778s6 0.996917s6 0.997052s6 0.997185s6 0.997314s6 0.997440s6 0.997564s6 0.997684s6 0.997801s6 0.997915s6 0.998026s6 0.998134s6 0.998239s6 0.998341s6 0.998440s6 0.998536s6 0.998629s6 0.998719s6 0.998806s6 0.998889s6 0.998970s6 0.999048s6 0.999122s6 0.999194s6 0.999262s6 0.999328s6 0.999390s6 0.999450s6 0.999506s6 0.999559s6 0.999610s6 0.999657s6 0.999701s6 0.999742s6 0.999780s6 0.999815s6 0.999847s6 0.999876s6 0.999902s6 0.999925s6 0.999945s6 0.999961s6 0.999975s6 0.999986s6 0.999993s6 0.999998s6)! !!AvTrigonometryHelper class methodsFor: 'trigonometry-support' stamp: 'Jon 1/26/2006 12:28'!loadSinTable	"AvTrigonometryHelper loadSinTable"	SinTable := #(0.000000s6 0.001745s6 0.003490s6 0.005235s6 0.006981s6 0.008726s6 0.010471s6 0.012217s6 0.013962s6 0.015707s6 0.017452s6 0.019197s6 0.020942s6 0.022687s6 0.024432s6 0.026176s6 0.027921s6 0.029666s6 0.031410s6 0.033155s6 0.034899s6 0.036643s6 0.038387s6 0.040131s6 0.041875s6 0.043619s6 0.045362s6 0.047106s6 0.048849s6 0.050592s6 0.052335s6 0.054078s6 0.055821s6 0.057564s6 0.059306s6 0.061048s6 0.062790s6 0.064532s6 0.066273s6 0.068015s6 0.069756s6 0.071497s6 0.073238s6 0.074978s6 0.076719s6 0.078459s6 0.080198s6 0.081938s6 0.083677s6 0.085416s6 0.087155s6 0.088894s6 0.090632s6 0.092370s6 0.094108s6 0.095845s6 0.097582s6 0.099319s6 0.101056s6 0.102792s6 0.104528s6 0.106264s6 0.107999s6 0.109734s6 0.111468s6 0.113203s6 0.114937s6 0.116670s6 0.118403s6 0.120136s6 0.121869s6 0.123601s6 0.125333s6 0.127064s6 0.128795s6 0.130526s6 0.132256s6 0.133986s6 0.135715s6 0.137444s6 0.139173s6 0.140901s6 0.142628s6 0.144356s6 0.146083s6 0.147809s6 0.149535s6 0.151260s6 0.152985s6 0.154710s6 0.156434s6 0.158158s6 0.159881s6 0.161603s6 0.163325s6 0.165047s6 0.166768s6 0.168489s6 0.170209s6 0.171929s6 0.173648s6 0.175366s6 0.177084s6 0.178802s6 0.180519s6 0.182235s6 0.183951s6 0.185666s6 0.187381s6 0.189095s6 0.190808s6 0.192521s6 0.194234s6 0.195946s6 0.197657s6 0.199367s6 0.201077s6 0.202787s6 0.204496s6 0.206204s6 0.207911s6 0.209618s6 0.211324s6 0.213030s6 0.214735s6 0.216439s6 0.218143s6 0.219846s6 0.221548s6 0.223250s6 0.224951s6 0.226651s6 0.228350s6 0.230049s6 0.231747s6 0.233445s6 0.235142s6 0.236838s6 0.238533s6 0.240228s6 0.241921s6 0.243615s6 0.245307s6 0.246999s6 0.248689s6 0.250380s6 0.252069s6 0.253757s6 0.255445s6 0.257132s6 0.258819s6 0.260504s6 0.262189s6 0.263873s6 0.265556s6 0.267238s6 0.268919s6 0.270600s6 0.272280s6 0.273959s6 0.275637s6 0.277314s6 0.278991s6 0.280666s6 0.282341s6 0.284015s6 0.285688s6 0.287360s6 0.289031s6 0.290702s6 0.292371s6 0.294040s6 0.295708s6 0.297374s6 0.299040s6 0.300705s6 0.302369s6 0.304033s6 0.305695s6 0.307356s6 0.309016s6 0.310676s6 0.312334s6 0.313992s6 0.315649s6 0.317304s6 0.318959s6 0.320612s6 0.322265s6 0.323917s6 0.325568s6 0.327217s6 0.328866s6 0.330514s6 0.332161s6 0.333806s6 0.335451s6 0.337095s6 0.338737s6 0.340379s6 0.342020s6 0.343659s6 0.345298s6 0.346935s6 0.348572s6 0.350207s6 0.351841s6 0.353474s6 0.355106s6 0.356737s6 0.358367s6 0.359996s6 0.361624s6 0.363251s6 0.364876s6 0.366501s6 0.368124s6 0.369746s6 0.371367s6 0.372987s6 0.374606s6 0.376224s6 0.377840s6 0.379456s6 0.381070s6 0.382683s6 0.384295s6 0.385906s6 0.387515s6 0.389123s6 0.390731s6 0.392337s6 0.393941s6 0.395545s6 0.397147s6 0.398749s6 0.400349s6 0.401947s6 0.403545s6 0.405141s6 0.406736s6 0.408330s6 0.409923s6 0.411514s6 0.413104s6 0.414693s6 0.416280s6 0.417867s6 0.419452s6 0.421035s6 0.422618s6 0.424199s6 0.425779s6 0.427357s6 0.428935s6 0.430511s6 0.432085s6 0.433659s6 0.435231s6 0.436801s6 0.438371s6 0.439939s6 0.441505s6 0.443071s6 0.444635s6 0.446197s6 0.447759s6 0.449318s6 0.450877s6 0.452434s6 0.453990s6 0.455544s6 0.457097s6 0.458649s6 0.460199s6 0.461748s6 0.463296s6 0.464842s6 0.466386s6 0.467929s6 0.469471s6 0.471011s6 0.472550s6 0.474088s6 0.475624s6 0.477158s6 0.478691s6 0.480223s6 0.481753s6 0.483282s6 0.484809s6 0.486335s6 0.487859s6 0.489382s6 0.490903s6 0.492423s6 0.493941s6 0.495458s6 0.496973s6 0.498487s6 0.499999s6 0.501510s6 0.503019s6 0.504527s6 0.506033s6 0.507538s6 0.509041s6 0.510542s6 0.512042s6 0.513541s6 0.515038s6 0.516533s6 0.518027s6 0.519519s6 0.521009s6 0.522498s6 0.523985s6 0.525471s6 0.526955s6 0.528438s6 0.529919s6 0.531398s6 0.532876s6 0.534352s6 0.535826s6 0.537299s6 0.538770s6 0.540240s6 0.541708s6 0.543174s6 0.544639s6 0.546101s6 0.547563s6 0.549022s6 0.550480s6 0.551936s6 0.553391s6 0.554844s6 0.556295s6 0.557745s6 0.559192s6 0.560638s6 0.562083s6 0.563526s6 0.564967s6 0.566406s6 0.567843s6 0.569279s6 0.570713s6 0.572145s6 0.573576s6 0.575005s6 0.576432s6 0.577857s6 0.579281s6 0.580702s6 0.582122s6 0.583541s6 0.584957s6 0.586372s6 0.587785s6 0.589196s6 0.590605s6 0.592013s6 0.593418s6 0.594822s6 0.596224s6 0.597625s6 0.599023s6 0.600420s6 0.601815s6 0.603207s6 0.604599s6 0.605988s6 0.607375s6 0.608761s6 0.610145s6 0.611527s6 0.612907s6 0.614285s6 0.615661s6 0.617035s6 0.618408s6 0.619779s6 0.621147s6 0.622514s6 0.623879s6 0.625242s6 0.626603s6 0.627963s6 0.629320s6 0.630675s6 0.632029s6 0.633380s6 0.634730s6 0.636078s6 0.637423s6 0.638767s6 0.640109s6 0.641449s6 0.642787s6 0.644123s6 0.645457s6 0.646789s6 0.648119s6 0.649448s6 0.650774s6 0.652098s6 0.653420s6 0.654740s6 0.656059s6 0.657375s6 0.658689s6 0.660001s6 0.661311s6 0.662620s6 0.663926s6 0.665230s6 0.666532s6 0.667832s6 0.669130s6 0.670426s6 0.671720s6 0.673012s6 0.674302s6 0.675590s6 0.676875s6 0.678159s6 0.679441s6 0.680720s6 0.681998s6 0.683273s6 0.684547s6 0.685818s6 0.687087s6 0.688354s6 0.689619s6 0.690882s6 0.692143s6 0.693401s6 0.694658s6 0.695912s6 0.697165s6 0.698415s6 0.699663s6 0.700909s6 0.702153s6 0.703394s6 0.704634s6 0.705871s6 0.707106s6 0.708339s6 0.709570s6 0.710799s6 0.712026s6 0.713250s6 0.714472s6 0.715692s6 0.716910s6 0.718126s6 0.719339s6 0.720551s6 0.721760s6 0.722967s6 0.724171s6 0.725374s6 0.726574s6 0.727772s6 0.728968s6 0.730162s6 0.731353s6 0.732542s6 0.733729s6 0.734914s6 0.736097s6 0.737277s6 0.738455s6 0.739631s6 0.740804s6 0.741975s6 0.743144s6 0.744311s6 0.745475s6 0.746638s6 0.747798s6 0.748955s6 0.750111s6 0.751264s6 0.752414s6 0.753563s6 0.754709s6 0.755853s6 0.756995s6 0.758134s6 0.759271s6 0.760405s6 0.761538s6 0.762668s6 0.763796s6 0.764921s6 0.766044s6 0.767165s6 0.768283s6 0.769399s6 0.770513s6 0.771624s6 0.772733s6 0.773840s6 0.774944s6 0.776046s6 0.777145s6 0.778243s6 0.779337s6 0.780430s6 0.781520s6 0.782608s6 0.783693s6 0.784776s6 0.785856s6 0.786935s6 0.788010s6 0.789084s6 0.790155s6 0.791223s6 0.792289s6 0.793353s6 0.794414s6 0.795473s6 0.796529s6 0.797583s6 0.798635s6 0.799684s6 0.800731s6 0.801775s6 0.802817s6 0.803856s6 0.804893s6 0.805928s6 0.806960s6 0.807989s6 0.809016s6 0.810041s6 0.811063s6 0.812083s6 0.813100s6 0.814115s6 0.815127s6 0.816137s6 0.817144s6 0.818149s6 0.819152s6 0.820151s6 0.821149s6 0.822144s6 0.823136s6 0.824126s6 0.825113s6 0.826098s6 0.827080s6 0.828060s6 0.829037s6 0.830012s6 0.830984s6 0.831954s6 0.832921s6 0.833885s6 0.834847s6 0.835807s6 0.836764s6 0.837718s6 0.838670s6 0.839619s6 0.840566s6 0.841510s6 0.842452s6 0.843391s6 0.844327s6 0.845261s6 0.846193s6 0.847121s6 0.848048s6 0.848971s6 0.849892s6 0.850811s6 0.851726s6 0.852640s6 0.853550s6 0.854458s6 0.855364s6 0.856267s6 0.857167s6 0.858064s6 0.858959s6 0.859852s6 0.860742s6 0.861629s6 0.862513s6 0.863395s6 0.864274s6 0.865151s6 0.866025s6 0.866896s6 0.867765s6 0.868631s6 0.869494s6 0.870355s6 0.871213s6 0.872069s6 0.872922s6 0.873772s6 0.874619s6 0.875464s6 0.876306s6 0.877146s6 0.877982s6 0.878817s6 0.879648s6 0.880477s6 0.881303s6 0.882126s6 0.882947s6 0.883765s6 0.884580s6 0.885393s6 0.886203s6 0.887010s6 0.887815s6 0.888617s6 0.889416s6 0.890212s6 0.891006s6 0.891797s6 0.892585s6 0.893371s6 0.894154s6 0.894934s6 0.895711s6 0.896486s6 0.897258s6 0.898027s6 0.898794s6 0.899557s6 0.900318s6 0.901077s6 0.901832s6 0.902585s6 0.903335s6 0.904082s6 0.904827s6 0.905568s6 0.906307s6 0.907044s6 0.907777s6 0.908508s6 0.909236s6 0.909961s6 0.910683s6 0.911403s6 0.912120s6 0.912834s6 0.913545s6 0.914253s6 0.914959s6 0.915662s6 0.916362s6 0.917060s6 0.917754s6 0.918446s6 0.919135s6 0.919821s6 0.920504s6 0.921185s6 0.921863s6 0.922538s6 0.923210s6 0.923879s6 0.924546s6 0.925209s6 0.925870s6 0.926528s6 0.927183s6 0.927836s6 0.928485s6 0.929132s6 0.929776s6 0.930417s6 0.931055s6 0.931691s6 0.932323s6 0.932953s6 0.933580s6 0.934204s6 0.934825s6 0.935444s6 0.936059s6 0.936672s6 0.937281s6 0.937888s6 0.938493s6 0.939094s6 0.939692s6 0.940288s6 0.940880s6 0.941470s6 0.942057s6 0.942641s6 0.943222s6 0.943800s6 0.944376s6 0.944948s6 0.945518s6 0.946085s6 0.946649s6 0.947210s6 0.947768s6 0.948323s6 0.948876s6 0.949425s6 0.949972s6 0.950515s6 0.951056s6 0.951594s6 0.952129s6 0.952661s6 0.953190s6 0.953716s6 0.954240s6 0.954760s6 0.955278s6 0.955793s6 0.956304s6 0.956813s6 0.957319s6 0.957822s6 0.958322s6 0.958819s6 0.959313s6 0.959805s6 0.960293s6 0.960779s6 0.961261s6 0.961741s6 0.962217s6 0.962691s6 0.963162s6 0.963630s6 0.964095s6 0.964557s6 0.965016s6 0.965472s6 0.965925s6 0.966376s6 0.966823s6 0.967267s6 0.967709s6 0.968147s6 0.968583s6 0.969015s6 0.969445s6 0.969872s6 0.970295s6 0.970716s6 0.971134s6 0.971549s6 0.971961s6 0.972369s6 0.972775s6 0.973178s6 0.973578s6 0.973975s6 0.974370s6 0.974761s6 0.975149s6 0.975534s6 0.975916s6 0.976296s6 0.976672s6 0.977045s6 0.977415s6 0.977783s6 0.978147s6 0.978508s6 0.978867s6 0.979222s6 0.979575s6 0.979924s6 0.980271s6 0.980614s6 0.980955s6 0.981292s6 0.981627s6 0.981958s6 0.982287s6 0.982612s6 0.982935s6 0.983254s6 0.983571s6 0.983885s6 0.984195s6 0.984503s6 0.984807s6 0.985109s6 0.985407s6 0.985703s6 0.985996s6 0.986285s6 0.986572s6 0.986855s6 0.987136s6 0.987413s6 0.987688s6 0.987959s6 0.988228s6 0.988493s6 0.988756s6 0.989015s6 0.989272s6 0.989525s6 0.989776s6 0.990023s6 0.990268s6 0.990509s6 0.990747s6 0.990983s6 0.991215s6 0.991444s6 0.991671s6 0.991894s6 0.992114s6 0.992331s6 0.992546s6 0.992757s6 0.992965s6 0.993170s6 0.993372s6 0.993571s6 0.993767s6 0.993960s6 0.994150s6 0.994337s6 0.994521s6 0.994702s6 0.994880s6 0.995055s6 0.995227s6 0.995396s6 0.995561s6 0.995724s6 0.995884s6 0.996041s6 0.996194s6 0.996345s6 0.996492s6 0.996637s6 0.996778s6 0.996917s6 0.997052s6 0.997185s6 0.997314s6 0.997440s6 0.997564s6 0.997684s6 0.997801s6 0.997915s6 0.998026s6 0.998134s6 0.998239s6 0.998341s6 0.998440s6 0.998536s6 0.998629s6 0.998719s6 0.998806s6 0.998889s6 0.998970s6 0.999048s6 0.999122s6 0.999194s6 0.999262s6 0.999328s6 0.999390s6 0.999450s6 0.999506s6 0.999559s6 0.999610s6 0.999657s6 0.999701s6 0.999742s6 0.999780s6 0.999815s6 0.999847s6 0.999876s6 0.999902s6 0.999925s6 0.999945s6 0.999961s6 0.999975s6 0.999986s6 0.999993s6 0.999998s6 1.000000s6 0.999998s6 0.999993s6 0.999986s6 0.999975s6 0.999961s6 0.999945s6 0.999925s6 0.999902s6 0.999876s6 0.999847s6 0.999815s6 0.999780s6 0.999742s6 0.999701s6 0.999657s6 0.999610s6 0.999559s6 0.999506s6 0.999450s6 0.999390s6 0.999328s6 0.999262s6 0.999194s6 0.999122s6 0.999048s6 0.998970s6 0.998889s6 0.998806s6 0.998719s6 0.998629s6 0.998536s6 0.998440s6 0.998341s6 0.998239s6 0.998134s6 0.998026s6 0.997915s6 0.997801s6 0.997684s6 0.997564s6 0.997440s6 0.997314s6 0.997185s6 0.997052s6 0.996917s6 0.996778s6 0.996637s6 0.996492s6 0.996345s6 0.996194s6 0.996041s6 0.995884s6 0.995724s6 0.995561s6 0.995396s6 0.995227s6 0.995055s6 0.994880s6 0.994702s6 0.994521s6 0.994337s6 0.994150s6 0.993960s6 0.993767s6 0.993571s6 0.993372s6 0.993170s6 0.992965s6 0.992757s6 0.992546s6 0.992331s6 0.992114s6 0.991894s6 0.991671s6 0.991444s6 0.991215s6 0.990983s6 0.990747s6 0.990509s6 0.990268s6 0.990023s6 0.989776s6 0.989525s6 0.989272s6 0.989015s6 0.988756s6 0.988493s6 0.988228s6 0.987959s6 0.987688s6 0.987413s6 0.987136s6 0.986855s6 0.986572s6 0.986285s6 0.985996s6 0.985703s6 0.985407s6 0.985109s6 0.984807s6 0.984503s6 0.984195s6 0.983885s6 0.983571s6 0.983254s6 0.982935s6 0.982612s6 0.982287s6 0.981958s6 0.981627s6 0.981292s6 0.980955s6 0.980614s6 0.980271s6 0.979924s6 0.979575s6 0.979222s6 0.978867s6 0.978508s6 0.978147s6 0.977783s6 0.977415s6 0.977045s6 0.976672s6 0.976296s6 0.975916s6 0.975534s6 0.975149s6 0.974761s6 0.974370s6 0.973975s6 0.973578s6 0.973178s6 0.972775s6 0.972369s6 0.971961s6 0.971549s6 0.971134s6 0.970716s6 0.970295s6 0.969872s6 0.969445s6 0.969015s6 0.968583s6 0.968147s6 0.967709s6 0.967267s6 0.966823s6 0.966376s6 0.965925s6 0.965472s6 0.965016s6 0.964557s6 0.964095s6 0.963630s6 0.963162s6 0.962691s6 0.962217s6 0.961741s6 0.961261s6 0.960779s6 0.960293s6 0.959805s6 0.959313s6 0.958819s6 0.958322s6 0.957822s6 0.957319s6 0.956813s6 0.956304s6 0.955793s6 0.955278s6 0.954760s6 0.954240s6 0.953716s6 0.953190s6 0.952661s6 0.952129s6 0.951594s6 0.951056s6 0.950515s6 0.949972s6 0.949425s6 0.948876s6 0.948323s6 0.947768s6 0.947210s6 0.946649s6 0.946085s6 0.945518s6 0.944948s6 0.944376s6 0.943800s6 0.943222s6 0.942641s6 0.942057s6 0.941470s6 0.940880s6 0.940288s6 0.939692s6 0.939094s6 0.938493s6 0.937888s6 0.937281s6 0.936672s6 0.936059s6 0.935444s6 0.934825s6 0.934204s6 0.933580s6 0.932953s6 0.932323s6 0.931691s6 0.931055s6 0.930417s6 0.929776s6 0.929132s6 0.928485s6 0.927836s6 0.927183s6 0.926528s6 0.925870s6 0.925209s6 0.924546s6 0.923879s6 0.923210s6 0.922538s6 0.921863s6 0.921185s6 0.920504s6 0.919821s6 0.919135s6 0.918446s6 0.917754s6 0.917060s6 0.916362s6 0.915662s6 0.914959s6 0.914253s6 0.913545s6 0.912834s6 0.912120s6 0.911403s6 0.910683s6 0.909961s6 0.909236s6 0.908508s6 0.907777s6 0.907044s6 0.906307s6 0.905568s6 0.904827s6 0.904082s6 0.903335s6 0.902585s6 0.901832s6 0.901077s6 0.900318s6 0.899557s6 0.898794s6 0.898027s6 0.897258s6 0.896486s6 0.895711s6 0.894934s6 0.894154s6 0.893371s6 0.892585s6 0.891797s6 0.891006s6 0.890212s6 0.889416s6 0.888617s6 0.887815s6 0.887010s6 0.886203s6 0.885393s6 0.884580s6 0.883765s6 0.882947s6 0.882126s6 0.881303s6 0.880477s6 0.879648s6 0.878817s6 0.877982s6 0.877146s6 0.876306s6 0.875464s6 0.874619s6 0.873772s6 0.872922s6 0.872069s6 0.871213s6 0.870355s6 0.869494s6 0.868631s6 0.867765s6 0.866896s6 0.866025s6 0.865151s6 0.864274s6 0.863395s6 0.862513s6 0.861629s6 0.860742s6 0.859852s6 0.858959s6 0.858064s6 0.857167s6 0.856267s6 0.855364s6 0.854458s6 0.853550s6 0.852640s6 0.851726s6 0.850811s6 0.849892s6 0.848971s6 0.848048s6 0.847121s6 0.846193s6 0.845261s6 0.844327s6 0.843391s6 0.842452s6 0.841510s6 0.840566s6 0.839619s6 0.838670s6 0.837718s6 0.836764s6 0.835807s6 0.834847s6 0.833885s6 0.832921s6 0.831954s6 0.830984s6 0.830012s6 0.829037s6 0.828060s6 0.827080s6 0.826098s6 0.825113s6 0.824126s6 0.823136s6 0.822144s6 0.821149s6 0.820151s6 0.819152s6 0.818149s6 0.817144s6 0.816137s6 0.815127s6 0.814115s6 0.813100s6 0.812083s6 0.811063s6 0.810041s6 0.809016s6 0.807989s6 0.806960s6 0.805928s6 0.804893s6 0.803856s6 0.802817s6 0.801775s6 0.800731s6 0.799684s6 0.798635s6 0.797583s6 0.796529s6 0.795473s6 0.794414s6 0.793353s6 0.792289s6 0.791223s6 0.790155s6 0.789084s6 0.788010s6 0.786935s6 0.785856s6 0.784776s6 0.783693s6 0.782608s6 0.781520s6 0.780430s6 0.779337s6 0.778243s6 0.777145s6 0.776046s6 0.774944s6 0.773840s6 0.772733s6 0.771624s6 0.770513s6 0.769399s6 0.768283s6 0.767165s6 0.766044s6 0.764921s6 0.763796s6 0.762668s6 0.761538s6 0.760405s6 0.759271s6 0.758134s6 0.756995s6 0.755853s6 0.754709s6 0.753563s6 0.752414s6 0.751264s6 0.750111s6 0.748955s6 0.747798s6 0.746638s6 0.745475s6 0.744311s6 0.743144s6 0.741975s6 0.740804s6 0.739631s6 0.738455s6 0.737277s6 0.736097s6 0.734914s6 0.733729s6 0.732542s6 0.731353s6 0.730162s6 0.728968s6 0.727772s6 0.726574s6 0.725374s6 0.724171s6 0.722967s6 0.721760s6 0.720551s6 0.719339s6 0.718126s6 0.716910s6 0.715692s6 0.714472s6 0.713250s6 0.712026s6 0.710799s6 0.709570s6 0.708339s6 0.707106s6 0.705871s6 0.704634s6 0.703394s6 0.702153s6 0.700909s6 0.699663s6 0.698415s6 0.697165s6 0.695912s6 0.694658s6 0.693401s6 0.692143s6 0.690882s6 0.689619s6 0.688354s6 0.687087s6 0.685818s6 0.684547s6 0.683273s6 0.681998s6 0.680720s6 0.679441s6 0.678159s6 0.676875s6 0.675590s6 0.674302s6 0.673012s6 0.671720s6 0.670426s6 0.669130s6 0.667832s6 0.666532s6 0.665230s6 0.663926s6 0.662620s6 0.661311s6 0.660001s6 0.658689s6 0.657375s6 0.656059s6 0.654740s6 0.653420s6 0.652098s6 0.650774s6 0.649448s6 0.648119s6 0.646789s6 0.645457s6 0.644123s6 0.642787s6 0.641449s6 0.640109s6 0.638767s6 0.637423s6 0.636078s6 0.634730s6 0.633380s6 0.632029s6 0.630675s6 0.629320s6 0.627963s6 0.626603s6 0.625242s6 0.623879s6 0.622514s6 0.621147s6 0.619779s6 0.618408s6 0.617035s6 0.615661s6 0.614285s6 0.612907s6 0.611527s6 0.610145s6 0.608761s6 0.607375s6 0.605988s6 0.604599s6 0.603207s6 0.601815s6 0.600420s6 0.599023s6 0.597625s6 0.596224s6 0.594822s6 0.593418s6 0.592013s6 0.590605s6 0.589196s6 0.587785s6 0.586372s6 0.584957s6 0.583541s6 0.582122s6 0.580702s6 0.579281s6 0.577857s6 0.576432s6 0.575005s6 0.573576s6 0.572145s6 0.570713s6 0.569279s6 0.567843s6 0.566406s6 0.564967s6 0.563526s6 0.562083s6 0.560638s6 0.559192s6 0.557745s6 0.556295s6 0.554844s6 0.553391s6 0.551936s6 0.550480s6 0.549022s6 0.547563s6 0.546101s6 0.544639s6 0.543174s6 0.541708s6 0.540240s6 0.538770s6 0.537299s6 0.535826s6 0.534352s6 0.532876s6 0.531398s6 0.529919s6 0.528438s6 0.526955s6 0.525471s6 0.523985s6 0.522498s6 0.521009s6 0.519519s6 0.518027s6 0.516533s6 0.515038s6 0.513541s6 0.512042s6 0.510542s6 0.509041s6 0.507538s6 0.506033s6 0.504527s6 0.503019s6 0.501510s6 0.499999s6 0.498487s6 0.496973s6 0.495458s6 0.493941s6 0.492423s6 0.490903s6 0.489382s6 0.487859s6 0.486335s6 0.484809s6 0.483282s6 0.481753s6 0.480223s6 0.478691s6 0.477158s6 0.475624s6 0.474088s6 0.472550s6 0.471011s6 0.469471s6 0.467929s6 0.466386s6 0.464842s6 0.463296s6 0.461748s6 0.460199s6 0.458649s6 0.457097s6 0.455544s6 0.453990s6 0.452434s6 0.450877s6 0.449318s6 0.447759s6 0.446197s6 0.444635s6 0.443071s6 0.441505s6 0.439939s6 0.438371s6 0.436801s6 0.435231s6 0.433659s6 0.432085s6 0.430511s6 0.428935s6 0.427357s6 0.425779s6 0.424199s6 0.422618s6 0.421035s6 0.419452s6 0.417867s6 0.416280s6 0.414693s6 0.413104s6 0.411514s6 0.409923s6 0.408330s6 0.406736s6 0.405141s6 0.403545s6 0.401947s6 0.400349s6 0.398749s6 0.397147s6 0.395545s6 0.393941s6 0.392337s6 0.390731s6 0.389123s6 0.387515s6 0.385906s6 0.384295s6 0.382683s6 0.381070s6 0.379456s6 0.377840s6 0.376224s6 0.374606s6 0.372987s6 0.371367s6 0.369746s6 0.368124s6 0.366501s6 0.364876s6 0.363251s6 0.361624s6 0.359996s6 0.358367s6 0.356737s6 0.355106s6 0.353474s6 0.351841s6 0.350207s6 0.348572s6 0.346935s6 0.345298s6 0.343659s6 0.342020s6 0.340379s6 0.338737s6 0.337095s6 0.335451s6 0.333806s6 0.332161s6 0.330514s6 0.328866s6 0.327217s6 0.325568s6 0.323917s6 0.322265s6 0.320612s6 0.318959s6 0.317304s6 0.315649s6 0.313992s6 0.312334s6 0.310676s6 0.309016s6 0.307356s6 0.305695s6 0.304033s6 0.302369s6 0.300705s6 0.299040s6 0.297374s6 0.295708s6 0.294040s6 0.292371s6 0.290702s6 0.289031s6 0.287360s6 0.285688s6 0.284015s6 0.282341s6 0.280666s6 0.278991s6 0.277314s6 0.275637s6 0.273959s6 0.272280s6 0.270600s6 0.268919s6 0.267238s6 0.265556s6 0.263873s6 0.262189s6 0.260504s6 0.258819s6 0.257132s6 0.255445s6 0.253757s6 0.252069s6 0.250380s6 0.248689s6 0.246999s6 0.245307s6 0.243615s6 0.241921s6 0.240228s6 0.238533s6 0.236838s6 0.235142s6 0.233445s6 0.231747s6 0.230049s6 0.228350s6 0.226651s6 0.224951s6 0.223250s6 0.221548s6 0.219846s6 0.218143s6 0.216439s6 0.214735s6 0.213030s6 0.211324s6 0.209618s6 0.207911s6 0.206204s6 0.204496s6 0.202787s6 0.201077s6 0.199367s6 0.197657s6 0.195946s6 0.194234s6 0.192521s6 0.190808s6 0.189095s6 0.187381s6 0.185666s6 0.183951s6 0.182235s6 0.180519s6 0.178802s6 0.177084s6 0.175366s6 0.173648s6 0.171929s6 0.170209s6 0.168489s6 0.166768s6 0.165047s6 0.163325s6 0.161603s6 0.159881s6 0.158158s6 0.156434s6 0.154710s6 0.152985s6 0.151260s6 0.149535s6 0.147809s6 0.146083s6 0.144356s6 0.142628s6 0.140901s6 0.139173s6 0.137444s6 0.135715s6 0.133986s6 0.132256s6 0.130526s6 0.128795s6 0.127064s6 0.125333s6 0.123601s6 0.121869s6 0.120136s6 0.118403s6 0.116670s6 0.114937s6 0.113203s6 0.111468s6 0.109734s6 0.107999s6 0.106264s6 0.104528s6 0.102792s6 0.101056s6 0.099319s6 0.097582s6 0.095845s6 0.094108s6 0.092370s6 0.090632s6 0.088894s6 0.087155s6 0.085416s6 0.083677s6 0.081938s6 0.080198s6 0.078459s6 0.076719s6 0.074978s6 0.073238s6 0.071497s6 0.069756s6 0.068015s6 0.066273s6 0.064532s6 0.062790s6 0.061048s6 0.059306s6 0.057564s6 0.055821s6 0.054078s6 0.052335s6 0.050592s6 0.048849s6 0.047106s6 0.045362s6 0.043619s6 0.041875s6 0.040131s6 0.038387s6 0.036643s6 0.034899s6 0.033155s6 0.031410s6 0.029666s6 0.027921s6 0.026176s6 0.024432s6 0.022687s6 0.020942s6 0.019197s6 0.017452s6 0.015707s6 0.013962s6 0.012217s6 0.010471s6 0.008726s6 0.006981s6 0.005235s6 0.003490s6 0.001745s6 0.000000s6 -0.001745s6 -0.003490s6 -0.005235s6 -0.006981s6 -0.008726s6 -0.010471s6 -0.012217s6 -0.013962s6 -0.015707s6 -0.017452s6 -0.019197s6 -0.020942s6 -0.022687s6 -0.024432s6 -0.026176s6 -0.027921s6 -0.029666s6 -0.031410s6 -0.033155s6 -0.034899s6 -0.036643s6 -0.038387s6 -0.040131s6 -0.041875s6 -0.043619s6 -0.045362s6 -0.047106s6 -0.048849s6 -0.050592s6 -0.052335s6 -0.054078s6 -0.055821s6 -0.057564s6 -0.059306s6 -0.061048s6 -0.062790s6 -0.064532s6 -0.066273s6 -0.068015s6 -0.069756s6 -0.071497s6 -0.073238s6 -0.074978s6 -0.076719s6 -0.078459s6 -0.080198s6 -0.081938s6 -0.083677s6 -0.085416s6 -0.087155s6 -0.088894s6 -0.090632s6 -0.092370s6 -0.094108s6 -0.095845s6 -0.097582s6 -0.099319s6 -0.101056s6 -0.102792s6 -0.104528s6 -0.106264s6 -0.107999s6 -0.109734s6 -0.111468s6 -0.113203s6 -0.114937s6 -0.116670s6 -0.118403s6 -0.120136s6 -0.121869s6 -0.123601s6 -0.125333s6 -0.127064s6 -0.128795s6 -0.130526s6 -0.132256s6 -0.133986s6 -0.135715s6 -0.137444s6 -0.139173s6 -0.140901s6 -0.142628s6 -0.144356s6 -0.146083s6 -0.147809s6 -0.149535s6 -0.151260s6 -0.152985s6 -0.154710s6 -0.156434s6 -0.158158s6 -0.159881s6 -0.161603s6 -0.163325s6 -0.165047s6 -0.166768s6 -0.168489s6 -0.170209s6 -0.171929s6 -0.173648s6 -0.175366s6 -0.177084s6 -0.178802s6 -0.180519s6 -0.182235s6 -0.183951s6 -0.185666s6 -0.187381s6 -0.189095s6 -0.190808s6 -0.192521s6 -0.194234s6 -0.195946s6 -0.197657s6 -0.199367s6 -0.201077s6 -0.202787s6 -0.204496s6 -0.206204s6 -0.207911s6 -0.209618s6 -0.211324s6 -0.213030s6 -0.214735s6 -0.216439s6 -0.218143s6 -0.219846s6 -0.221548s6 -0.223250s6 -0.224951s6 -0.226651s6 -0.228350s6 -0.230049s6 -0.231747s6 -0.233445s6 -0.235142s6 -0.236838s6 -0.238533s6 -0.240228s6 -0.241921s6 -0.243615s6 -0.245307s6 -0.246999s6 -0.248689s6 -0.250380s6 -0.252069s6 -0.253757s6 -0.255445s6 -0.257132s6 -0.258819s6 -0.260504s6 -0.262189s6 -0.263873s6 -0.265556s6 -0.267238s6 -0.268919s6 -0.270600s6 -0.272280s6 -0.273959s6 -0.275637s6 -0.277314s6 -0.278991s6 -0.280666s6 -0.282341s6 -0.284015s6 -0.285688s6 -0.287360s6 -0.289031s6 -0.290702s6 -0.292371s6 -0.294040s6 -0.295708s6 -0.297374s6 -0.299040s6 -0.300705s6 -0.302369s6 -0.304033s6 -0.305695s6 -0.307356s6 -0.309016s6 -0.310676s6 -0.312334s6 -0.313992s6 -0.315649s6 -0.317304s6 -0.318959s6 -0.320612s6 -0.322265s6 -0.323917s6 -0.325568s6 -0.327217s6 -0.328866s6 -0.330514s6 -0.332161s6 -0.333806s6 -0.335451s6 -0.337095s6 -0.338737s6 -0.340379s6 -0.342020s6 -0.343659s6 -0.345298s6 -0.346935s6 -0.348572s6 -0.350207s6 -0.351841s6 -0.353474s6 -0.355106s6 -0.356737s6 -0.358367s6 -0.359996s6 -0.361624s6 -0.363251s6 -0.364876s6 -0.366501s6 -0.368124s6 -0.369746s6 -0.371367s6 -0.372987s6 -0.374606s6 -0.376224s6 -0.377840s6 -0.379456s6 -0.381070s6 -0.382683s6 -0.384295s6 -0.385906s6 -0.387515s6 -0.389123s6 -0.390731s6 -0.392337s6 -0.393941s6 -0.395545s6 -0.397147s6 -0.398749s6 -0.400349s6 -0.401947s6 -0.403545s6 -0.405141s6 -0.406736s6 -0.408330s6 -0.409923s6 -0.411514s6 -0.413104s6 -0.414693s6 -0.416280s6 -0.417867s6 -0.419452s6 -0.421035s6 -0.422618s6 -0.424199s6 -0.425779s6 -0.427357s6 -0.428935s6 -0.430511s6 -0.432085s6 -0.433659s6 -0.435231s6 -0.436801s6 -0.438371s6 -0.439939s6 -0.441505s6 -0.443071s6 -0.444635s6 -0.446197s6 -0.447759s6 -0.449318s6 -0.450877s6 -0.452434s6 -0.453990s6 -0.455544s6 -0.457097s6 -0.458649s6 -0.460199s6 -0.461748s6 -0.463296s6 -0.464842s6 -0.466386s6 -0.467929s6 -0.469471s6 -0.471011s6 -0.472550s6 -0.474088s6 -0.475624s6 -0.477158s6 -0.478691s6 -0.480223s6 -0.481753s6 -0.483282s6 -0.484809s6 -0.486335s6 -0.487859s6 -0.489382s6 -0.490903s6 -0.492423s6 -0.493941s6 -0.495458s6 -0.496973s6 -0.498487s6 -0.500000s6 -0.501510s6 -0.503019s6 -0.504527s6 -0.506033s6 -0.507538s6 -0.509041s6 -0.510542s6 -0.512042s6 -0.513541s6 -0.515038s6 -0.516533s6 -0.518027s6 -0.519519s6 -0.521009s6 -0.522498s6 -0.523985s6 -0.525471s6 -0.526955s6 -0.528438s6 -0.529919s6 -0.531398s6 -0.532876s6 -0.534352s6 -0.535826s6 -0.537299s6 -0.538770s6 -0.540240s6 -0.541708s6 -0.543174s6 -0.544639s6 -0.546101s6 -0.547563s6 -0.549022s6 -0.550480s6 -0.551936s6 -0.553391s6 -0.554844s6 -0.556295s6 -0.557745s6 -0.559192s6 -0.560638s6 -0.562083s6 -0.563526s6 -0.564967s6 -0.566406s6 -0.567843s6 -0.569279s6 -0.570713s6 -0.572145s6 -0.573576s6 -0.575005s6 -0.576432s6 -0.577857s6 -0.579281s6 -0.580702s6 -0.582122s6 -0.583541s6 -0.584957s6 -0.586372s6 -0.587785s6 -0.589196s6 -0.590605s6 -0.592013s6 -0.593418s6 -0.594822s6 -0.596224s6 -0.597625s6 -0.599023s6 -0.600420s6 -0.601815s6 -0.603207s6 -0.604599s6 -0.605988s6 -0.607375s6 -0.608761s6 -0.610145s6 -0.611527s6 -0.612907s6 -0.614285s6 -0.615661s6 -0.617035s6 -0.618408s6 -0.619779s6 -0.621147s6 -0.622514s6 -0.623879s6 -0.625242s6 -0.626603s6 -0.627963s6 -0.629320s6 -0.630675s6 -0.632029s6 -0.633380s6 -0.634730s6 -0.636078s6 -0.637423s6 -0.638767s6 -0.640109s6 -0.641449s6 -0.642787s6 -0.644123s6 -0.645457s6 -0.646789s6 -0.648119s6 -0.649448s6 -0.650774s6 -0.652098s6 -0.653420s6 -0.654740s6 -0.656059s6 -0.657375s6 -0.658689s6 -0.660001s6 -0.661311s6 -0.662620s6 -0.663926s6 -0.665230s6 -0.666532s6 -0.667832s6 -0.669130s6 -0.670426s6 -0.671720s6 -0.673012s6 -0.674302s6 -0.675590s6 -0.676875s6 -0.678159s6 -0.679441s6 -0.680720s6 -0.681998s6 -0.683273s6 -0.684547s6 -0.685818s6 -0.687087s6 -0.688354s6 -0.689619s6 -0.690882s6 -0.692143s6 -0.693401s6 -0.694658s6 -0.695912s6 -0.697165s6 -0.698415s6 -0.699663s6 -0.700909s6 -0.702153s6 -0.703394s6 -0.704634s6 -0.705871s6 -0.707106s6 -0.708339s6 -0.709570s6 -0.710799s6 -0.712026s6 -0.713250s6 -0.714472s6 -0.715692s6 -0.716910s6 -0.718126s6 -0.719339s6 -0.720551s6 -0.721760s6 -0.722967s6 -0.724171s6 -0.725374s6 -0.726574s6 -0.727772s6 -0.728968s6 -0.730162s6 -0.731353s6 -0.732542s6 -0.733729s6 -0.734914s6 -0.736097s6 -0.737277s6 -0.738455s6 -0.739631s6 -0.740804s6 -0.741975s6 -0.743144s6 -0.744311s6 -0.745475s6 -0.746638s6 -0.747798s6 -0.748955s6 -0.750111s6 -0.751264s6 -0.752414s6 -0.753563s6 -0.754709s6 -0.755853s6 -0.756995s6 -0.758134s6 -0.759271s6 -0.760405s6 -0.761538s6 -0.762668s6 -0.763796s6 -0.764921s6 -0.766044s6 -0.767165s6 -0.768283s6 -0.769399s6 -0.770513s6 -0.771624s6 -0.772733s6 -0.773840s6 -0.774944s6 -0.776046s6 -0.777145s6 -0.778243s6 -0.779337s6 -0.780430s6 -0.781520s6 -0.782608s6 -0.783693s6 -0.784776s6 -0.785856s6 -0.786935s6 -0.788010s6 -0.789084s6 -0.790155s6 -0.791223s6 -0.792289s6 -0.793353s6 -0.794414s6 -0.795473s6 -0.796529s6 -0.797583s6 -0.798635s6 -0.799684s6 -0.800731s6 -0.801775s6 -0.802817s6 -0.803856s6 -0.804893s6 -0.805928s6 -0.806960s6 -0.807989s6 -0.809016s6 -0.810041s6 -0.811063s6 -0.812083s6 -0.813100s6 -0.814115s6 -0.815127s6 -0.816137s6 -0.817144s6 -0.818149s6 -0.819152s6 -0.820151s6 -0.821149s6 -0.822144s6 -0.823136s6 -0.824126s6 -0.825113s6 -0.826098s6 -0.827080s6 -0.828060s6 -0.829037s6 -0.830012s6 -0.830984s6 -0.831954s6 -0.832921s6 -0.833885s6 -0.834847s6 -0.835807s6 -0.836764s6 -0.837718s6 -0.838670s6 -0.839619s6 -0.840566s6 -0.841510s6 -0.842452s6 -0.843391s6 -0.844327s6 -0.845261s6 -0.846193s6 -0.847121s6 -0.848048s6 -0.848971s6 -0.849892s6 -0.850811s6 -0.851726s6 -0.852640s6 -0.853550s6 -0.854458s6 -0.855364s6 -0.856267s6 -0.857167s6 -0.858064s6 -0.858959s6 -0.859852s6 -0.860742s6 -0.861629s6 -0.862513s6 -0.863395s6 -0.864274s6 -0.865151s6 -0.866025s6 -0.866896s6 -0.867765s6 -0.868631s6 -0.869494s6 -0.870355s6 -0.871213s6 -0.872069s6 -0.872922s6 -0.873772s6 -0.874619s6 -0.875464s6 -0.876306s6 -0.877146s6 -0.877982s6 -0.878817s6 -0.879648s6 -0.880477s6 -0.881303s6 -0.882126s6 -0.882947s6 -0.883765s6 -0.884580s6 -0.885393s6 -0.886203s6 -0.887010s6 -0.887815s6 -0.888617s6 -0.889416s6 -0.890212s6 -0.891006s6 -0.891797s6 -0.892585s6 -0.893371s6 -0.894154s6 -0.894934s6 -0.895711s6 -0.896486s6 -0.897258s6 -0.898027s6 -0.898794s6 -0.899557s6 -0.900318s6 -0.901077s6 -0.901832s6 -0.902585s6 -0.903335s6 -0.904082s6 -0.904827s6 -0.905568s6 -0.906307s6 -0.907044s6 -0.907777s6 -0.908508s6 -0.909236s6 -0.909961s6 -0.910683s6 -0.911403s6 -0.912120s6 -0.912834s6 -0.913545s6 -0.914253s6 -0.914959s6 -0.915662s6 -0.916362s6 -0.917060s6 -0.917754s6 -0.918446s6 -0.919135s6 -0.919821s6 -0.920504s6 -0.921185s6 -0.921863s6 -0.922538s6 -0.923210s6 -0.923879s6 -0.924546s6 -0.925209s6 -0.925870s6 -0.926528s6 -0.927183s6 -0.927836s6 -0.928485s6 -0.929132s6 -0.929776s6 -0.930417s6 -0.931055s6 -0.931691s6 -0.932323s6 -0.932953s6 -0.933580s6 -0.934204s6 -0.934825s6 -0.935444s6 -0.936059s6 -0.936672s6 -0.937281s6 -0.937888s6 -0.938493s6 -0.939094s6 -0.939692s6 -0.940288s6 -0.940880s6 -0.941470s6 -0.942057s6 -0.942641s6 -0.943222s6 -0.943800s6 -0.944376s6 -0.944948s6 -0.945518s6 -0.946085s6 -0.946649s6 -0.947210s6 -0.947768s6 -0.948323s6 -0.948876s6 -0.949425s6 -0.949972s6 -0.950515s6 -0.951056s6 -0.951594s6 -0.952129s6 -0.952661s6 -0.953190s6 -0.953716s6 -0.954240s6 -0.954760s6 -0.955278s6 -0.955793s6 -0.956304s6 -0.956813s6 -0.957319s6 -0.957822s6 -0.958322s6 -0.958819s6 -0.959313s6 -0.959805s6 -0.960293s6 -0.960779s6 -0.961261s6 -0.961741s6 -0.962217s6 -0.962691s6 -0.963162s6 -0.963630s6 -0.964095s6 -0.964557s6 -0.965016s6 -0.965472s6 -0.965925s6 -0.966376s6 -0.966823s6 -0.967267s6 -0.967709s6 -0.968147s6 -0.968583s6 -0.969015s6 -0.969445s6 -0.969872s6 -0.970295s6 -0.970716s6 -0.971134s6 -0.971549s6 -0.971961s6 -0.972369s6 -0.972775s6 -0.973178s6 -0.973578s6 -0.973975s6 -0.974370s6 -0.974761s6 -0.975149s6 -0.975534s6 -0.975916s6 -0.976296s6 -0.976672s6 -0.977045s6 -0.977415s6 -0.977783s6 -0.978147s6 -0.978508s6 -0.978867s6 -0.979222s6 -0.979575s6 -0.979924s6 -0.980271s6 -0.980614s6 -0.980955s6 -0.981292s6 -0.981627s6 -0.981958s6 -0.982287s6 -0.982612s6 -0.982935s6 -0.983254s6 -0.983571s6 -0.983885s6 -0.984195s6 -0.984503s6 -0.984807s6 -0.985109s6 -0.985407s6 -0.985703s6 -0.985996s6 -0.986285s6 -0.986572s6 -0.986855s6 -0.987136s6 -0.987413s6 -0.987688s6 -0.987959s6 -0.988228s6 -0.988493s6 -0.988756s6 -0.989015s6 -0.989272s6 -0.989525s6 -0.989776s6 -0.990023s6 -0.990268s6 -0.990509s6 -0.990747s6 -0.990983s6 -0.991215s6 -0.991444s6 -0.991671s6 -0.991894s6 -0.992114s6 -0.992331s6 -0.992546s6 -0.992757s6 -0.992965s6 -0.993170s6 -0.993372s6 -0.993571s6 -0.993767s6 -0.993960s6 -0.994150s6 -0.994337s6 -0.994521s6 -0.994702s6 -0.994880s6 -0.995055s6 -0.995227s6 -0.995396s6 -0.995561s6 -0.995724s6 -0.995884s6 -0.996041s6 -0.996194s6 -0.996345s6 -0.996492s6 -0.996637s6 -0.996778s6 -0.996917s6 -0.997052s6 -0.997185s6 -0.997314s6 -0.997440s6 -0.997564s6 -0.997684s6 -0.997801s6 -0.997915s6 -0.998026s6 -0.998134s6 -0.998239s6 -0.998341s6 -0.998440s6 -0.998536s6 -0.998629s6 -0.998719s6 -0.998806s6 -0.998889s6 -0.998970s6 -0.999048s6 -0.999122s6 -0.999194s6 -0.999262s6 -0.999328s6 -0.999390s6 -0.999450s6 -0.999506s6 -0.999559s6 -0.999610s6 -0.999657s6 -0.999701s6 -0.999742s6 -0.999780s6 -0.999815s6 -0.999847s6 -0.999876s6 -0.999902s6 -0.999925s6 -0.999945s6 -0.999961s6 -0.999975s6 -0.999986s6 -0.999993s6 -0.999998s6 -1.000000s6 -0.999998s6 -0.999993s6 -0.999986s6 -0.999975s6 -0.999961s6 -0.999945s6 -0.999925s6 -0.999902s6 -0.999876s6 -0.999847s6 -0.999815s6 -0.999780s6 -0.999742s6 -0.999701s6 -0.999657s6 -0.999610s6 -0.999559s6 -0.999506s6 -0.999450s6 -0.999390s6 -0.999328s6 -0.999262s6 -0.999194s6 -0.999122s6 -0.999048s6 -0.998970s6 -0.998889s6 -0.998806s6 -0.998719s6 -0.998629s6 -0.998536s6 -0.998440s6 -0.998341s6 -0.998239s6 -0.998134s6 -0.998026s6 -0.997915s6 -0.997801s6 -0.997684s6 -0.997564s6 -0.997440s6 -0.997314s6 -0.997185s6 -0.997052s6 -0.996917s6 -0.996778s6 -0.996637s6 -0.996492s6 -0.996345s6 -0.996194s6 -0.996041s6 -0.995884s6 -0.995724s6 -0.995561s6 -0.995396s6 -0.995227s6 -0.995055s6 -0.994880s6 -0.994702s6 -0.994521s6 -0.994337s6 -0.994150s6 -0.993960s6 -0.993767s6 -0.993571s6 -0.993372s6 -0.993170s6 -0.992965s6 -0.992757s6 -0.992546s6 -0.992331s6 -0.992114s6 -0.991894s6 -0.991671s6 -0.991444s6 -0.991215s6 -0.990983s6 -0.990747s6 -0.990509s6 -0.990268s6 -0.990023s6 -0.989776s6 -0.989525s6 -0.989272s6 -0.989015s6 -0.988756s6 -0.988493s6 -0.988228s6 -0.987959s6 -0.987688s6 -0.987413s6 -0.987136s6 -0.986855s6 -0.986572s6 -0.986285s6 -0.985996s6 -0.985703s6 -0.985407s6 -0.985109s6 -0.984807s6 -0.984503s6 -0.984195s6 -0.983885s6 -0.983571s6 -0.983254s6 -0.982935s6 -0.982612s6 -0.982287s6 -0.981958s6 -0.981627s6 -0.981292s6 -0.980955s6 -0.980614s6 -0.980271s6 -0.979924s6 -0.979575s6 -0.979222s6 -0.978867s6 -0.978508s6 -0.978147s6 -0.977783s6 -0.977415s6 -0.977045s6 -0.976672s6 -0.976296s6 -0.975916s6 -0.975534s6 -0.975149s6 -0.974761s6 -0.974370s6 -0.973975s6 -0.973578s6 -0.973178s6 -0.972775s6 -0.972369s6 -0.971961s6 -0.971549s6 -0.971134s6 -0.970716s6 -0.970295s6 -0.969872s6 -0.969445s6 -0.969015s6 -0.968583s6 -0.968147s6 -0.967709s6 -0.967267s6 -0.966823s6 -0.966376s6 -0.965925s6 -0.965472s6 -0.965016s6 -0.964557s6 -0.964095s6 -0.963630s6 -0.963162s6 -0.962691s6 -0.962217s6 -0.961741s6 -0.961261s6 -0.960779s6 -0.960293s6 -0.959805s6 -0.959313s6 -0.958819s6 -0.958322s6 -0.957822s6 -0.957319s6 -0.956813s6 -0.956304s6 -0.955793s6 -0.955278s6 -0.954760s6 -0.954240s6 -0.953716s6 -0.953190s6 -0.952661s6 -0.952129s6 -0.951594s6 -0.951056s6 -0.950515s6 -0.949972s6 -0.949425s6 -0.948876s6 -0.948323s6 -0.947768s6 -0.947210s6 -0.946649s6 -0.946085s6 -0.945518s6 -0.944948s6 -0.944376s6 -0.943800s6 -0.943222s6 -0.942641s6 -0.942057s6 -0.941470s6 -0.940880s6 -0.940288s6 -0.939692s6 -0.939094s6 -0.938493s6 -0.937888s6 -0.937281s6 -0.936672s6 -0.936059s6 -0.935444s6 -0.934825s6 -0.934204s6 -0.933580s6 -0.932953s6 -0.932323s6 -0.931691s6 -0.931055s6 -0.930417s6 -0.929776s6 -0.929132s6 -0.928485s6 -0.927836s6 -0.927183s6 -0.926528s6 -0.925870s6 -0.925209s6 -0.924546s6 -0.923879s6 -0.923210s6 -0.922538s6 -0.921863s6 -0.921185s6 -0.920504s6 -0.919821s6 -0.919135s6 -0.918446s6 -0.917754s6 -0.917060s6 -0.916362s6 -0.915662s6 -0.914959s6 -0.914253s6 -0.913545s6 -0.912834s6 -0.912120s6 -0.911403s6 -0.910683s6 -0.909961s6 -0.909236s6 -0.908508s6 -0.907777s6 -0.907044s6 -0.906307s6 -0.905568s6 -0.904827s6 -0.904082s6 -0.903335s6 -0.902585s6 -0.901832s6 -0.901077s6 -0.900318s6 -0.899557s6 -0.898794s6 -0.898027s6 -0.897258s6 -0.896486s6 -0.895711s6 -0.894934s6 -0.894154s6 -0.893371s6 -0.892585s6 -0.891797s6 -0.891006s6 -0.890212s6 -0.889416s6 -0.888617s6 -0.887815s6 -0.887010s6 -0.886203s6 -0.885393s6 -0.884580s6 -0.883765s6 -0.882947s6 -0.882126s6 -0.881303s6 -0.880477s6 -0.879648s6 -0.878817s6 -0.877982s6 -0.877146s6 -0.876306s6 -0.875464s6 -0.874619s6 -0.873772s6 -0.872922s6 -0.872069s6 -0.871213s6 -0.870355s6 -0.869494s6 -0.868631s6 -0.867765s6 -0.866896s6 -0.866025s6 -0.865151s6 -0.864274s6 -0.863395s6 -0.862513s6 -0.861629s6 -0.860742s6 -0.859852s6 -0.858959s6 -0.858064s6 -0.857167s6 -0.856267s6 -0.855364s6 -0.854458s6 -0.853550s6 -0.852640s6 -0.851726s6 -0.850811s6 -0.849892s6 -0.848971s6 -0.848048s6 -0.847121s6 -0.846193s6 -0.845261s6 -0.844327s6 -0.843391s6 -0.842452s6 -0.841510s6 -0.840566s6 -0.839619s6 -0.838670s6 -0.837718s6 -0.836764s6 -0.835807s6 -0.834847s6 -0.833885s6 -0.832921s6 -0.831954s6 -0.830984s6 -0.830012s6 -0.829037s6 -0.828060s6 -0.827080s6 -0.826098s6 -0.825113s6 -0.824126s6 -0.823136s6 -0.822144s6 -0.821149s6 -0.820151s6 -0.819152s6 -0.818149s6 -0.817144s6 -0.816137s6 -0.815127s6 -0.814115s6 -0.813100s6 -0.812083s6 -0.811063s6 -0.810041s6 -0.809016s6 -0.807989s6 -0.806960s6 -0.805928s6 -0.804893s6 -0.803856s6 -0.802817s6 -0.801775s6 -0.800731s6 -0.799684s6 -0.798635s6 -0.797583s6 -0.796529s6 -0.795473s6 -0.794414s6 -0.793353s6 -0.792289s6 -0.791223s6 -0.790155s6 -0.789084s6 -0.788010s6 -0.786935s6 -0.785856s6 -0.784776s6 -0.783693s6 -0.782608s6 -0.781520s6 -0.780430s6 -0.779337s6 -0.778243s6 -0.777145s6 -0.776046s6 -0.774944s6 -0.773840s6 -0.772733s6 -0.771624s6 -0.770513s6 -0.769399s6 -0.768283s6 -0.767165s6 -0.766044s6 -0.764921s6 -0.763796s6 -0.762668s6 -0.761538s6 -0.760405s6 -0.759271s6 -0.758134s6 -0.756995s6 -0.755853s6 -0.754709s6 -0.753563s6 -0.752414s6 -0.751264s6 -0.750111s6 -0.748955s6 -0.747798s6 -0.746638s6 -0.745475s6 -0.744311s6 -0.743144s6 -0.741975s6 -0.740804s6 -0.739631s6 -0.738455s6 -0.737277s6 -0.736097s6 -0.734914s6 -0.733729s6 -0.732542s6 -0.731353s6 -0.730162s6 -0.728968s6 -0.727772s6 -0.726574s6 -0.725374s6 -0.724171s6 -0.722967s6 -0.721760s6 -0.720551s6 -0.719339s6 -0.718126s6 -0.716910s6 -0.715692s6 -0.714472s6 -0.713250s6 -0.712026s6 -0.710799s6 -0.709570s6 -0.708339s6 -0.707106s6 -0.705871s6 -0.704634s6 -0.703394s6 -0.702153s6 -0.700909s6 -0.699663s6 -0.698415s6 -0.697165s6 -0.695912s6 -0.694658s6 -0.693401s6 -0.692143s6 -0.690882s6 -0.689619s6 -0.688354s6 -0.687087s6 -0.685818s6 -0.684547s6 -0.683273s6 -0.681998s6 -0.680720s6 -0.679441s6 -0.678159s6 -0.676875s6 -0.675590s6 -0.674302s6 -0.673012s6 -0.671720s6 -0.670426s6 -0.669130s6 -0.667832s6 -0.666532s6 -0.665230s6 -0.663926s6 -0.662620s6 -0.661311s6 -0.660001s6 -0.658689s6 -0.657375s6 -0.656059s6 -0.654740s6 -0.653420s6 -0.652098s6 -0.650774s6 -0.649448s6 -0.648119s6 -0.646789s6 -0.645457s6 -0.644123s6 -0.642787s6 -0.641449s6 -0.640109s6 -0.638767s6 -0.637423s6 -0.636078s6 -0.634730s6 -0.633380s6 -0.632029s6 -0.630675s6 -0.629320s6 -0.627963s6 -0.626603s6 -0.625242s6 -0.623879s6 -0.622514s6 -0.621147s6 -0.619779s6 -0.618408s6 -0.617035s6 -0.615661s6 -0.614285s6 -0.612907s6 -0.611527s6 -0.610145s6 -0.608761s6 -0.607375s6 -0.605988s6 -0.604599s6 -0.603207s6 -0.601815s6 -0.600420s6 -0.599023s6 -0.597625s6 -0.596224s6 -0.594822s6 -0.593418s6 -0.592013s6 -0.590605s6 -0.589196s6 -0.587785s6 -0.586372s6 -0.584957s6 -0.583541s6 -0.582122s6 -0.580702s6 -0.579281s6 -0.577857s6 -0.576432s6 -0.575005s6 -0.573576s6 -0.572145s6 -0.570713s6 -0.569279s6 -0.567843s6 -0.566406s6 -0.564967s6 -0.563526s6 -0.562083s6 -0.560638s6 -0.559192s6 -0.557745s6 -0.556295s6 -0.554844s6 -0.553391s6 -0.551936s6 -0.550480s6 -0.549022s6 -0.547563s6 -0.546101s6 -0.544639s6 -0.543174s6 -0.541708s6 -0.540240s6 -0.538770s6 -0.537299s6 -0.535826s6 -0.534352s6 -0.532876s6 -0.531398s6 -0.529919s6 -0.528438s6 -0.526955s6 -0.525471s6 -0.523985s6 -0.522498s6 -0.521009s6 -0.519519s6 -0.518027s6 -0.516533s6 -0.515038s6 -0.513541s6 -0.512042s6 -0.510542s6 -0.509041s6 -0.507538s6 -0.506033s6 -0.504527s6 -0.503019s6 -0.501510s6 -0.500000s6 -0.498487s6 -0.496973s6 -0.495458s6 -0.493941s6 -0.492423s6 -0.490903s6 -0.489382s6 -0.487859s6 -0.486335s6 -0.484809s6 -0.483282s6 -0.481753s6 -0.480223s6 -0.478691s6 -0.477158s6 -0.475624s6 -0.474088s6 -0.472550s6 -0.471011s6 -0.469471s6 -0.467929s6 -0.466386s6 -0.464842s6 -0.463296s6 -0.461748s6 -0.460199s6 -0.458649s6 -0.457097s6 -0.455544s6 -0.453990s6 -0.452434s6 -0.450877s6 -0.449318s6 -0.447759s6 -0.446197s6 -0.444635s6 -0.443071s6 -0.441505s6 -0.439939s6 -0.438371s6 -0.436801s6 -0.435231s6 -0.433659s6 -0.432085s6 -0.430511s6 -0.428935s6 -0.427357s6 -0.425779s6 -0.424199s6 -0.422618s6 -0.421035s6 -0.419452s6 -0.417867s6 -0.416280s6 -0.414693s6 -0.413104s6 -0.411514s6 -0.409923s6 -0.408330s6 -0.406736s6 -0.405141s6 -0.403545s6 -0.401947s6 -0.400349s6 -0.398749s6 -0.397147s6 -0.395545s6 -0.393941s6 -0.392337s6 -0.390731s6 -0.389123s6 -0.387515s6 -0.385906s6 -0.384295s6 -0.382683s6 -0.381070s6 -0.379456s6 -0.377840s6 -0.376224s6 -0.374606s6 -0.372987s6 -0.371367s6 -0.369746s6 -0.368124s6 -0.366501s6 -0.364876s6 -0.363251s6 -0.361624s6 -0.359996s6 -0.358367s6 -0.356737s6 -0.355106s6 -0.353474s6 -0.351841s6 -0.350207s6 -0.348572s6 -0.346935s6 -0.345298s6 -0.343659s6 -0.342020s6 -0.340379s6 -0.338737s6 -0.337095s6 -0.335451s6 -0.333806s6 -0.332161s6 -0.330514s6 -0.328866s6 -0.327217s6 -0.325568s6 -0.323917s6 -0.322265s6 -0.320612s6 -0.318959s6 -0.317304s6 -0.315649s6 -0.313992s6 -0.312334s6 -0.310676s6 -0.309016s6 -0.307356s6 -0.305695s6 -0.304033s6 -0.302369s6 -0.300705s6 -0.299040s6 -0.297374s6 -0.295708s6 -0.294040s6 -0.292371s6 -0.290702s6 -0.289031s6 -0.287360s6 -0.285688s6 -0.284015s6 -0.282341s6 -0.280666s6 -0.278991s6 -0.277314s6 -0.275637s6 -0.273959s6 -0.272280s6 -0.270600s6 -0.268919s6 -0.267238s6 -0.265556s6 -0.263873s6 -0.262189s6 -0.260504s6 -0.258819s6 -0.257132s6 -0.255445s6 -0.253757s6 -0.252069s6 -0.250380s6 -0.248689s6 -0.246999s6 -0.245307s6 -0.243615s6 -0.241921s6 -0.240228s6 -0.238533s6 -0.236838s6 -0.235142s6 -0.233445s6 -0.231747s6 -0.230049s6 -0.228350s6 -0.226651s6 -0.224951s6 -0.223250s6 -0.221548s6 -0.219846s6 -0.218143s6 -0.216439s6 -0.214735s6 -0.213030s6 -0.211324s6 -0.209618s6 -0.207911s6 -0.206204s6 -0.204496s6 -0.202787s6 -0.201077s6 -0.199367s6 -0.197657s6 -0.195946s6 -0.194234s6 -0.192521s6 -0.190808s6 -0.189095s6 -0.187381s6 -0.185666s6 -0.183951s6 -0.182235s6 -0.180519s6 -0.178802s6 -0.177084s6 -0.175366s6 -0.173648s6 -0.171929s6 -0.170209s6 -0.168489s6 -0.166768s6 -0.165047s6 -0.163325s6 -0.161603s6 -0.159881s6 -0.158158s6 -0.156434s6 -0.154710s6 -0.152985s6 -0.151260s6 -0.149535s6 -0.147809s6 -0.146083s6 -0.144356s6 -0.142628s6 -0.140901s6 -0.139173s6 -0.137444s6 -0.135715s6 -0.133986s6 -0.132256s6 -0.130526s6 -0.128795s6 -0.127064s6 -0.125333s6 -0.123601s6 -0.121869s6 -0.120136s6 -0.118403s6 -0.116670s6 -0.114937s6 -0.113203s6 -0.111468s6 -0.109734s6 -0.107999s6 -0.106264s6 -0.104528s6 -0.102792s6 -0.101056s6 -0.099319s6 -0.097582s6 -0.095845s6 -0.094108s6 -0.092370s6 -0.090632s6 -0.088894s6 -0.087155s6 -0.085416s6 -0.083677s6 -0.081938s6 -0.080198s6 -0.078459s6 -0.076719s6 -0.074978s6 -0.073238s6 -0.071497s6 -0.069756s6 -0.068015s6 -0.066273s6 -0.064532s6 -0.062790s6 -0.061048s6 -0.059306s6 -0.057564s6 -0.055821s6 -0.054078s6 -0.052335s6 -0.050592s6 -0.048849s6 -0.047106s6 -0.045362s6 -0.043619s6 -0.041875s6 -0.040131s6 -0.038387s6 -0.036643s6 -0.034899s6 -0.033155s6 -0.031410s6 -0.029666s6 -0.027921s6 -0.026176s6 -0.024432s6 -0.022687s6 -0.020942s6 -0.019197s6 -0.017452s6 -0.015707s6 -0.013962s6 -0.012217s6 -0.010471s6 -0.008726s6 -0.006981s6 -0.005235s6 -0.003490s6 -0.001745s6)! !!AvTrigonometryHelper class methodsFor: 'trigonometry-support' stamp: 'Jon 1/26/2006 12:30'!loadTanTable	"AvTrigonometryHelper loadTanTable"	TanTable := #(0.000000s6 0.001745s6 0.003490s6 0.005236s6 0.006981s6 0.008726s6 0.010472s6 0.012217s6 0.013963s6 0.015709s6 0.017455s6 0.019200s6 0.020947s6 0.022693s6 0.024439s6 0.026185s6 0.027932s6 0.029679s6 0.031426s6 0.033173s6 0.034920s6 0.036668s6 0.038416s6 0.040164s6 0.041912s6 0.043660s6 0.045409s6 0.047158s6 0.048908s6 0.050657s6 0.052407s6 0.054158s6 0.055908s6 0.057659s6 0.059410s6 0.061162s6 0.062914s6 0.064667s6 0.066419s6 0.068173s6 0.069926s6 0.071680s6 0.073435s6 0.075190s6 0.076945s6 0.078701s6 0.080458s6 0.082214s6 0.083972s6 0.085730s6 0.087488s6 0.089247s6 0.091007s6 0.092767s6 0.094527s6 0.096289s6 0.098050s6 0.099813s6 0.101576s6 0.103339s6 0.105104s6 0.106869s6 0.108634s6 0.110401s6 0.112167s6 0.113935s6 0.115703s6 0.117473s6 0.119242s6 0.121013s6 0.122784s6 0.124556s6 0.126329s6 0.128102s6 0.129877s6 0.131652s6 0.133428s6 0.135205s6 0.136982s6 0.138761s6 0.140540s6 0.142321s6 0.144102s6 0.145884s6 0.147667s6 0.149451s6 0.151235s6 0.153021s6 0.154808s6 0.156595s6 0.158384s6 0.160174s6 0.161964s6 0.163756s6 0.165548s6 0.167342s6 0.169137s6 0.170933s6 0.172729s6 0.174527s6 0.176326s6 0.178127s6 0.179928s6 0.181730s6 0.183534s6 0.185339s6 0.187144s6 0.188951s6 0.190760s6 0.192569s6 0.194380s6 0.196192s6 0.198005s6 0.199819s6 0.201635s6 0.203452s6 0.205270s6 0.207090s6 0.208910s6 0.210733s6 0.212556s6 0.214381s6 0.216207s6 0.218035s6 0.219864s6 0.221694s6 0.223526s6 0.225359s6 0.227194s6 0.229030s6 0.230868s6 0.232707s6 0.234547s6 0.236389s6 0.238233s6 0.240078s6 0.241925s6 0.243773s6 0.245623s6 0.247474s6 0.249328s6 0.251182s6 0.253038s6 0.254896s6 0.256756s6 0.258617s6 0.260480s6 0.262345s6 0.264211s6 0.266079s6 0.267949s6 0.269820s6 0.271693s6 0.273569s6 0.275445s6 0.277324s6 0.279205s6 0.281087s6 0.282971s6 0.284857s6 0.286745s6 0.288635s6 0.290526s6 0.292420s6 0.294316s6 0.296213s6 0.298112s6 0.300014s6 0.301917s6 0.303823s6 0.305730s6 0.307640s6 0.309551s6 0.311465s6 0.313381s6 0.315298s6 0.317218s6 0.319140s6 0.321064s6 0.322991s6 0.324919s6 0.326850s6 0.328783s6 0.330718s6 0.332655s6 0.334595s6 0.336537s6 0.338481s6 0.340427s6 0.342376s6 0.344327s6 0.346281s6 0.348236s6 0.350195s6 0.352155s6 0.354118s6 0.356083s6 0.358051s6 0.360022s6 0.361994s6 0.363970s6 0.365948s6 0.367928s6 0.369911s6 0.371896s6 0.373884s6 0.375875s6 0.377868s6 0.379864s6 0.381862s6 0.383864s6 0.385867s6 0.387874s6 0.389883s6 0.391895s6 0.393910s6 0.395928s6 0.397948s6 0.399971s6 0.401997s6 0.404026s6 0.406057s6 0.408092s6 0.410129s6 0.412170s6 0.414213s6 0.416259s6 0.418309s6 0.420361s6 0.422416s6 0.424474s6 0.426536s6 0.428600s6 0.430668s6 0.432738s6 0.434812s6 0.436889s6 0.438969s6 0.441052s6 0.443139s6 0.445228s6 0.447321s6 0.449417s6 0.451517s6 0.453620s6 0.455726s6 0.457835s6 0.459948s6 0.462064s6 0.464184s6 0.466307s6 0.468434s6 0.470564s6 0.472697s6 0.474834s6 0.476975s6 0.479119s6 0.481267s6 0.483418s6 0.485573s6 0.487732s6 0.489894s6 0.492061s6 0.494230s6 0.496404s6 0.498581s6 0.500762s6 0.502947s6 0.505136s6 0.507328s6 0.509525s6 0.511725s6 0.513930s6 0.516138s6 0.518350s6 0.520567s6 0.522787s6 0.525011s6 0.527240s6 0.529472s6 0.531709s6 0.533950s6 0.536195s6 0.538444s6 0.540697s6 0.542955s6 0.545217s6 0.547484s6 0.549754s6 0.552029s6 0.554309s6 0.556592s6 0.558881s6 0.561173s6 0.563471s6 0.565772s6 0.568079s6 0.570389s6 0.572705s6 0.575025s6 0.577350s6 0.579679s6 0.582013s6 0.584352s6 0.586696s6 0.589045s6 0.591398s6 0.593756s6 0.596119s6 0.598487s6 0.600860s6 0.603238s6 0.605621s6 0.608009s6 0.610402s6 0.612800s6 0.615204s6 0.617612s6 0.620026s6 0.622445s6 0.624869s6 0.627298s6 0.629733s6 0.632173s6 0.634619s6 0.637070s6 0.639526s6 0.641988s6 0.644456s6 0.646929s6 0.649407s6 0.651891s6 0.654381s6 0.656877s6 0.659378s6 0.661885s6 0.664398s6 0.666917s6 0.669441s6 0.671972s6 0.674508s6 0.677050s6 0.679599s6 0.682153s6 0.684714s6 0.687280s6 0.689853s6 0.692432s6 0.695018s6 0.697609s6 0.700207s6 0.702811s6 0.705422s6 0.708039s6 0.710663s6 0.713293s6 0.715929s6 0.718572s6 0.721222s6 0.723879s6 0.726542s6 0.729212s6 0.731889s6 0.734573s6 0.737263s6 0.739961s6 0.742665s6 0.745377s6 0.748095s6 0.750821s6 0.753554s6 0.756294s6 0.759041s6 0.761795s6 0.764557s6 0.767326s6 0.770103s6 0.772887s6 0.775679s6 0.778478s6 0.781285s6 0.784100s6 0.786922s6 0.789752s6 0.792590s6 0.795435s6 0.798289s6 0.801151s6 0.804020s6 0.806898s6 0.809784s6 0.812677s6 0.815580s6 0.818490s6 0.821409s6 0.824336s6 0.827271s6 0.830215s6 0.833168s6 0.836129s6 0.839099s6 0.842078s6 0.845065s6 0.848061s6 0.851066s6 0.854080s6 0.857103s6 0.860135s6 0.863176s6 0.866227s6 0.869286s6 0.872355s6 0.875433s6 0.878521s6 0.881618s6 0.884725s6 0.887841s6 0.890967s6 0.894103s6 0.897248s6 0.900404s6 0.903569s6 0.906744s6 0.909929s6 0.913125s6 0.916331s6 0.919547s6 0.922773s6 0.926010s6 0.929257s6 0.932515s6 0.935783s6 0.939062s6 0.942352s6 0.945652s6 0.948964s6 0.952287s6 0.955620s6 0.958965s6 0.962321s6 0.965688s6 0.969067s6 0.972457s6 0.975859s6 0.979272s6 0.982697s6 0.986133s6 0.989582s6 0.993042s6 0.996515s6 0.999999s6 1.003496s6 1.007005s6 1.010527s6 1.014061s6 1.017607s6 1.021166s6 1.024738s6 1.028322s6 1.031919s6 1.035530s6 1.039153s6 1.042790s6 1.046440s6 1.050103s6 1.053780s6 1.057470s6 1.061174s6 1.064891s6 1.068623s6 1.072368s6 1.076128s6 1.079901s6 1.083689s6 1.087491s6 1.091308s6 1.095139s6 1.098985s6 1.102846s6 1.106721s6 1.110612s6 1.114518s6 1.118439s6 1.122375s6 1.126327s6 1.130294s6 1.134277s6 1.138276s6 1.142290s6 1.146321s6 1.150368s6 1.154431s6 1.158511s6 1.162607s6 1.166720s6 1.170849s6 1.174996s6 1.179159s6 1.183340s6 1.187538s6 1.191753s6 1.195986s6 1.200237s6 1.204505s6 1.208792s6 1.213097s6 1.217419s6 1.221761s6 1.226121s6 1.230499s6 1.234897s6 1.239313s6 1.243749s6 1.248204s6 1.252678s6 1.257172s6 1.261685s6 1.266219s6 1.270773s6 1.275347s6 1.279941s6 1.284556s6 1.289192s6 1.293848s6 1.298526s6 1.303225s6 1.307945s6 1.312687s6 1.317451s6 1.322237s6 1.327044s6 1.331874s6 1.336727s6 1.341602s6 1.346501s6 1.351422s6 1.356367s6 1.361335s6 1.366326s6 1.371342s6 1.376381s6 1.381445s6 1.386534s6 1.391647s6 1.396785s6 1.401948s6 1.407136s6 1.412350s6 1.417590s6 1.422856s6 1.428148s6 1.433466s6 1.438811s6 1.444183s6 1.449582s6 1.455009s6 1.460463s6 1.465945s6 1.471455s6 1.476993s6 1.482560s6 1.488156s6 1.493782s6 1.499436s6 1.505120s6 1.510835s6 1.516579s6 1.522354s6 1.528160s6 1.533996s6 1.539864s6 1.545764s6 1.551696s6 1.557660s6 1.563656s6 1.569685s6 1.575747s6 1.581843s6 1.587973s6 1.594136s6 1.600334s6 1.606567s6 1.612834s6 1.619137s6 1.625476s6 1.631851s6 1.638262s6 1.644711s6 1.651196s6 1.657718s6 1.664279s6 1.670878s6 1.677515s6 1.684191s6 1.690907s6 1.697663s6 1.704458s6 1.711294s6 1.718172s6 1.725090s6 1.732050s6 1.739053s6 1.746098s6 1.753186s6 1.760318s6 1.767494s6 1.774714s6 1.781979s6 1.789289s6 1.796645s6 1.804047s6 1.811496s6 1.818993s6 1.826537s6 1.834129s6 1.841770s6 1.849461s6 1.857201s6 1.864992s6 1.872833s6 1.880726s6 1.888671s6 1.896668s6 1.904719s6 1.912823s6 1.920982s6 1.929195s6 1.937464s6 1.945789s6 1.954171s6 1.962610s6 1.971107s6 1.979663s6 1.988278s6 1.996953s6 2.005689s6 2.014486s6 2.023346s6 2.032268s6 2.041253s6 2.050303s6 2.059418s6 2.068599s6 2.077846s6 2.087161s6 2.096543s6 2.105995s6 2.115516s6 2.125108s6 2.134771s6 2.144506s6 2.154315s6 2.164198s6 2.174155s6 2.184189s6 2.194299s6 2.204487s6 2.214754s6 2.225100s6 2.235527s6 2.246036s6 2.256628s6 2.267303s6 2.278063s6 2.288909s6 2.299842s6 2.310863s6 2.321974s6 2.333174s6 2.344467s6 2.355852s6 2.367331s6 2.378905s6 2.390576s6 2.402345s6 2.414213s6 2.426181s6 2.438251s6 2.450425s6 2.462703s6 2.475086s6 2.487578s6 2.500178s6 2.512889s6 2.525711s6 2.538647s6 2.551699s6 2.564867s6 2.578153s6 2.591560s6 2.605089s6 2.618741s6 2.632518s6 2.646423s6 2.660456s6 2.674621s6 2.688918s6 2.703351s6 2.717920s6 2.732628s6 2.747477s6 2.762469s6 2.777606s6 2.792891s6 2.808326s6 2.823912s6 2.839653s6 2.855551s6 2.871608s6 2.887827s6 2.904210s6 2.920760s6 2.937480s6 2.954372s6 2.971439s6 2.988684s6 3.006110s6 3.023720s6 3.041517s6 3.059503s6 3.077683s6 3.096059s6 3.114635s6 3.133414s6 3.152399s6 3.171594s6 3.191003s6 3.210630s6 3.230478s6 3.250550s6 3.270852s6 3.291387s6 3.312159s6 3.333173s6 3.354433s6 3.375943s6 3.397708s6 3.419733s6 3.442022s6 3.464581s6 3.487414s6 3.510527s6 3.533925s6 3.557613s6 3.581597s6 3.605883s6 3.630477s6 3.655384s6 3.680611s6 3.706164s6 3.732050s6 3.758276s6 3.784848s6 3.811773s6 3.839059s6 3.866713s6 3.894742s6 3.923156s6 3.951961s6 3.981166s6 4.010780s6 4.040812s6 4.071270s6 4.102164s6 4.133504s6 4.165299s6 4.197560s6 4.230297s6 4.263521s6 4.297243s6 4.331475s6 4.366229s6 4.401516s6 4.437349s6 4.473742s6 4.510708s6 4.548260s6 4.586414s6 4.625183s6 4.664583s6 4.704630s6 4.745340s6 4.786730s6 4.828817s6 4.871620s6 4.915157s6 4.959447s6 5.004511s6 5.050369s6 5.097042s6 5.144554s6 5.192926s6 5.242183s6 5.292350s6 5.343452s6 5.395517s6 5.448571s6 5.502644s6 5.557766s6 5.613967s6 5.671281s6 5.729741s6 5.789382s6 5.850240s6 5.912355s6 5.975764s6 6.040510s6 6.106636s6 6.174186s6 6.243208s6 6.313751s6 6.385866s6 6.459607s6 6.535029s6 6.612191s6 6.691156s6 6.771986s6 6.854750s6 6.939519s6 7.026366s6 7.115369s6 7.206611s6 7.300178s6 7.396159s6 7.494651s6 7.595754s6 7.699573s6 7.806221s6 7.915815s6 8.028479s6 8.144346s6 8.263554s6 8.386251s6 8.512594s6 8.642747s6 8.776887s6 8.915200s6 9.057886s6 9.205156s6 9.357235s6 9.514364s6 9.676799s6 9.844816s6 10.018707s6 10.198788s6 10.385397s6 10.578894s6 10.779672s6 10.988150s6 11.204780s6 11.430052s6 11.664495s6 11.908682s6 12.163235s6 12.428831s6 12.706204s6 12.996159s6 13.299574s6 13.617408s6 13.950719s6 14.300666s6 14.668529s6 15.055722s6 15.463814s6 15.894544s6 16.349855s6 16.831914s6 17.343154s6 17.886310s6 18.464470s6 19.081136s6 19.740290s6 20.446486s6 21.204948s6 22.021710s6 22.903765s6 23.859277s6 24.897826s6 26.030735s6 27.271486s6 28.636253s6 30.144618s6 31.820515s6 33.693508s6 35.800553s6 38.188459s6 40.917411s6 44.066113s6 47.739501s6 52.080672s6 57.289961s6 63.656741s6 71.615070s6 81.847041s6 95.489475s6 114.588650s6 143.237121s6 190.984186s6 286.477734s6 572.957213s6 8165889364191922.000000s6 -572.957213s6 -286.477734s6 -190.984186s6 -143.237121s6 -114.588650s6 -95.489475s6 -81.847041s6 -71.615070s6 -63.656741s6 -57.289961s6 -52.080672s6 -47.739501s6 -44.066113s6 -40.917411s6 -38.188459s6 -35.800553s6 -33.693508s6 -31.820515s6 -30.144618s6 -28.636253s6 -27.271486s6 -26.030735s6 -24.897826s6 -23.859277s6 -22.903765s6 -22.021710s6 -21.204948s6 -20.446486s6 -19.740290s6 -19.081136s6 -18.464470s6 -17.886310s6 -17.343154s6 -16.831914s6 -16.349855s6 -15.894544s6 -15.463814s6 -15.055722s6 -14.668529s6 -14.300666s6 -13.950719s6 -13.617408s6 -13.299574s6 -12.996159s6 -12.706204s6 -12.428831s6 -12.163235s6 -11.908682s6 -11.664495s6 -11.430052s6 -11.204780s6 -10.988150s6 -10.779672s6 -10.578894s6 -10.385397s6 -10.198788s6 -10.018707s6 -9.844816s6 -9.676799s6 -9.514364s6 -9.357235s6 -9.205156s6 -9.057886s6 -8.915200s6 -8.776887s6 -8.642747s6 -8.512594s6 -8.386251s6 -8.263554s6 -8.144346s6 -8.028479s6 -7.915815s6 -7.806221s6 -7.699573s6 -7.595754s6 -7.494651s6 -7.396159s6 -7.300178s6 -7.206611s6 -7.115369s6 -7.026366s6 -6.939519s6 -6.854750s6 -6.771986s6 -6.691156s6 -6.612191s6 -6.535029s6 -6.459607s6 -6.385866s6 -6.313751s6 -6.243208s6 -6.174186s6 -6.106636s6 -6.040510s6 -5.975764s6 -5.912355s6 -5.850240s6 -5.789382s6 -5.729741s6 -5.671281s6 -5.613967s6 -5.557766s6 -5.502644s6 -5.448571s6 -5.395517s6 -5.343452s6 -5.292350s6 -5.242183s6 -5.192926s6 -5.144554s6 -5.097042s6 -5.050369s6 -5.004511s6 -4.959447s6 -4.915157s6 -4.871620s6 -4.828817s6 -4.786730s6 -4.745340s6 -4.704630s6 -4.664583s6 -4.625183s6 -4.586414s6 -4.548260s6 -4.510708s6 -4.473742s6 -4.437349s6 -4.401516s6 -4.366229s6 -4.331475s6 -4.297243s6 -4.263521s6 -4.230297s6 -4.197560s6 -4.165299s6 -4.133504s6 -4.102164s6 -4.071270s6 -4.040812s6 -4.010780s6 -3.981166s6 -3.951961s6 -3.923156s6 -3.894742s6 -3.866713s6 -3.839059s6 -3.811773s6 -3.784848s6 -3.758276s6 -3.732050s6 -3.706164s6 -3.680611s6 -3.655384s6 -3.630477s6 -3.605883s6 -3.581597s6 -3.557613s6 -3.533925s6 -3.510527s6 -3.487414s6 -3.464581s6 -3.442022s6 -3.419733s6 -3.397708s6 -3.375943s6 -3.354433s6 -3.333173s6 -3.312159s6 -3.291387s6 -3.270852s6 -3.250550s6 -3.230478s6 -3.210630s6 -3.191003s6 -3.171594s6 -3.152399s6 -3.133414s6 -3.114635s6 -3.096059s6 -3.077683s6 -3.059503s6 -3.041517s6 -3.023720s6 -3.006110s6 -2.988684s6 -2.971439s6 -2.954372s6 -2.937480s6 -2.920760s6 -2.904210s6 -2.887827s6 -2.871608s6 -2.855551s6 -2.839653s6 -2.823912s6 -2.808326s6 -2.792891s6 -2.777606s6 -2.762469s6 -2.747477s6 -2.732628s6 -2.717920s6 -2.703351s6 -2.688918s6 -2.674621s6 -2.660456s6 -2.646423s6 -2.632518s6 -2.618741s6 -2.605089s6 -2.591560s6 -2.578153s6 -2.564867s6 -2.551699s6 -2.538647s6 -2.525711s6 -2.512889s6 -2.500178s6 -2.487578s6 -2.475086s6 -2.462703s6 -2.450425s6 -2.438251s6 -2.426181s6 -2.414213s6 -2.402345s6 -2.390576s6 -2.378905s6 -2.367331s6 -2.355852s6 -2.344467s6 -2.333174s6 -2.321974s6 -2.310863s6 -2.299842s6 -2.288909s6 -2.278063s6 -2.267303s6 -2.256628s6 -2.246036s6 -2.235527s6 -2.225100s6 -2.214754s6 -2.204487s6 -2.194299s6 -2.184189s6 -2.174155s6 -2.164198s6 -2.154315s6 -2.144506s6 -2.134771s6 -2.125108s6 -2.115516s6 -2.105995s6 -2.096543s6 -2.087161s6 -2.077846s6 -2.068599s6 -2.059418s6 -2.050303s6 -2.041253s6 -2.032268s6 -2.023346s6 -2.014486s6 -2.005689s6 -1.996953s6 -1.988278s6 -1.979663s6 -1.971107s6 -1.962610s6 -1.954171s6 -1.945789s6 -1.937464s6 -1.929195s6 -1.920982s6 -1.912823s6 -1.904719s6 -1.896668s6 -1.888671s6 -1.880726s6 -1.872833s6 -1.864992s6 -1.857201s6 -1.849461s6 -1.841770s6 -1.834129s6 -1.826537s6 -1.818993s6 -1.811496s6 -1.804047s6 -1.796645s6 -1.789289s6 -1.781979s6 -1.774714s6 -1.767494s6 -1.760318s6 -1.753186s6 -1.746098s6 -1.739053s6 -1.732050s6 -1.725090s6 -1.718172s6 -1.711294s6 -1.704458s6 -1.697663s6 -1.690907s6 -1.684191s6 -1.677515s6 -1.670878s6 -1.664279s6 -1.657718s6 -1.651196s6 -1.644711s6 -1.638262s6 -1.631851s6 -1.625476s6 -1.619137s6 -1.612834s6 -1.606567s6 -1.600334s6 -1.594136s6 -1.587973s6 -1.581843s6 -1.575747s6 -1.569685s6 -1.563656s6 -1.557660s6 -1.551696s6 -1.545764s6 -1.539864s6 -1.533996s6 -1.528160s6 -1.522354s6 -1.516579s6 -1.510835s6 -1.505120s6 -1.499436s6 -1.493782s6 -1.488156s6 -1.482560s6 -1.476993s6 -1.471455s6 -1.465945s6 -1.460463s6 -1.455009s6 -1.449582s6 -1.444183s6 -1.438811s6 -1.433466s6 -1.428148s6 -1.422856s6 -1.417590s6 -1.412350s6 -1.407136s6 -1.401948s6 -1.396785s6 -1.391647s6 -1.386534s6 -1.381445s6 -1.376381s6 -1.371342s6 -1.366326s6 -1.361335s6 -1.356367s6 -1.351422s6 -1.346501s6 -1.341602s6 -1.336727s6 -1.331874s6 -1.327044s6 -1.322237s6 -1.317451s6 -1.312687s6 -1.307945s6 -1.303225s6 -1.298526s6 -1.293848s6 -1.289192s6 -1.284556s6 -1.279941s6 -1.275347s6 -1.270773s6 -1.266219s6 -1.261685s6 -1.257172s6 -1.252678s6 -1.248204s6 -1.243749s6 -1.239313s6 -1.234897s6 -1.230499s6 -1.226121s6 -1.221761s6 -1.217419s6 -1.213097s6 -1.208792s6 -1.204505s6 -1.200237s6 -1.195986s6 -1.191753s6 -1.187538s6 -1.183340s6 -1.179159s6 -1.174996s6 -1.170849s6 -1.166720s6 -1.162607s6 -1.158511s6 -1.154431s6 -1.150368s6 -1.146321s6 -1.142290s6 -1.138276s6 -1.134277s6 -1.130294s6 -1.126327s6 -1.122375s6 -1.118439s6 -1.114518s6 -1.110612s6 -1.106721s6 -1.102846s6 -1.098985s6 -1.095139s6 -1.091308s6 -1.087491s6 -1.083689s6 -1.079901s6 -1.076128s6 -1.072368s6 -1.068623s6 -1.064891s6 -1.061174s6 -1.057470s6 -1.053780s6 -1.050103s6 -1.046440s6 -1.042790s6 -1.039153s6 -1.035530s6 -1.031919s6 -1.028322s6 -1.024738s6 -1.021166s6 -1.017607s6 -1.014061s6 -1.010527s6 -1.007005s6 -1.003496s6 -1.000000s6 -0.996515s6 -0.993042s6 -0.989582s6 -0.986133s6 -0.982697s6 -0.979272s6 -0.975859s6 -0.972457s6 -0.969067s6 -0.965688s6 -0.962321s6 -0.958965s6 -0.955620s6 -0.952287s6 -0.948964s6 -0.945652s6 -0.942352s6 -0.939062s6 -0.935783s6 -0.932515s6 -0.929257s6 -0.926010s6 -0.922773s6 -0.919547s6 -0.916331s6 -0.913125s6 -0.909929s6 -0.906744s6 -0.903569s6 -0.900404s6 -0.897248s6 -0.894103s6 -0.890967s6 -0.887841s6 -0.884725s6 -0.881618s6 -0.878521s6 -0.875433s6 -0.872355s6 -0.869286s6 -0.866227s6 -0.863176s6 -0.860135s6 -0.857103s6 -0.854080s6 -0.851066s6 -0.848061s6 -0.845065s6 -0.842078s6 -0.839099s6 -0.836129s6 -0.833168s6 -0.830215s6 -0.827271s6 -0.824336s6 -0.821409s6 -0.818490s6 -0.815580s6 -0.812677s6 -0.809784s6 -0.806898s6 -0.804020s6 -0.801151s6 -0.798289s6 -0.795435s6 -0.792590s6 -0.789752s6 -0.786922s6 -0.784100s6 -0.781285s6 -0.778478s6 -0.775679s6 -0.772887s6 -0.770103s6 -0.767326s6 -0.764557s6 -0.761795s6 -0.759041s6 -0.756294s6 -0.753554s6 -0.750821s6 -0.748095s6 -0.745377s6 -0.742665s6 -0.739961s6 -0.737263s6 -0.734573s6 -0.731889s6 -0.729212s6 -0.726542s6 -0.723879s6 -0.721222s6 -0.718572s6 -0.715929s6 -0.713293s6 -0.710663s6 -0.708039s6 -0.705422s6 -0.702811s6 -0.700207s6 -0.697609s6 -0.695018s6 -0.692432s6 -0.689853s6 -0.687280s6 -0.684714s6 -0.682153s6 -0.679599s6 -0.677050s6 -0.674508s6 -0.671972s6 -0.669441s6 -0.666917s6 -0.664398s6 -0.661885s6 -0.659378s6 -0.656877s6 -0.654381s6 -0.651891s6 -0.649407s6 -0.646929s6 -0.644456s6 -0.641988s6 -0.639526s6 -0.637070s6 -0.634619s6 -0.632173s6 -0.629733s6 -0.627298s6 -0.624869s6 -0.622445s6 -0.620026s6 -0.617612s6 -0.615204s6 -0.612800s6 -0.610402s6 -0.608009s6 -0.605621s6 -0.603238s6 -0.600860s6 -0.598487s6 -0.596119s6 -0.593756s6 -0.591398s6 -0.589045s6 -0.586696s6 -0.584352s6 -0.582013s6 -0.579679s6 -0.577350s6 -0.575025s6 -0.572705s6 -0.570389s6 -0.568079s6 -0.565772s6 -0.563471s6 -0.561173s6 -0.558881s6 -0.556592s6 -0.554309s6 -0.552029s6 -0.549754s6 -0.547484s6 -0.545217s6 -0.542955s6 -0.540697s6 -0.538444s6 -0.536195s6 -0.533950s6 -0.531709s6 -0.529472s6 -0.527240s6 -0.525011s6 -0.522787s6 -0.520567s6 -0.518350s6 -0.516138s6 -0.513930s6 -0.511725s6 -0.509525s6 -0.507328s6 -0.505136s6 -0.502947s6 -0.500762s6 -0.498581s6 -0.496404s6 -0.494230s6 -0.492061s6 -0.489894s6 -0.487732s6 -0.485573s6 -0.483418s6 -0.481267s6 -0.479119s6 -0.476975s6 -0.474834s6 -0.472697s6 -0.470564s6 -0.468434s6 -0.466307s6 -0.464184s6 -0.462064s6 -0.459948s6 -0.457835s6 -0.455726s6 -0.453620s6 -0.451517s6 -0.449417s6 -0.447321s6 -0.445228s6 -0.443139s6 -0.441052s6 -0.438969s6 -0.436889s6 -0.434812s6 -0.432738s6 -0.430668s6 -0.428600s6 -0.426536s6 -0.424474s6 -0.422416s6 -0.420361s6 -0.418309s6 -0.416259s6 -0.414213s6 -0.412170s6 -0.410129s6 -0.408092s6 -0.406057s6 -0.404026s6 -0.401997s6 -0.399971s6 -0.397948s6 -0.395928s6 -0.393910s6 -0.391895s6 -0.389883s6 -0.387874s6 -0.385867s6 -0.383864s6 -0.381862s6 -0.379864s6 -0.377868s6 -0.375875s6 -0.373884s6 -0.371896s6 -0.369911s6 -0.367928s6 -0.365948s6 -0.363970s6 -0.361994s6 -0.360022s6 -0.358051s6 -0.356083s6 -0.354118s6 -0.352155s6 -0.350195s6 -0.348236s6 -0.346281s6 -0.344327s6 -0.342376s6 -0.340427s6 -0.338481s6 -0.336537s6 -0.334595s6 -0.332655s6 -0.330718s6 -0.328783s6 -0.326850s6 -0.324919s6 -0.322991s6 -0.321064s6 -0.319140s6 -0.317218s6 -0.315298s6 -0.313381s6 -0.311465s6 -0.309551s6 -0.307640s6 -0.305730s6 -0.303823s6 -0.301917s6 -0.300014s6 -0.298112s6 -0.296213s6 -0.294316s6 -0.292420s6 -0.290526s6 -0.288635s6 -0.286745s6 -0.284857s6 -0.282971s6 -0.281087s6 -0.279205s6 -0.277324s6 -0.275445s6 -0.273569s6 -0.271693s6 -0.269820s6 -0.267949s6 -0.266079s6 -0.264211s6 -0.262345s6 -0.260480s6 -0.258617s6 -0.256756s6 -0.254896s6 -0.253038s6 -0.251182s6 -0.249328s6 -0.247474s6 -0.245623s6 -0.243773s6 -0.241925s6 -0.240078s6 -0.238233s6 -0.236389s6 -0.234547s6 -0.232707s6 -0.230868s6 -0.229030s6 -0.227194s6 -0.225359s6 -0.223526s6 -0.221694s6 -0.219864s6 -0.218035s6 -0.216207s6 -0.214381s6 -0.212556s6 -0.210733s6 -0.208910s6 -0.207090s6 -0.205270s6 -0.203452s6 -0.201635s6 -0.199819s6 -0.198005s6 -0.196192s6 -0.194380s6 -0.192569s6 -0.190760s6 -0.188951s6 -0.187144s6 -0.185339s6 -0.183534s6 -0.181730s6 -0.179928s6 -0.178127s6 -0.176326s6 -0.174527s6 -0.172729s6 -0.170933s6 -0.169137s6 -0.167342s6 -0.165548s6 -0.163756s6 -0.161964s6 -0.160174s6 -0.158384s6 -0.156595s6 -0.154808s6 -0.153021s6 -0.151235s6 -0.149451s6 -0.147667s6 -0.145884s6 -0.144102s6 -0.142321s6 -0.140540s6 -0.138761s6 -0.136982s6 -0.135205s6 -0.133428s6 -0.131652s6 -0.129877s6 -0.128102s6 -0.126329s6 -0.124556s6 -0.122784s6 -0.121013s6 -0.119242s6 -0.117473s6 -0.115703s6 -0.113935s6 -0.112167s6 -0.110401s6 -0.108634s6 -0.106869s6 -0.105104s6 -0.103339s6 -0.101576s6 -0.099813s6 -0.098050s6 -0.096289s6 -0.094527s6 -0.092767s6 -0.091007s6 -0.089247s6 -0.087488s6 -0.085730s6 -0.083972s6 -0.082214s6 -0.080458s6 -0.078701s6 -0.076945s6 -0.075190s6 -0.073435s6 -0.071680s6 -0.069926s6 -0.068173s6 -0.066419s6 -0.064667s6 -0.062914s6 -0.061162s6 -0.059410s6 -0.057659s6 -0.055908s6 -0.054158s6 -0.052407s6 -0.050657s6 -0.048908s6 -0.047158s6 -0.045409s6 -0.043660s6 -0.041912s6 -0.040164s6 -0.038416s6 -0.036668s6 -0.034920s6 -0.033173s6 -0.031426s6 -0.029679s6 -0.027932s6 -0.026185s6 -0.024439s6 -0.022693s6 -0.020947s6 -0.019200s6 -0.017455s6 -0.015709s6 -0.013963s6 -0.012217s6 -0.010472s6 -0.008726s6 -0.006981s6 -0.005236s6 -0.003490s6 -0.001745s6 -0.000000s6 0.001745s6 0.003490s6 0.005236s6 0.006981s6 0.008726s6 0.010472s6 0.012217s6 0.013963s6 0.015709s6 0.017455s6 0.019200s6 0.020947s6 0.022693s6 0.024439s6 0.026185s6 0.027932s6 0.029679s6 0.031426s6 0.033173s6 0.034920s6 0.036668s6 0.038416s6 0.040164s6 0.041912s6 0.043660s6 0.045409s6 0.047158s6 0.048908s6 0.050657s6 0.052407s6 0.054158s6 0.055908s6 0.057659s6 0.059410s6 0.061162s6 0.062914s6 0.064667s6 0.066419s6 0.068173s6 0.069926s6 0.071680s6 0.073435s6 0.075190s6 0.076945s6 0.078701s6 0.080458s6 0.082214s6 0.083972s6 0.085730s6 0.087488s6 0.089247s6 0.091007s6 0.092767s6 0.094527s6 0.096289s6 0.098050s6 0.099813s6 0.101576s6 0.103339s6 0.105104s6 0.106869s6 0.108634s6 0.110401s6 0.112167s6 0.113935s6 0.115703s6 0.117473s6 0.119242s6 0.121013s6 0.122784s6 0.124556s6 0.126329s6 0.128102s6 0.129877s6 0.131652s6 0.133428s6 0.135205s6 0.136982s6 0.138761s6 0.140540s6 0.142321s6 0.144102s6 0.145884s6 0.147667s6 0.149451s6 0.151235s6 0.153021s6 0.154808s6 0.156595s6 0.158384s6 0.160174s6 0.161964s6 0.163756s6 0.165548s6 0.167342s6 0.169137s6 0.170933s6 0.172729s6 0.174527s6 0.176326s6 0.178127s6 0.179928s6 0.181730s6 0.183534s6 0.185339s6 0.187144s6 0.188951s6 0.190760s6 0.192569s6 0.194380s6 0.196192s6 0.198005s6 0.199819s6 0.201635s6 0.203452s6 0.205270s6 0.207090s6 0.208910s6 0.210733s6 0.212556s6 0.214381s6 0.216207s6 0.218035s6 0.219864s6 0.221694s6 0.223526s6 0.225359s6 0.227194s6 0.229030s6 0.230868s6 0.232707s6 0.234547s6 0.236389s6 0.238233s6 0.240078s6 0.241925s6 0.243773s6 0.245623s6 0.247474s6 0.249328s6 0.251182s6 0.253038s6 0.254896s6 0.256756s6 0.258617s6 0.260480s6 0.262345s6 0.264211s6 0.266079s6 0.267949s6 0.269820s6 0.271693s6 0.273569s6 0.275445s6 0.277324s6 0.279205s6 0.281087s6 0.282971s6 0.284857s6 0.286745s6 0.288635s6 0.290526s6 0.292420s6 0.294316s6 0.296213s6 0.298112s6 0.300014s6 0.301917s6 0.303823s6 0.305730s6 0.307640s6 0.309551s6 0.311465s6 0.313381s6 0.315298s6 0.317218s6 0.319140s6 0.321064s6 0.322991s6 0.324919s6 0.326850s6 0.328783s6 0.330718s6 0.332655s6 0.334595s6 0.336537s6 0.338481s6 0.340427s6 0.342376s6 0.344327s6 0.346281s6 0.348236s6 0.350195s6 0.352155s6 0.354118s6 0.356083s6 0.358051s6 0.360022s6 0.361994s6 0.363970s6 0.365948s6 0.367928s6 0.369911s6 0.371896s6 0.373884s6 0.375875s6 0.377868s6 0.379864s6 0.381862s6 0.383864s6 0.385867s6 0.387874s6 0.389883s6 0.391895s6 0.393910s6 0.395928s6 0.397948s6 0.399971s6 0.401997s6 0.404026s6 0.406057s6 0.408092s6 0.410129s6 0.412170s6 0.414213s6 0.416259s6 0.418309s6 0.420361s6 0.422416s6 0.424474s6 0.426536s6 0.428600s6 0.430668s6 0.432738s6 0.434812s6 0.436889s6 0.438969s6 0.441052s6 0.443139s6 0.445228s6 0.447321s6 0.449417s6 0.451517s6 0.453620s6 0.455726s6 0.457835s6 0.459948s6 0.462064s6 0.464184s6 0.466307s6 0.468434s6 0.470564s6 0.472697s6 0.474834s6 0.476975s6 0.479119s6 0.481267s6 0.483418s6 0.485573s6 0.487732s6 0.489894s6 0.492061s6 0.494230s6 0.496404s6 0.498581s6 0.500762s6 0.502947s6 0.505136s6 0.507328s6 0.509525s6 0.511725s6 0.513930s6 0.516138s6 0.518350s6 0.520567s6 0.522787s6 0.525011s6 0.527240s6 0.529472s6 0.531709s6 0.533950s6 0.536195s6 0.538444s6 0.540697s6 0.542955s6 0.545217s6 0.547484s6 0.549754s6 0.552029s6 0.554309s6 0.556592s6 0.558881s6 0.561173s6 0.563471s6 0.565772s6 0.568079s6 0.570389s6 0.572705s6 0.575025s6 0.577350s6 0.579679s6 0.582013s6 0.584352s6 0.586696s6 0.589045s6 0.591398s6 0.593756s6 0.596119s6 0.598487s6 0.600860s6 0.603238s6 0.605621s6 0.608009s6 0.610402s6 0.612800s6 0.615204s6 0.617612s6 0.620026s6 0.622445s6 0.624869s6 0.627298s6 0.629733s6 0.632173s6 0.634619s6 0.637070s6 0.639526s6 0.641988s6 0.644456s6 0.646929s6 0.649407s6 0.651891s6 0.654381s6 0.656877s6 0.659378s6 0.661885s6 0.664398s6 0.666917s6 0.669441s6 0.671972s6 0.674508s6 0.677050s6 0.679599s6 0.682153s6 0.684714s6 0.687280s6 0.689853s6 0.692432s6 0.695018s6 0.697609s6 0.700207s6 0.702811s6 0.705422s6 0.708039s6 0.710663s6 0.713293s6 0.715929s6 0.718572s6 0.721222s6 0.723879s6 0.726542s6 0.729212s6 0.731889s6 0.734573s6 0.737263s6 0.739961s6 0.742665s6 0.745377s6 0.748095s6 0.750821s6 0.753554s6 0.756294s6 0.759041s6 0.761795s6 0.764557s6 0.767326s6 0.770103s6 0.772887s6 0.775679s6 0.778478s6 0.781285s6 0.784100s6 0.786922s6 0.789752s6 0.792590s6 0.795435s6 0.798289s6 0.801151s6 0.804020s6 0.806898s6 0.809784s6 0.812677s6 0.815580s6 0.818490s6 0.821409s6 0.824336s6 0.827271s6 0.830215s6 0.833168s6 0.836129s6 0.839099s6 0.842078s6 0.845065s6 0.848061s6 0.851066s6 0.854080s6 0.857103s6 0.860135s6 0.863176s6 0.866227s6 0.869286s6 0.872355s6 0.875433s6 0.878521s6 0.881618s6 0.884725s6 0.887841s6 0.890967s6 0.894103s6 0.897248s6 0.900404s6 0.903569s6 0.906744s6 0.909929s6 0.913125s6 0.916331s6 0.919547s6 0.922773s6 0.926010s6 0.929257s6 0.932515s6 0.935783s6 0.939062s6 0.942352s6 0.945652s6 0.948964s6 0.952287s6 0.955620s6 0.958965s6 0.962321s6 0.965688s6 0.969067s6 0.972457s6 0.975859s6 0.979272s6 0.982697s6 0.986133s6 0.989582s6 0.993042s6 0.996515s6 0.999999s6 1.003496s6 1.007005s6 1.010527s6 1.014061s6 1.017607s6 1.021166s6 1.024738s6 1.028322s6 1.031919s6 1.035530s6 1.039153s6 1.042790s6 1.046440s6 1.050103s6 1.053780s6 1.057470s6 1.061174s6 1.064891s6 1.068623s6 1.072368s6 1.076128s6 1.079901s6 1.083689s6 1.087491s6 1.091308s6 1.095139s6 1.098985s6 1.102846s6 1.106721s6 1.110612s6 1.114518s6 1.118439s6 1.122375s6 1.126327s6 1.130294s6 1.134277s6 1.138276s6 1.142290s6 1.146321s6 1.150368s6 1.154431s6 1.158511s6 1.162607s6 1.166720s6 1.170849s6 1.174996s6 1.179159s6 1.183340s6 1.187538s6 1.191753s6 1.195986s6 1.200237s6 1.204505s6 1.208792s6 1.213097s6 1.217419s6 1.221761s6 1.226121s6 1.230499s6 1.234897s6 1.239313s6 1.243749s6 1.248204s6 1.252678s6 1.257172s6 1.261685s6 1.266219s6 1.270773s6 1.275347s6 1.279941s6 1.284556s6 1.289192s6 1.293848s6 1.298526s6 1.303225s6 1.307945s6 1.312687s6 1.317451s6 1.322237s6 1.327044s6 1.331874s6 1.336727s6 1.341602s6 1.346501s6 1.351422s6 1.356367s6 1.361335s6 1.366326s6 1.371342s6 1.376381s6 1.381445s6 1.386534s6 1.391647s6 1.396785s6 1.401948s6 1.407136s6 1.412350s6 1.417590s6 1.422856s6 1.428148s6 1.433466s6 1.438811s6 1.444183s6 1.449582s6 1.455009s6 1.460463s6 1.465945s6 1.471455s6 1.476993s6 1.482560s6 1.488156s6 1.493782s6 1.499436s6 1.505120s6 1.510835s6 1.516579s6 1.522354s6 1.528160s6 1.533996s6 1.539864s6 1.545764s6 1.551696s6 1.557660s6 1.563656s6 1.569685s6 1.575747s6 1.581843s6 1.587973s6 1.594136s6 1.600334s6 1.606567s6 1.612834s6 1.619137s6 1.625476s6 1.631851s6 1.638262s6 1.644711s6 1.651196s6 1.657718s6 1.664279s6 1.670878s6 1.677515s6 1.684191s6 1.690907s6 1.697663s6 1.704458s6 1.711294s6 1.718172s6 1.725090s6 1.732050s6 1.739053s6 1.746098s6 1.753186s6 1.760318s6 1.767494s6 1.774714s6 1.781979s6 1.789289s6 1.796645s6 1.804047s6 1.811496s6 1.818993s6 1.826537s6 1.834129s6 1.841770s6 1.849461s6 1.857201s6 1.864992s6 1.872833s6 1.880726s6 1.888671s6 1.896668s6 1.904719s6 1.912823s6 1.920982s6 1.929195s6 1.937464s6 1.945789s6 1.954171s6 1.962610s6 1.971107s6 1.979663s6 1.988278s6 1.996953s6 2.005689s6 2.014486s6 2.023346s6 2.032268s6 2.041253s6 2.050303s6 2.059418s6 2.068599s6 2.077846s6 2.087161s6 2.096543s6 2.105995s6 2.115516s6 2.125108s6 2.134771s6 2.144506s6 2.154315s6 2.164198s6 2.174155s6 2.184189s6 2.194299s6 2.204487s6 2.214754s6 2.225100s6 2.235527s6 2.246036s6 2.256628s6 2.267303s6 2.278063s6 2.288909s6 2.299842s6 2.310863s6 2.321974s6 2.333174s6 2.344467s6 2.355852s6 2.367331s6 2.378905s6 2.390576s6 2.402345s6 2.414213s6 2.426181s6 2.438251s6 2.450425s6 2.462703s6 2.475086s6 2.487578s6 2.500178s6 2.512889s6 2.525711s6 2.538647s6 2.551699s6 2.564867s6 2.578153s6 2.591560s6 2.605089s6 2.618741s6 2.632518s6 2.646423s6 2.660456s6 2.674621s6 2.688918s6 2.703351s6 2.717920s6 2.732628s6 2.747477s6 2.762469s6 2.777606s6 2.792891s6 2.808326s6 2.823912s6 2.839653s6 2.855551s6 2.871608s6 2.887827s6 2.904210s6 2.920760s6 2.937480s6 2.954372s6 2.971439s6 2.988684s6 3.006110s6 3.023720s6 3.041517s6 3.059503s6 3.077683s6 3.096059s6 3.114635s6 3.133414s6 3.152399s6 3.171594s6 3.191003s6 3.210630s6 3.230478s6 3.250550s6 3.270852s6 3.291387s6 3.312159s6 3.333173s6 3.354433s6 3.375943s6 3.397708s6 3.419733s6 3.442022s6 3.464581s6 3.487414s6 3.510527s6 3.533925s6 3.557613s6 3.581597s6 3.605883s6 3.630477s6 3.655384s6 3.680611s6 3.706164s6 3.732050s6 3.758276s6 3.784848s6 3.811773s6 3.839059s6 3.866713s6 3.894742s6 3.923156s6 3.951961s6 3.981166s6 4.010780s6 4.040812s6 4.071270s6 4.102164s6 4.133504s6 4.165299s6 4.197560s6 4.230297s6 4.263521s6 4.297243s6 4.331475s6 4.366229s6 4.401516s6 4.437349s6 4.473742s6 4.510708s6 4.548260s6 4.586414s6 4.625183s6 4.664583s6 4.704630s6 4.745340s6 4.786730s6 4.828817s6 4.871620s6 4.915157s6 4.959447s6 5.004511s6 5.050369s6 5.097042s6 5.144554s6 5.192926s6 5.242183s6 5.292350s6 5.343452s6 5.395517s6 5.448571s6 5.502644s6 5.557766s6 5.613967s6 5.671281s6 5.729741s6 5.789382s6 5.850240s6 5.912355s6 5.975764s6 6.040510s6 6.106636s6 6.174186s6 6.243208s6 6.313751s6 6.385866s6 6.459607s6 6.535029s6 6.612191s6 6.691156s6 6.771986s6 6.854750s6 6.939519s6 7.026366s6 7.115369s6 7.206611s6 7.300178s6 7.396159s6 7.494651s6 7.595754s6 7.699573s6 7.806221s6 7.915815s6 8.028479s6 8.144346s6 8.263554s6 8.386251s6 8.512594s6 8.642747s6 8.776887s6 8.915200s6 9.057886s6 9.205156s6 9.357235s6 9.514364s6 9.676799s6 9.844816s6 10.018707s6 10.198788s6 10.385397s6 10.578894s6 10.779672s6 10.988150s6 11.204780s6 11.430052s6 11.664495s6 11.908682s6 12.163235s6 12.428831s6 12.706204s6 12.996159s6 13.299574s6 13.617408s6 13.950719s6 14.300666s6 14.668529s6 15.055722s6 15.463814s6 15.894544s6 16.349855s6 16.831914s6 17.343154s6 17.886310s6 18.464470s6 19.081136s6 19.740290s6 20.446486s6 21.204948s6 22.021710s6 22.903765s6 23.859277s6 24.897826s6 26.030735s6 27.271486s6 28.636253s6 30.144618s6 31.820515s6 33.693508s6 35.800553s6 38.188459s6 40.917411s6 44.066113s6 47.739501s6 52.080672s6 57.289961s6 63.656741s6 71.615070s6 81.847041s6 95.489475s6 114.588650s6 143.237121s6 190.984186s6 286.477734s6 572.957213s6 4082944682095961.000000s6 -572.957213s6 -286.477734s6 -190.984186s6 -143.237121s6 -114.588650s6 -95.489475s6 -81.847041s6 -71.615070s6 -63.656741s6 -57.289961s6 -52.080672s6 -47.739501s6 -44.066113s6 -40.917411s6 -38.188459s6 -35.800553s6 -33.693508s6 -31.820515s6 -30.144618s6 -28.636253s6 -27.271486s6 -26.030735s6 -24.897826s6 -23.859277s6 -22.903765s6 -22.021710s6 -21.204948s6 -20.446486s6 -19.740290s6 -19.081136s6 -18.464470s6 -17.886310s6 -17.343154s6 -16.831914s6 -16.349855s6 -15.894544s6 -15.463814s6 -15.055722s6 -14.668529s6 -14.300666s6 -13.950719s6 -13.617408s6 -13.299574s6 -12.996159s6 -12.706204s6 -12.428831s6 -12.163235s6 -11.908682s6 -11.664495s6 -11.430052s6 -11.204780s6 -10.988150s6 -10.779672s6 -10.578894s6 -10.385397s6 -10.198788s6 -10.018707s6 -9.844816s6 -9.676799s6 -9.514364s6 -9.357235s6 -9.205156s6 -9.057886s6 -8.915200s6 -8.776887s6 -8.642747s6 -8.512594s6 -8.386251s6 -8.263554s6 -8.144346s6 -8.028479s6 -7.915815s6 -7.806221s6 -7.699573s6 -7.595754s6 -7.494651s6 -7.396159s6 -7.300178s6 -7.206611s6 -7.115369s6 -7.026366s6 -6.939519s6 -6.854750s6 -6.771986s6 -6.691156s6 -6.612191s6 -6.535029s6 -6.459607s6 -6.385866s6 -6.313751s6 -6.243208s6 -6.174186s6 -6.106636s6 -6.040510s6 -5.975764s6 -5.912355s6 -5.850240s6 -5.789382s6 -5.729741s6 -5.671281s6 -5.613967s6 -5.557766s6 -5.502644s6 -5.448571s6 -5.395517s6 -5.343452s6 -5.292350s6 -5.242183s6 -5.192926s6 -5.144554s6 -5.097042s6 -5.050369s6 -5.004511s6 -4.959447s6 -4.915157s6 -4.871620s6 -4.828817s6 -4.786730s6 -4.745340s6 -4.704630s6 -4.664583s6 -4.625183s6 -4.586414s6 -4.548260s6 -4.510708s6 -4.473742s6 -4.437349s6 -4.401516s6 -4.366229s6 -4.331475s6 -4.297243s6 -4.263521s6 -4.230297s6 -4.197560s6 -4.165299s6 -4.133504s6 -4.102164s6 -4.071270s6 -4.040812s6 -4.010780s6 -3.981166s6 -3.951961s6 -3.923156s6 -3.894742s6 -3.866713s6 -3.839059s6 -3.811773s6 -3.784848s6 -3.758276s6 -3.732050s6 -3.706164s6 -3.680611s6 -3.655384s6 -3.630477s6 -3.605883s6 -3.581597s6 -3.557613s6 -3.533925s6 -3.510527s6 -3.487414s6 -3.464581s6 -3.442022s6 -3.419733s6 -3.397708s6 -3.375943s6 -3.354433s6 -3.333173s6 -3.312159s6 -3.291387s6 -3.270852s6 -3.250550s6 -3.230478s6 -3.210630s6 -3.191003s6 -3.171594s6 -3.152399s6 -3.133414s6 -3.114635s6 -3.096059s6 -3.077683s6 -3.059503s6 -3.041517s6 -3.023720s6 -3.006110s6 -2.988684s6 -2.971439s6 -2.954372s6 -2.937480s6 -2.920760s6 -2.904210s6 -2.887827s6 -2.871608s6 -2.855551s6 -2.839653s6 -2.823912s6 -2.808326s6 -2.792891s6 -2.777606s6 -2.762469s6 -2.747477s6 -2.732628s6 -2.717920s6 -2.703351s6 -2.688918s6 -2.674621s6 -2.660456s6 -2.646423s6 -2.632518s6 -2.618741s6 -2.605089s6 -2.591560s6 -2.578153s6 -2.564867s6 -2.551699s6 -2.538647s6 -2.525711s6 -2.512889s6 -2.500178s6 -2.487578s6 -2.475086s6 -2.462703s6 -2.450425s6 -2.438251s6 -2.426181s6 -2.414213s6 -2.402345s6 -2.390576s6 -2.378905s6 -2.367331s6 -2.355852s6 -2.344467s6 -2.333174s6 -2.321974s6 -2.310863s6 -2.299842s6 -2.288909s6 -2.278063s6 -2.267303s6 -2.256628s6 -2.246036s6 -2.235527s6 -2.225100s6 -2.214754s6 -2.204487s6 -2.194299s6 -2.184189s6 -2.174155s6 -2.164198s6 -2.154315s6 -2.144506s6 -2.134771s6 -2.125108s6 -2.115516s6 -2.105995s6 -2.096543s6 -2.087161s6 -2.077846s6 -2.068599s6 -2.059418s6 -2.050303s6 -2.041253s6 -2.032268s6 -2.023346s6 -2.014486s6 -2.005689s6 -1.996953s6 -1.988278s6 -1.979663s6 -1.971107s6 -1.962610s6 -1.954171s6 -1.945789s6 -1.937464s6 -1.929195s6 -1.920982s6 -1.912823s6 -1.904719s6 -1.896668s6 -1.888671s6 -1.880726s6 -1.872833s6 -1.864992s6 -1.857201s6 -1.849461s6 -1.841770s6 -1.834129s6 -1.826537s6 -1.818993s6 -1.811496s6 -1.804047s6 -1.796645s6 -1.789289s6 -1.781979s6 -1.774714s6 -1.767494s6 -1.760318s6 -1.753186s6 -1.746098s6 -1.739053s6 -1.732050s6 -1.725090s6 -1.718172s6 -1.711294s6 -1.704458s6 -1.697663s6 -1.690907s6 -1.684191s6 -1.677515s6 -1.670878s6 -1.664279s6 -1.657718s6 -1.651196s6 -1.644711s6 -1.638262s6 -1.631851s6 -1.625476s6 -1.619137s6 -1.612834s6 -1.606567s6 -1.600334s6 -1.594136s6 -1.587973s6 -1.581843s6 -1.575747s6 -1.569685s6 -1.563656s6 -1.557660s6 -1.551696s6 -1.545764s6 -1.539864s6 -1.533996s6 -1.528160s6 -1.522354s6 -1.516579s6 -1.510835s6 -1.505120s6 -1.499436s6 -1.493782s6 -1.488156s6 -1.482560s6 -1.476993s6 -1.471455s6 -1.465945s6 -1.460463s6 -1.455009s6 -1.449582s6 -1.444183s6 -1.438811s6 -1.433466s6 -1.428148s6 -1.422856s6 -1.417590s6 -1.412350s6 -1.407136s6 -1.401948s6 -1.396785s6 -1.391647s6 -1.386534s6 -1.381445s6 -1.376381s6 -1.371342s6 -1.366326s6 -1.361335s6 -1.356367s6 -1.351422s6 -1.346501s6 -1.341602s6 -1.336727s6 -1.331874s6 -1.327044s6 -1.322237s6 -1.317451s6 -1.312687s6 -1.307945s6 -1.303225s6 -1.298526s6 -1.293848s6 -1.289192s6 -1.284556s6 -1.279941s6 -1.275347s6 -1.270773s6 -1.266219s6 -1.261685s6 -1.257172s6 -1.252678s6 -1.248204s6 -1.243749s6 -1.239313s6 -1.234897s6 -1.230499s6 -1.226121s6 -1.221761s6 -1.217419s6 -1.213097s6 -1.208792s6 -1.204505s6 -1.200237s6 -1.195986s6 -1.191753s6 -1.187538s6 -1.183340s6 -1.179159s6 -1.174996s6 -1.170849s6 -1.166720s6 -1.162607s6 -1.158511s6 -1.154431s6 -1.150368s6 -1.146321s6 -1.142290s6 -1.138276s6 -1.134277s6 -1.130294s6 -1.126327s6 -1.122375s6 -1.118439s6 -1.114518s6 -1.110612s6 -1.106721s6 -1.102846s6 -1.098985s6 -1.095139s6 -1.091308s6 -1.087491s6 -1.083689s6 -1.079901s6 -1.076128s6 -1.072368s6 -1.068623s6 -1.064891s6 -1.061174s6 -1.057470s6 -1.053780s6 -1.050103s6 -1.046440s6 -1.042790s6 -1.039153s6 -1.035530s6 -1.031919s6 -1.028322s6 -1.024738s6 -1.021166s6 -1.017607s6 -1.014061s6 -1.010527s6 -1.007005s6 -1.003496s6 -1.000000s6 -0.996515s6 -0.993042s6 -0.989582s6 -0.986133s6 -0.982697s6 -0.979272s6 -0.975859s6 -0.972457s6 -0.969067s6 -0.965688s6 -0.962321s6 -0.958965s6 -0.955620s6 -0.952287s6 -0.948964s6 -0.945652s6 -0.942352s6 -0.939062s6 -0.935783s6 -0.932515s6 -0.929257s6 -0.926010s6 -0.922773s6 -0.919547s6 -0.916331s6 -0.913125s6 -0.909929s6 -0.906744s6 -0.903569s6 -0.900404s6 -0.897248s6 -0.894103s6 -0.890967s6 -0.887841s6 -0.884725s6 -0.881618s6 -0.878521s6 -0.875433s6 -0.872355s6 -0.869286s6 -0.866227s6 -0.863176s6 -0.860135s6 -0.857103s6 -0.854080s6 -0.851066s6 -0.848061s6 -0.845065s6 -0.842078s6 -0.839099s6 -0.836129s6 -0.833168s6 -0.830215s6 -0.827271s6 -0.824336s6 -0.821409s6 -0.818490s6 -0.815580s6 -0.812677s6 -0.809784s6 -0.806898s6 -0.804020s6 -0.801151s6 -0.798289s6 -0.795435s6 -0.792590s6 -0.789752s6 -0.786922s6 -0.784100s6 -0.781285s6 -0.778478s6 -0.775679s6 -0.772887s6 -0.770103s6 -0.767326s6 -0.764557s6 -0.761795s6 -0.759041s6 -0.756294s6 -0.753554s6 -0.750821s6 -0.748095s6 -0.745377s6 -0.742665s6 -0.739961s6 -0.737263s6 -0.734573s6 -0.731889s6 -0.729212s6 -0.726542s6 -0.723879s6 -0.721222s6 -0.718572s6 -0.715929s6 -0.713293s6 -0.710663s6 -0.708039s6 -0.705422s6 -0.702811s6 -0.700207s6 -0.697609s6 -0.695018s6 -0.692432s6 -0.689853s6 -0.687280s6 -0.684714s6 -0.682153s6 -0.679599s6 -0.677050s6 -0.674508s6 -0.671972s6 -0.669441s6 -0.666917s6 -0.664398s6 -0.661885s6 -0.659378s6 -0.656877s6 -0.654381s6 -0.651891s6 -0.649407s6 -0.646929s6 -0.644456s6 -0.641988s6 -0.639526s6 -0.637070s6 -0.634619s6 -0.632173s6 -0.629733s6 -0.627298s6 -0.624869s6 -0.622445s6 -0.620026s6 -0.617612s6 -0.615204s6 -0.612800s6 -0.610402s6 -0.608009s6 -0.605621s6 -0.603238s6 -0.600860s6 -0.598487s6 -0.596119s6 -0.593756s6 -0.591398s6 -0.589045s6 -0.586696s6 -0.584352s6 -0.582013s6 -0.579679s6 -0.577350s6 -0.575025s6 -0.572705s6 -0.570389s6 -0.568079s6 -0.565772s6 -0.563471s6 -0.561173s6 -0.558881s6 -0.556592s6 -0.554309s6 -0.552029s6 -0.549754s6 -0.547484s6 -0.545217s6 -0.542955s6 -0.540697s6 -0.538444s6 -0.536195s6 -0.533950s6 -0.531709s6 -0.529472s6 -0.527240s6 -0.525011s6 -0.522787s6 -0.520567s6 -0.518350s6 -0.516138s6 -0.513930s6 -0.511725s6 -0.509525s6 -0.507328s6 -0.505136s6 -0.502947s6 -0.500762s6 -0.498581s6 -0.496404s6 -0.494230s6 -0.492061s6 -0.489894s6 -0.487732s6 -0.485573s6 -0.483418s6 -0.481267s6 -0.479119s6 -0.476975s6 -0.474834s6 -0.472697s6 -0.470564s6 -0.468434s6 -0.466307s6 -0.464184s6 -0.462064s6 -0.459948s6 -0.457835s6 -0.455726s6 -0.453620s6 -0.451517s6 -0.449417s6 -0.447321s6 -0.445228s6 -0.443139s6 -0.441052s6 -0.438969s6 -0.436889s6 -0.434812s6 -0.432738s6 -0.430668s6 -0.428600s6 -0.426536s6 -0.424474s6 -0.422416s6 -0.420361s6 -0.418309s6 -0.416259s6 -0.414213s6 -0.412170s6 -0.410129s6 -0.408092s6 -0.406057s6 -0.404026s6 -0.401997s6 -0.399971s6 -0.397948s6 -0.395928s6 -0.393910s6 -0.391895s6 -0.389883s6 -0.387874s6 -0.385867s6 -0.383864s6 -0.381862s6 -0.379864s6 -0.377868s6 -0.375875s6 -0.373884s6 -0.371896s6 -0.369911s6 -0.367928s6 -0.365948s6 -0.363970s6 -0.361994s6 -0.360022s6 -0.358051s6 -0.356083s6 -0.354118s6 -0.352155s6 -0.350195s6 -0.348236s6 -0.346281s6 -0.344327s6 -0.342376s6 -0.340427s6 -0.338481s6 -0.336537s6 -0.334595s6 -0.332655s6 -0.330718s6 -0.328783s6 -0.326850s6 -0.324919s6 -0.322991s6 -0.321064s6 -0.319140s6 -0.317218s6 -0.315298s6 -0.313381s6 -0.311465s6 -0.309551s6 -0.307640s6 -0.305730s6 -0.303823s6 -0.301917s6 -0.300014s6 -0.298112s6 -0.296213s6 -0.294316s6 -0.292420s6 -0.290526s6 -0.288635s6 -0.286745s6 -0.284857s6 -0.282971s6 -0.281087s6 -0.279205s6 -0.277324s6 -0.275445s6 -0.273569s6 -0.271693s6 -0.269820s6 -0.267949s6 -0.266079s6 -0.264211s6 -0.262345s6 -0.260480s6 -0.258617s6 -0.256756s6 -0.254896s6 -0.253038s6 -0.251182s6 -0.249328s6 -0.247474s6 -0.245623s6 -0.243773s6 -0.241925s6 -0.240078s6 -0.238233s6 -0.236389s6 -0.234547s6 -0.232707s6 -0.230868s6 -0.229030s6 -0.227194s6 -0.225359s6 -0.223526s6 -0.221694s6 -0.219864s6 -0.218035s6 -0.216207s6 -0.214381s6 -0.212556s6 -0.210733s6 -0.208910s6 -0.207090s6 -0.205270s6 -0.203452s6 -0.201635s6 -0.199819s6 -0.198005s6 -0.196192s6 -0.194380s6 -0.192569s6 -0.190760s6 -0.188951s6 -0.187144s6 -0.185339s6 -0.183534s6 -0.181730s6 -0.179928s6 -0.178127s6 -0.176326s6 -0.174527s6 -0.172729s6 -0.170933s6 -0.169137s6 -0.167342s6 -0.165548s6 -0.163756s6 -0.161964s6 -0.160174s6 -0.158384s6 -0.156595s6 -0.154808s6 -0.153021s6 -0.151235s6 -0.149451s6 -0.147667s6 -0.145884s6 -0.144102s6 -0.142321s6 -0.140540s6 -0.138761s6 -0.136982s6 -0.135205s6 -0.133428s6 -0.131652s6 -0.129877s6 -0.128102s6 -0.126329s6 -0.124556s6 -0.122784s6 -0.121013s6 -0.119242s6 -0.117473s6 -0.115703s6 -0.113935s6 -0.112167s6 -0.110401s6 -0.108634s6 -0.106869s6 -0.105104s6 -0.103339s6 -0.101576s6 -0.099813s6 -0.098050s6 -0.096289s6 -0.094527s6 -0.092767s6 -0.091007s6 -0.089247s6 -0.087488s6 -0.085730s6 -0.083972s6 -0.082214s6 -0.080458s6 -0.078701s6 -0.076945s6 -0.075190s6 -0.073435s6 -0.071680s6 -0.069926s6 -0.068173s6 -0.066419s6 -0.064667s6 -0.062914s6 -0.061162s6 -0.059410s6 -0.057659s6 -0.055908s6 -0.054158s6 -0.052407s6 -0.050657s6 -0.048908s6 -0.047158s6 -0.045409s6 -0.043660s6 -0.041912s6 -0.040164s6 -0.038416s6 -0.036668s6 -0.034920s6 -0.033173s6 -0.031426s6 -0.029679s6 -0.027932s6 -0.026185s6 -0.024439s6 -0.022693s6 -0.020947s6 -0.019200s6 -0.017455s6 -0.015709s6 -0.013963s6 -0.012217s6 -0.010472s6 -0.008726s6 -0.006981s6 -0.005236s6 -0.003490s6 -0.001745s6)! !!AvTrigonometryHelper class methodsFor: 'trigonometry-support' stamp: 'Jon 1/26/2006 12:19'!sinTable	"AvTrigonometryHelper sinTable"	SinTable isNil		ifTrue: [self initializeSinTable].	^SinTable! !!AvTrigonometryHelper class methodsFor: 'trigonometry-support' stamp: 'Jon 1/26/2006 12:20'!tanTable	"AvTrigonometryHelper tanTable"	TanTable isNil		ifTrue: [self initializeTanTable].	^TanTable! !Object subclass: #AvUncertainNumber	instanceVariableNames: 'value confidence'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!!AvUncertainNumber commentStamp: 'jon 11/4/2004 08:39' prior: 0!An AvUncertainNumber is a number that has an associated confidence, which is a percentage value.Instance Variables:value			<Number>confidence		<Float>value	- the real numberconfidence	- a measure of our confidence in the accuracy and correctness of value	- a Float between 0.0 and 1.0	- 0.0 would represent a value that we have no confidence in	- 1.0 would represent a value that we have total confidence in!AvPosition subclass: #AvVelocity	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Support'!!AvVelocity commentStamp: '<historical>' prior: 0!An AvVelocity represents a two-dimensional vector with direction and magnitude.!!AvVelocity methodsFor: 'printing' stamp: 'jon 10/16/2004 20:04'!printOn: aStream	aStream nextPut: $<.	(mapPoint x roundTo: 0.01) printOn: aStream precision: 2.	aStream nextPutAll: ' @ '.	(mapPoint y roundTo: 0.01) printOn: aStream precision: 2.	aStream nextPut: $>! !ExternalObject subclass: #AvFrameCapture	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Vision'!!AvFrameCapture commentStamp: 'Jon 12/28/2005 07:20' prior: 0!AvFrameCapture is a simple interface to Framecap (http://www.robin-hewitt.com/framecap) using FFI.!!AvFrameCapture methodsFor: 'private' stamp: 'Jon 10/31/2005 22:41'!getFrameSize	<apicall: long 'getFrameSize' (void) module: 'fgclient.dll'>	^self externalCallFailed! !!AvFrameCapture methodsFor: 'private' stamp: 'Jon 11/1/2005 09:52'!getHeight	<apicall: long 'getHeight' (void) module:'fgclient.dll'>	^self externalCallFailed! !!AvFrameCapture methodsFor: 'private' stamp: 'Jon 11/1/2005 09:52'!getImage: bytes size: size	<apicall: long 'getFrame' (byte* long) module: 'fgclient.dll'>	^self externalCallFailed! !!AvFrameCapture methodsFor: 'private' stamp: 'Jon 11/1/2005 09:52'!getWidth	<apicall: long 'getWidth' (void) module: 'fgclient.dll'>	^self externalCallFailed! !!AvFrameCapture methodsFor: 'frame capture' stamp: 'Jon 12/28/2005 07:18'!captureFrame	"AvFrameCapture captureFrame"	"Note - assumes 320 x 240 webcam..."	| bytes size bits byteArray |	size := self new getFrameSize.	bytes := ByteArray new: size.	self new getImage: bytes size: size.	bits := Bitmap new: 320 * 240.	byteArray := ByteArray new: 320 * 240 * 4.	0 to: 320 * 240 - 1 do: [:eachIndex |		| firstIndex secondIndex |		firstIndex := eachIndex * 3 + 1.		secondIndex := ((320 * 240) - eachIndex - 1) * 4 + 1.		byteArray			at: secondIndex put: 255;			at: secondIndex + 1 put: (bytes at: firstIndex);			at: secondIndex + 2 put: (bytes at: firstIndex + 1);			at: secondIndex + 3 put: (bytes at: firstIndex + 2)].	bits copyFromByteArray: byteArray.	^Form extent: 320 @ 240 depth: 32 bits: bits! !Object subclass: #AvImageProcessor	instanceVariableNames: 'originalImage'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Vision'!!AvImageProcessor methodsFor: 'accessing' stamp: 'jon 10/11/2004 18:08'!originalImage	"Answer the value of originalImage"	^ originalImage! !!AvImageProcessor methodsFor: 'accessing' stamp: 'jon 10/11/2004 18:08'!originalImage: anObject	"Set the value of originalImage"	originalImage _ anObject! !!AvImageProcessor methodsFor: 'image processing' stamp: 'Jon 1/20/2005 10:06'!edgeEnhance	| resultForm width height |	resultForm := Form extent: originalImage extent depth: originalImage depth.	width := originalImage width.	height := originalImage height.	2 to: height - 1 do: [:yIndex |		2 to: width - 1 do: [:xIndex |			| a b c d e f g h horizontal vertical color |			a := (originalImage colorAt: (xIndex - 1) @ (yIndex - 1)) brightness.			b := (originalImage colorAt: xIndex @ (yIndex - 1)) brightness.			c := (originalImage colorAt: (xIndex + 1) @ (yIndex - 1)) brightness.			d := (originalImage colorAt: (xIndex - 1) @ yIndex) brightness.			e := (originalImage colorAt: (xIndex + 1) @ yIndex) brightness.			f := (originalImage colorAt: (xIndex - 1) @ (yIndex + 1)) brightness.			g := (originalImage colorAt: xIndex @ (yIndex + 1)) brightness.			h := (originalImage colorAt: (xIndex + 1) @ (yIndex + 1)) brightness.			horizontal := ((a + d + f) - (c + e + h)) abs.			vertical := ((a + b + c) - (f + g + h)) abs.			color := Color gray: (horizontal + vertical min: 1.0).			resultForm colorAt: xIndex @ yIndex put: color]].	^resultForm! !!AvImageProcessor methodsFor: 'image processing' stamp: 'jon 10/11/2004 18:54'!findHorizonLine	| form rowAverages stream done baseline darkBaseline changeRow lightBaseline|	form := originalImage deepCopy.	rowAverages := OrderedCollection new.	0 to: form height - 1 do: [:eachY |		| rowPixel |		rowPixel := 0.		0 to: form width - 1 do: [:eachX |			rowPixel := rowPixel + (form pixelValueAt: eachX @ eachY)].		rowAverages add: rowPixel // form width].	stream := ReadStream on: (rowAverages size to: 1 by: -1).	done := false.	stream next: 20.	baseline := ((stream next: 5) collect: [:each | rowAverages at: each])		average asInteger.	darkBaseline := baseline - 30.	lightBaseline := baseline + 100.	[stream atEnd | done] whileFalse: [		| next |		next := stream next.		done := (rowAverages at: next) < darkBaseline |			((rowAverages at: next) > lightBaseline)].	changeRow := stream atEnd		ifTrue: [0]		ifFalse: [stream next].	^form		fill: (0 @ changeRow extent: form width @ 2)		fillColor: Color red! !!AvImageProcessor methodsFor: 'image processing' stamp: 'jon 10/11/2004 19:54'!findVerticalPole	| form columnAverages grouped verticalLines |	form := originalImage deepCopy.	columnAverages := OrderedCollection new.	0 to: form width - 1 do: [:eachX |		| columnPixel |		columnPixel := 0.		0 to: form height // 2 do: [:eachY |			columnPixel := columnPixel + (form pixelValueAt: eachX @ eachY)].		columnAverages add: columnPixel // form height].	grouped := columnAverages groupsOf: 10 atATimeCollect: [:eachSet | eachSet average asInteger].	verticalLines := OrderedCollection new.	1 to: grouped size - 1 do: [:index |		| first second |		first := grouped at: index.		second := grouped at: index + 1.		(first - second) abs > 15			ifTrue: [verticalLines add: index * 10]].	verticalLines do: [:eachX |		form fillWhite: (eachX @ 0 extent: 2 @ form height)].	^form! !!AvImageProcessor methodsFor: 'image processing' stamp: 'jon 10/11/2004 19:24'!openMorphWithGrid	| form |	form := originalImage deepCopy.	10 to: form width - 10 by: 10 do: [:eachX |		form fillBlack: (eachX @ 0 extent: 1 @ form height)].	10 to: form height - 10 by: 10 do: [:eachY |		form fillBlack: (0 @ eachY extent: form width @ 1)].	ImageMorph new		image: form;		openInWorld! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvImageProcessor class	instanceVariableNames: ''!!AvImageProcessor class methodsFor: 'instance creation' stamp: 'jon 10/11/2004 18:06'!fromFilename: filename	^self fromForm: (Form fromFileNamed: filename)! !!AvImageProcessor class methodsFor: 'instance creation' stamp: 'jon 10/11/2004 18:06'!fromForm: aForm	^self new		originalImage: aForm;		yourself! !Object subclass: #AvSimulatedClodBusterVehicle	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-Simulation'!Morph subclass: #AvAckermanSImulator	instanceVariableNames: 'kingpinSeparation tieRodLength axleToTieRodSeparation leftWheelAngle rightWheelAngle wheelbase'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-UI'!!AvAckermanSImulator methodsFor: 'initializing' stamp: 'jon 11/2/2004 11:35'!initialize	kingpinSeparation := 184.	tieRodLength := 148.	axleToTieRodSeparation := 36.	wheelbase := 184.	leftWheelAngle := 0.	super initialize! !!AvAckermanSImulator methodsFor: 'drawing' stamp: 'jon 11/2/2004 13:12'!drawOn: aCanvas	| origin leftKingpin rightKingpin halfTrack leftTieRodEnd rightTieRodEnd tieRodInset |	origin := self drawOrigin.	leftKingpin := origin.	rightKingpin := origin + (kingpinSeparation @ 0).	halfTrack := kingpinSeparation / 2.0.	tieRodInset := axleToTieRodSeparation * (halfTrack / wheelbase).	leftTieRodEnd := origin + (tieRodInset @ axleToTieRodSeparation).	leftTieRodEnd := leftTieRodEnd rotateBy: leftWheelAngle degreesToRadians negated about: leftKingpin.	rightTieRodEnd  := self rightTieRodEnd.	aCanvas		fillRectangle: self bounds color: Color white;		drawPolygon: {leftKingpin . rightKingpin . rightTieRodEnd . leftTieRodEnd}		color: Color white		borderWidth: 1		borderColor: Color black;		line: (origin + (0 @ wheelbase))		to: (origin + (kingpinSeparation @ wheelbase))		color: Color black.	self		drawWheelLinesAt: leftKingpin turnAngle: leftWheelAngle negated on: aCanvas! !!AvAckermanSImulator methodsFor: 'drawing' stamp: 'jon 11/2/2004 12:21'!drawOrigin	^self bounds origin + (50 @ 50)! !!AvAckermanSImulator methodsFor: 'drawing' stamp: 'jon 11/2/2004 12:05'!drawWheelLinesAt: location turnAngle: turnAngle on: aCanvas	| lineHalfLength wheelLine axleLine turnRadians |	lineHalfLength := 15.	wheelLine := Array		with: location + (0 @ lineHalfLength)		with: location - (0 @ lineHalfLength).	axleLine := Array		with: location - (lineHalfLength @ 0)		with: location + (lineHalfLength @ 0).	turnRadians := turnAngle degreesToRadians.	wheelLine := wheelLine collect: [:each |		each rotateBy: turnRadians about: location].	axleLine := axleLine collect: [:each |		each rotateBy: turnRadians about: location].	aCanvas		drawPolygon: wheelLine color: Color white borderWidth: 1 borderColor: Color blue;		drawPolygon: axleLine color: Color white borderWidth: 1 borderColor: Color red! !!AvAckermanSImulator methodsFor: 'drawing' stamp: 'jon 11/2/2004 13:13'!rightTieRodEnd	| origin leftKingpin rightKingpin halfTrack leftTieRodEnd tieRodInset r0 r1 d a h p2 p3 baseTieRodAngle |	origin := self drawOrigin.	leftKingpin := origin.	rightKingpin := origin + (kingpinSeparation @ 0).	halfTrack := kingpinSeparation / 2.0.	tieRodInset := axleToTieRodSeparation * (halfTrack / wheelbase).	leftTieRodEnd := origin + (tieRodInset @ axleToTieRodSeparation).	baseTieRodAngle := 180 - (leftKingpin bearingToPoint: leftTieRodEnd).	leftTieRodEnd := leftTieRodEnd rotateBy: leftWheelAngle degreesToRadians negated about: leftKingpin.	leftWheelAngle = 0		ifTrue: [			rightWheelAngle := 0.			^origin + ((kingpinSeparation - tieRodInset) @ axleToTieRodSeparation)].	r0 := tieRodLength.	r1 := (tieRodInset squared +  axleToTieRodSeparation squared) sqrt.	d := leftTieRodEnd dist: rightKingpin.	a := (r0 squared - r1 squared + d squared) / (2 * d).	h := (r0 squared - a squared) abs sqrt.	p2 := leftTieRodEnd + ((a * (rightKingpin - leftTieRodEnd)) / d).	p3 := (p2 x - ((h * (rightKingpin y - leftTieRodEnd y)) / d)) @ (p2 y + ((h * (rightKingpin x - leftTieRodEnd x)) / d)).	rightWheelAngle := (rightKingpin bearingToPoint: p3) -  baseTieRodAngle - 180.		^p3! !Morph subclass: #AvCompassMorph	instanceVariableNames: 'heading'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-UI'!!AvCompassMorph methodsFor: 'initializing' stamp: 'jon 11/16/2004 15:44'!initialize	super initialize.	heading := 0.0.! !!AvCompassMorph methodsFor: 'accessing' stamp: 'jon 11/16/2004 17:36'!heading	^heading! !!AvCompassMorph methodsFor: 'accessing' stamp: 'jon 11/16/2004 17:36'!heading: aNumber	heading := aNumber! !!AvCompassMorph methodsFor: 'drawing' stamp: 'jon 11/16/2004 16:21'!drawOn: aCanvas	| center end box |	aCanvas		fillOval: self bounds		color: Color white		borderWidth: 1		borderColor: Color black.	self drawTextOn: aCanvas.	center := self bounds center.	end := center + (Point r: self width // 3 degrees: heading - 90).	aCanvas		line: center		to: end		width: 3		color: Color black.	aCanvas		fillOval: (self bounds insetBy: (self width // 3))		color: Color gray		borderWidth: 1		borderColor: Color black.	aCanvas		fillOval: (self bounds insetBy: (self width // 2.75))		color: Color white		borderWidth: 1		borderColor: Color black.	box := (0 @ 0 extent: 30 @ 15) align: 15 @ 7 with: center.	aCanvas		drawString: (heading rounded printPaddedWith: $0 to: 3), ''		in: box.! !!AvCompassMorph methodsFor: 'drawing' stamp: 'jon 11/16/2004 16:09'!drawTextOn: canvas	canvas		drawString: 'N'		at: (self bounds topCenter - (4 @ -2));		drawString: 'S'		at: (self bounds bottomCenter - (4 @ 18));		drawString: 'E'		at: (self bounds rightCenter - (16 @ 4));		drawString: 'W'		at: (self bounds leftCenter - (-4 @ 4));		yourself! !!AvCompassMorph methodsFor: 'event handling' stamp: 'jon 11/16/2004 17:01'!handleCenterHit: event	self world canvas		fillOval: (self bounds insetBy: self width // 2.75)		color: Color gray		borderWidth: 1		borderColor: Color black.	Sensor waitNoButton.	self		triggerEvent: #gotHeading with: heading rounded;		delete.! !!AvCompassMorph methodsFor: 'event handling' stamp: 'jon 11/16/2004 16:19'!handlesMouseDown: event	^ true! !!AvCompassMorph methodsFor: 'event handling' stamp: 'jon 11/16/2004 16:32'!mouseDown: event	| point |	point := event cursorPoint - bounds center.	point r < (self width // 6)		ifTrue: [^self handleCenterHit: event].	heading := (point theta radiansToDegrees + 90) \\ 360.	self changed.! !!AvCompassMorph methodsFor: 'event handling' stamp: 'jon 11/16/2004 16:20'!mouseMove: event	self mouseDown: event! !Object subclass: #AvCompassPicTester	instanceVariableNames: 'serialPort'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-UI'!!AvCompassPicTester methodsFor: 'morph creation' stamp: 'Jon 1/14/2006 18:41'!buttonMorphOn: button label: label	^(PluggableButtonMorph on: button)		useRoundedCorners;		hResizing: #spaceFill;		borderWidth: 2;		borderRaised;		feedbackColor: Color darkGray;		label: label;		color: Color veryLightGray;		yourself! !!AvCompassPicTester methodsFor: 'morph creation' stamp: 'Jon 1/14/2006 18:42'!buttonMorphOnSelector: selector label: label	^self		buttonMorphOn: (Button newOff onAction: [self perform: selector]; yourself)		label: label.! !!AvCompassPicTester methodsFor: 'morph creation' stamp: 'Jon 1/14/2006 19:14'!closePort	serialPort notNil		ifTrue: [			serialPort close.			serialPort := nil].! !!AvCompassPicTester methodsFor: 'morph creation' stamp: 'Jon 1/14/2006 19:33'!createView	| window |	(window := SystemWindowWithButton labelled: 'Mission Editor')		color: Color white;		allowReframeHandles: false;		model: self.	window		addMorph: (self buttonMorphOnSelector: #resetPort label: 'Reset Port')		fullFrame: (LayoutFrame 			fractions: (0@0 corner: 0.3@0.6) 			offsets: (5@5 corner: -5@-5)).	window		addMorph: (self buttonMorphOnSelector: #closePort label: 'Close Port')		fullFrame: (LayoutFrame 			fractions: (0.3@0 corner: 0.6@0.6) 			offsets: (5@5 corner: -5@-5)).	window		addMorph: (self buttonMorphOnSelector: #sendCommand label: 'Send Command')		fullFrame: (LayoutFrame 			fractions: (0.6@0 corner: 1@0.6) 			offsets: (5@5 corner: -5@-5)).	window openInWorldExtent: 350 @ 90.! !!AvCompassPicTester methodsFor: 'morph creation' stamp: 'Jon 1/14/2006 18:43'!resetPort	serialPort notNil		ifTrue: [serialPort close].	serialPort := SerialPort new		baudRate: 19200;		dataBits: 8;		stopBitsType: 1;		parityType: 0;		yourself.	(serialPort openPort: 1) isNil		ifTrue: [self error: 'Serial Port 1 Unavailable...'].! !!AvCompassPicTester methodsFor: 'morph creation' stamp: 'Jon 1/14/2006 19:36'!sendCommand	serialPort readByteArray.	1 to: 40 do: [:index |		| bytes |		serialPort nextPutAll: 'H'.		(Delay forMilliseconds: 10) wait.		bytes := serialPort readByteArray.		bytes isEmpty			ifTrue: [Transcript cr; show: index printString, ' - no response']			ifFalse: [				| left right heading |				heading := bytes unsignedShortAt: 1 bigEndian: false.				left := bytes unsignedShortAt: 5 bigEndian: false.				right := bytes unsignedShortAt: 7 bigEndian: false.				Transcript cr; show: index printString, ': heading: ', heading printString, ' left: ', left printString, ' right: ', right printString].		(Delay forMilliseconds: 200) wait].! !!AvCompassPicTester methodsFor: 'morph creation' stamp: 'Jon 1/14/2006 19:19'!serialPortStatus	^serialPort isNil		ifTrue: ['closed']		ifFalse: [			serialPort isConnected				ifTrue: ['ready']				ifFalse: ['bad state']].! !ListItemWrapper subclass: #AvGoalWrapper	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Av-UI'!!AvGoalWrapper methodsFor: 'accessing' stamp: 'jon 11/21/2004 22:49'!asString	| navigatorName |	navigatorName := item navigator isNil		ifTrue: ['']		ifFalse: [' (', item navigator class simpleDescriptiveName, ')'].	^item name, navigatorName! !!AvGoalWrapper methodsFor: 'accessing' stamp: 'jon 11/21/2004 22:27'!contents	^item subGoals collect: [:eachGoal |		self class with: eachGoal]! !!AvGoalWrapper methodsFor: 'accessing' stamp: 'jon 11/21/2004 22:41'!goal	^item! !Morph subclass: #AvGpsGaugeMorph	instanceVariableNames: 'sensor'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-UI'!!AvGpsGaugeMorph methodsFor: 'accessing' stamp: 'jon 10/23/2004 09:09'!coordinateColor	^self gpsCoordinate isValid		ifTrue: [Color blue muchDarker]		ifFalse: [Color red]! !!AvGpsGaugeMorph methodsFor: 'accessing' stamp: 'jon 10/24/2004 08:08'!gpsCoordinate	| coordinate |	sensor notNil		ifTrue: [coordinate := sensor gpsCoordinate].	^coordinate isNil		ifTrue: [(AvGpsCoordinate latitude: 0 longitude: 0) makeInvalid; yourself]		ifFalse: [coordinate]! !!AvGpsGaugeMorph methodsFor: 'accessing' stamp: 'jon 10/23/2004 09:01'!sensor: avGpsSensor	sensor := avGpsSensor! !!AvGpsGaugeMorph methodsFor: 'drawing' stamp: 'jon 10/24/2004 08:05'!drawCoordinatesOn: aCanvas	| coordinate box gpsBox font width string |	box := self bounds.	font := self textFont.	coordinate := self gpsCoordinate.	string := coordinate latitudeString.	width := font widthOfString: string.	gpsBox := 0 @ 0 extent: width @ 20.	gpsBox := gpsBox align: gpsBox bottomCenter with: box center.	aCanvas		drawString: string		in: gpsBox		font: font		color: self coordinateColor.	string := coordinate longitudeString.	width := font widthOfString: string.	gpsBox := 0 @ 0 extent: width @ 20.	gpsBox := gpsBox align: gpsBox bottomCenter with: box center.	aCanvas		drawString: string		in: (gpsBox translateBy: 0 @ 20)		font: font		color: self coordinateColor! !!AvGpsGaugeMorph methodsFor: 'drawing' stamp: 'jon 10/23/2004 08:51'!drawLabelTextOn: aCanvas	| box gpsBox font width |	box := self bounds.	font := self gpsFont.	width := font widthOfString: 'GPS'.	gpsBox := (0 @ 0 extent: width @ 20)		align: (width // 2) @ -15		with: box topCenter.	aCanvas		drawString: 'GPS'		in: gpsBox		font: font		color: Color green muchDarker! !!AvGpsGaugeMorph methodsFor: 'drawing' stamp: 'jon 10/23/2004 09:04'!drawOn: aCanvas	| box |	box := self bounds.	aCanvas		fillOval: box		color: Color white		borderWidth: 1		borderColor: Color black.	self		drawLabelTextOn: aCanvas;		drawCoordinatesOn: aCanvas;		drawUncertaintyOn: aCanvas! !!AvGpsGaugeMorph methodsFor: 'drawing' stamp: 'jon 10/24/2004 08:36'!drawUncertaintyOn: aCanvas	| coordinate box gpsBox font width string |	box := self bounds.	font := self textFont.	coordinate := sensor isNil		ifTrue: [nil]		ifFalse: [sensor gpsCoordinate].	string := coordinate isNil		ifTrue: ['no signal']		ifFalse: ['accuracy: ', (coordinate uncertainty roundTo: 0.1) printString, ' M'].	width := font widthOfString: string.	gpsBox := 0 @ 0 extent: width @ 20.	gpsBox := gpsBox align: gpsBox bottomCenter with: (box center + (0 @ 50)).	aCanvas		drawString: string		in: gpsBox		font: font		color: Color blue muchDarker! !!AvGpsGaugeMorph methodsFor: 'drawing' stamp: 'jon 10/23/2004 08:36'!gpsFont	^StrikeFont familyName: 'BitstreamVeraSansBoldOblique' size: 21! !!AvGpsGaugeMorph methodsFor: 'drawing' stamp: 'jon 10/23/2004 08:51'!textFont	^StrikeFont familyName: 'BitstreamVeraSansBoldOblique' size: 15! !!AvGpsGaugeMorph methodsFor: 'stepping' stamp: 'jon 10/23/2004 08:54'!step	self changed! !!AvGpsGaugeMorph methodsFor: 'stepping' stamp: 'jon 10/23/2004 08:54'!stepTime	^1000! !!AvGpsGaugeMorph methodsFor: 'stepping' stamp: 'jon 10/23/2004 08:54'!wantsSteps	^sensor notNil! !!AvGpsGaugeMorph methodsFor: 'releasing' stamp: 'jon 10/24/2004 08:42'!delete	sensor notNil		ifTrue: [sensor stop].	^super delete! !Morph subclass: #AvGyroMorph	instanceVariableNames: 'yawFilter'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-UI'!!AvGyroMorph methodsFor: 'accessing' stamp: 'jon 11/23/2004 13:34'!heading	^yawFilter heading! !!AvGyroMorph methodsFor: 'accessing' stamp: 'jon 11/23/2004 13:48'!setZero	yawFilter setZero.	self changed.! !!AvGyroMorph methodsFor: 'accessing' stamp: 'Jon 11/24/2004 19:47'!yawFilter	^yawFilter! !!AvGyroMorph methodsFor: 'accessing' stamp: 'jon 11/23/2004 13:33'!yawFilter: anAvYawFilter	yawFilter := anAvYawFilter! !!AvGyroMorph methodsFor: 'drawing' stamp: 'Jon 11/24/2004 20:18'!drawOn: aCanvas	| center end box |	aCanvas		fillOval: self bounds		color: Color white		borderWidth: 1		borderColor: Color black.	self drawTextOn: aCanvas.	center := self bounds center.	end := center + (Point r: self width // 3 degrees: self heading - 90).	aCanvas		line: center		to: end		width: 3		color: Color black.	aCanvas		fillOval: (self bounds insetBy: (self width // 3))		color: Color gray		borderWidth: 1		borderColor: Color black.	aCanvas		fillOval: (self bounds insetBy: (self width // 2.75))		color: Color white		borderWidth: 1		borderColor: Color black.	box := (0 @ 0 extent: 30 @ 15) align: 15 @ 7 with: center.	aCanvas		drawString: (self heading rounded printPaddedWith: $  to: 3), ''		in: box.! !!AvGyroMorph methodsFor: 'drawing' stamp: 'jon 11/23/2004 13:34'!drawTextOn: canvas	canvas		drawString: 'N'		at: (self bounds topCenter - (4 @ -2));		drawString: 'S'		at: (self bounds bottomCenter - (4 @ 18));		drawString: 'E'		at: (self bounds rightCenter - (16 @ 4));		drawString: 'W'		at: (self bounds leftCenter - (-4 @ 4));		yourself! !!AvGyroMorph methodsFor: 'stepping' stamp: 'jon 11/23/2004 13:36'!step	self changed.	^super step.! !!AvGyroMorph methodsFor: 'stepping' stamp: 'jon 11/23/2004 13:36'!stepTime	^100! !!AvGyroMorph methodsFor: 'stepping' stamp: 'jon 11/23/2004 13:36'!wantsSteps	^true! !Object subclass: #AvGyroTestWindow	instanceVariableNames: 'yawGyroMorph vehicle gyro window'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-UI'!!AvGyroTestWindow methodsFor: 'initializing' stamp: 'Jon 11/24/2004 21:21'!initialize	vehicle := AvVehicle fromFilename: 'devices\Drone.txt'.	gyro := vehicle sensorNamed: 'gyro'.	super initialize.! !!AvGyroTestWindow methodsFor: 'accessing' stamp: 'Jon 11/24/2004 19:48'!vehicleStatus	^vehicle motionModel isRunning		ifTrue: [yawGyroMorph yawFilter updateCount printString]		ifFalse: ['Stopped'].! !!AvGyroTestWindow methodsFor: 'morph creation' stamp: 'jon 11/23/2004 15:00'!buttonMorphOn: button label: label	^(PluggableButtonMorph on: button)		useRoundedCorners;		hResizing: #spaceFill;		borderWidth: 2;		borderRaised;		feedbackColor: Color darkGray;		label: label;		color: Color veryLightGray;		yourself! !!AvGyroTestWindow methodsFor: 'morph creation' stamp: 'jon 11/23/2004 15:00'!buttonMorphOnSelector: selector label: label	^self		buttonMorphOn: (Button newOff onAction: [self perform: selector]; yourself)		label: label.! !!AvGyroTestWindow methodsFor: 'morph creation' stamp: 'jon 11/23/2004 14:50'!buttonsMorph	| panelMorph |	panelMorph := AlignmentMorph new		listDirection: #topToBottom;		color: Color white;		yourself.	^panelMorph		addMorphBack: (self			buttonMorphOnSelector: #startVehicle			label: 'Start Vehicle');		addMorphBack: (self newVerticalSpacer: 2);		addMorphBack: (self			buttonMorphOnSelector: #stopVehicle			label: 'Stop Vehicle');		addMorphBack: (self newVerticalSpacer: 10);		addMorphBack: (self			buttonMorphOnSelector: #zeroGyro			label: 'Zero Gyro');		yourself.! !!AvGyroTestWindow methodsFor: 'morph creation' stamp: 'jon 11/23/2004 15:43'!createView	| statusMorph |	(window := SystemWindowWithButton labelled: 'Yaw Gyro Test')		color: Color white;		allowReframeHandles: false;		model: self;		addMorph: self yawGyroMorph		fullFrame: (LayoutFrame			fractions: (0 @ 0 corner: 0 @ 0)			offsets: (5 @ 5 extent: 125 @ 125));		addMorph: self buttonsMorph		fullFrame:  (LayoutFrame			fractions: (1 @ 0 corner: 1 @ 0)			offsets: (-100 @ 5 extent: 95 @ 95));		addMorph: (statusMorph := self statusMorph)		fullFrame:  (LayoutFrame			fractions: (1 @ 0 corner: 1 @ 0)			offsets: (-90 @ 110 extent: 85 @ 20));		openInWorldExtent: 250 @ 160.	statusMorph fillStyle: Color black! !!AvGyroTestWindow methodsFor: 'morph creation' stamp: 'jon 11/23/2004 15:00'!newVerticalSpacer: space	^Morph new		color: Color transparent;		height: space;		width: 1;		yourself! !!AvGyroTestWindow methodsFor: 'morph creation' stamp: 'Jon 11/27/2004 19:48'!statusMorph	^(UpdatingStringMorph on: self selector: #vehicleStatus)		stepTime: 1000;		useStringFormat;		contents: 'Stopped';		color: Color black;		fillStyle: Color black;		yourself! !!AvGyroTestWindow methodsFor: 'morph creation' stamp: 'Jon 11/24/2004 21:21'!yawGyroMorph	^yawGyroMorph := AvGyroMorph new		yawFilter: (AvYawFilter on: gyro);		extent: 125 @ 125;		yourself.! !!AvGyroTestWindow methodsFor: 'button handling' stamp: 'Jon 11/24/2004 20:12'!startVehicle	vehicle motionModel start.! !!AvGyroTestWindow methodsFor: 'button handling' stamp: 'jon 11/23/2004 15:10'!stopVehicle	vehicle motionModel stop! !!AvGyroTestWindow methodsFor: 'button handling' stamp: 'jon 11/23/2004 15:10'!zeroGyro	yawGyroMorph setZero.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvGyroTestWindow class	instanceVariableNames: ''!!AvGyroTestWindow class methodsFor: 'instance scheduling' stamp: 'jon 11/23/2004 14:59'!open	self new createView.! !Morph subclass: #AvMapEditorMorph	instanceVariableNames: 'mapForm gridOverlaySize objects selectedObjects scrollOffset zoomFactor mapPixelsPerMeter undoStack redoStack'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-UI'!!AvMapEditorMorph methodsFor: 'initializing' stamp: 'jon 11/12/2004 13:54'!initialize	objects := OrderedCollection new.	selectedObjects := OrderedCollection new.	scrollOffset := 0 @ 0.	zoomFactor := 1.	gridOverlaySize := 0.	mapPixelsPerMeter := 1.	self clearUndo; clearRedo.	super initialize! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 11:40'!gridOverlaySize	^ gridOverlaySize! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 11:40'!gridOverlaySize: anInteger	gridOverlaySize := anInteger! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 09:52'!mapForm	^ mapForm! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 09:52'!mapForm: aForm	mapForm := aForm! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 12:00'!mapPixelsPerMeter	^mapPixelsPerMeter! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 12:00'!mapPixelsPerMeter: anInteger	mapPixelsPerMeter := anInteger! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 09:53'!objects	^ objects! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 09:53'!objects: aCollection	objects := aCollection! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 13:54'!redoStack	^ redoStack! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 13:54'!redoStack: aCollection	redoStack := aCollection! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/15/2004 19:51'!resetZoom	self zoomTo: 1.! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 09:53'!scrollOffset	^ scrollOffset! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 09:53'!scrollOffset: aPoint	scrollOffset := aPoint! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 09:53'!selectedObjects	^ selectedObjects! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 09:53'!selectedObjects: aCollection	selectedObjects := aCollection! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 09:57'!setExtentFromMapForm	self extent: mapForm extent! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/16/2004 12:19'!showingGridOverlay	^self gridOverlaySize > 0! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 13:54'!undoStack	^ undoStack! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 13:54'!undoStack: aCollection	undoStack := aCollection! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 09:53'!zoomFactor	^ zoomFactor! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 09:53'!zoomFactor: aNumber	zoomFactor := aNumber! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 15:16'!zoomIn	zoomFactor = 8		ifTrue: [^self].	self zoomTo: zoomFactor * 2.! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/12/2004 15:16'!zoomOut	zoomFactor = 1		ifTrue: [^self].	self zoomTo: zoomFactor // 2.! !!AvMapEditorMorph methodsFor: 'accessing' stamp: 'jon 11/13/2004 22:49'!zoomTo: zoom	| center |	self zoomFactor: zoom.	center := self hasSelection		ifTrue: [			scrollOffset := 0 @ 0.			(self translateMapToWorld: self selectedObjectsCenterPoint) - bounds origin]		ifFalse: [(scrollOffset + (self extent // 2)) // 2].	scrollOffset := center - (self extent // 2).	self		limitScrollOffset;		changed.! !!AvMapEditorMorph methodsFor: 'drawing' stamp: 'jon 11/12/2004 11:53'!drawGridOn: aCanvas	| currentX currentY translateX translateY mapSize |	gridOverlaySize = 0		ifTrue: [^self].	currentX := 0.	mapSize := self extent * self mapPixelsPerMeter.	translateX := [:x | (self translateMapToWorldBlock value: x @ 0) x].	translateY := [:y | (self translateMapToWorldBlock value: 0 @ y) y].	[currentX > mapSize x] whileFalse: [		currentX := currentX + gridOverlaySize.		aCanvas			line: (translateX value: currentX) @ bounds top			to: (translateX value: currentX) @ bounds bottom			color: Color lightGray].	currentY := 0.	[currentY > mapSize y] whileFalse: [		currentY := currentY + gridOverlaySize.		aCanvas			line: bounds left @ (translateY value: currentY)			to: bounds right @ (translateY value: currentY)			color: Color lightGray].! !!AvMapEditorMorph methodsFor: 'drawing' stamp: 'jon 11/12/2004 12:04'!drawMapOn: aCanvas	zoomFactor = 1		ifTrue: [			^aCanvas				drawImage: mapForm				at: bounds origin - scrollOffset				sourceRect: mapForm boundingBox].	aCanvas		warpImage: mapForm		transform: (MatrixTransform2x3 withScale: zoomFactor @ zoomFactor)		at: bounds origin - scrollOffset		sourceRect: mapForm boundingBox		cellSize: 2.! !!AvMapEditorMorph methodsFor: 'drawing' stamp: 'jon 11/12/2004 11:41'!drawObjectsOn: aCanvas	objects do: [:each |		each			drawOn: aCanvas 			translateBy: self translateMapToWorldBlock 			selected: selectedObjects].! !!AvMapEditorMorph methodsFor: 'drawing' stamp: 'jon 11/12/2004 11:42'!drawOn: aCanvas	aCanvas		clipBy: bounds 		during: [:clippedCanvas |			self				drawMapOn: clippedCanvas;				drawGridOn: clippedCanvas;				drawObjectsOn: clippedCanvas].! !!AvMapEditorMorph methodsFor: 'event handling' stamp: 'jon 11/13/2004 19:51'!click: event	self		handleDragEvent: event;		changed.! !!AvMapEditorMorph methodsFor: 'event handling' stamp: 'jon 11/13/2004 20:02'!doubleClick: event	selectedObjects size = 1		ifTrue: [(Inspector openAsMorphOn: selectedObjects first) openInHand].! !!AvMapEditorMorph methodsFor: 'event handling' stamp: 'jon 11/12/2004 12:21'!handleDragEvent: event	selectedObjects size = 1		ifTrue: [self handleSingleObjectDragEvent: event]		ifFalse: [self handleMultipleObjectDragEvent: event].! !!AvMapEditorMorph methodsFor: 'event handling' stamp: 'jon 11/12/2004 14:27'!handleMultipleObjectDragEvent: event	| command originalPositions endPositions commandObjects translateFromScreenToMapBlock moved lastMousePoint originalMousePoint slop |	command := AvEditorCommand new		name: 'drag objects';		yourself.	originalPositions := selectedObjects collect: [:each | each undoPosition].	commandObjects := selectedObjects.	translateFromScreenToMapBlock := self translateWorldToMapBlock.	originalMousePoint := translateFromScreenToMapBlock value: event cursorPoint.	lastMousePoint := originalMousePoint.	moved := false.	slop := 3 / zoomFactor.	[Sensor anyButtonPressed] whileTrue: [		| current |		current := translateFromScreenToMapBlock value: Sensor cursorPoint.		(moved not and: [(originalMousePoint dist: current) < slop])			ifTrue: [current := originalMousePoint]			ifFalse: [moved := true].		current = lastMousePoint			ifFalse: [self selectedObjects do: [:each | each moveBy: current - lastMousePoint]].		lastMousePoint := current.		self changed.		self activeHand world doOneCycle].	endPositions := selectedObjects collect: [:each | each undoPosition]..	command		undoBlock: [			commandObjects				with: originalPositions				do: [:eachObject :eachPosition | eachObject setPositionFrom: eachPosition]];		redoBlock: [			commandObjects				with: endPositions				do: [:eachObject :eachPosition | eachObject setPositionFrom: eachPosition]];		yourself.	self addCommand: (moved ifTrue: [command] ifFalse: [nil]).! !!AvMapEditorMorph methodsFor: 'event handling' stamp: 'jon 11/12/2004 12:05'!handlePanEvent: event	Cursor webLink showWhile: [		| originalMousePoint originalScrollOffset |		originalMousePoint := event cursorPoint.		originalScrollOffset := scrollOffset.		[Sensor yellowButtonPressed] whileTrue: [			| offset |			offset := Sensor cursorPoint - originalMousePoint.			offset := offset negated.			scrollOffset := originalScrollOffset + offset.			self limitScrollOffset; changed.			self activeHand world doOneCycle]].! !!AvMapEditorMorph methodsFor: 'event handling' stamp: 'jon 11/13/2004 16:59'!handleSingleObjectDragEvent: event	| command |	selectedObjects isEmpty		ifTrue: [^self].	command := selectedObjects first		handleDragFrom: event cursorPoint		using: self translateWorldToMapBlock		displayingWith: [self changed; triggerEvent: #drag. self world doOneCycle]		useSlopArea: true.	self addCommand: command! !!AvMapEditorMorph methodsFor: 'event handling' stamp: 'jon 11/12/2004 10:30'!handlesMouseDown: event	^ true! !!AvMapEditorMorph methodsFor: 'event handling' stamp: 'jon 11/16/2004 18:00'!mouseDown: event	| objectUnderMouse |	event yellowButtonPressed		ifTrue: [^self handlePanEvent: event].	objectUnderMouse := self objectUnder: event cursorPoint.	event shiftPressed		ifTrue: [self flipSelectionOf: objectUnderMouse]		ifFalse: [			(self isSelected: objectUnderMouse)				ifTrue: [event hand waitForClicksOrDrag: self event: event]				ifFalse: [					self setSelection: objectUnderMouse.					event hand waitForClicksOrDrag: self event: event]].	self changed.! !!AvMapEditorMorph methodsFor: 'event handling' stamp: 'jon 11/16/2004 18:04'!startDrag: event	self		handleDragEvent: event;		changed.! !!AvMapEditorMorph methodsFor: 'private-selection' stamp: 'jon 11/13/2004 11:38'!addToSelection: aCollection	aCollection do: [:each |		(self isSelected: each)			ifFalse: [selectedObjects add: each]].	self triggerEvent: #selectionChanged.! !!AvMapEditorMorph methodsFor: 'private-selection' stamp: 'jon 11/13/2004 11:39'!deleteSelection	| command undoObjects |	command := AvEditorCommand new		name: 'delete';		yourself.	undoObjects := selectedObjects shallowCopy.	self noSelection.	self removeAllObjects: undoObjects.	command		undoBlock: [self addAllObjects: undoObjects];		redoBlock: [self removeAllObjects: undoObjects].	self addCommand: command.	self triggerEvent: #selectionChanged.! !!AvMapEditorMorph methodsFor: 'private-selection' stamp: 'jon 11/17/2004 17:57'!deleteSelectionWhenUndo: undoBlock whenRedo: redoBlock	| command undoObjects |	command := AvEditorCommand new		name: 'delete';		yourself.	undoObjects := selectedObjects shallowCopy.	self noSelection.	self removeAllObjects: undoObjects.	command		undoBlock: [self addAllObjects: undoObjects. undoBlock value: undoObjects];		redoBlock: [self removeAllObjects: undoObjects. redoBlock value: undoObjects].	self addCommand: command.	self triggerEvent: #selectionChanged.! !!AvMapEditorMorph methodsFor: 'private-selection' stamp: 'jon 11/12/2004 15:05'!flipSelectionOf: anObject	(selectedObjects includes: anObject)		ifTrue: [selectedObjects remove: anObject]		ifFalse: [selectedObjects add: anObject].	self triggerEvent: #selectionChanged.! !!AvMapEditorMorph methodsFor: 'private-selection' stamp: 'jon 11/12/2004 15:23'!hasSelection	^selectedObjects notEmpty! !!AvMapEditorMorph methodsFor: 'private-selection' stamp: 'jon 11/12/2004 10:45'!isSelected: anObject	anObject isNil		ifTrue: [^false].	^selectedObjects includes: anObject! !!AvMapEditorMorph methodsFor: 'private-selection' stamp: 'jon 11/12/2004 10:11'!noSelection	selectedObjects := OrderedCollection new! !!AvMapEditorMorph methodsFor: 'private-selection' stamp: 'jon 11/13/2004 11:39'!removeFromSelection: aCollection	aCollection do: [:each |		selectedObjects remove: each ifAbsent: []].	self triggerEvent: #selectionChanged.! !!AvMapEditorMorph methodsFor: 'private-selection' stamp: 'jon 11/12/2004 15:22'!selectedObjectsCenterPoint	^((selectedObjects		inject: 0 @ 0		into: [:sum :each | sum + each centerPoint]) / selectedObjects size) rounded! !!AvMapEditorMorph methodsFor: 'private-selection' stamp: 'jon 11/13/2004 16:57'!selectionDescription	self hasSelection		ifFalse: [^'no selection'].	selectedObjects size = 1		ifTrue: [^selectedObjects first printString].	^selectedObjects size printString, ' objects'.! !!AvMapEditorMorph methodsFor: 'private-selection' stamp: 'jon 11/12/2004 15:05'!setSelection: anObject	self noSelection.	anObject notNil		ifTrue: [selectedObjects add: anObject].	self triggerEvent: #selectionChanged.! !!AvMapEditorMorph methodsFor: 'private-undo/redo' stamp: 'jon 11/12/2004 15:04'!addCommand: command	command isNil		ifTrue: [^self].	undoStack add: command.	self		clearRedo;		triggerEvent: #undoChanged.! !!AvMapEditorMorph methodsFor: 'private-undo/redo' stamp: 'jon 11/12/2004 13:55'!clearRedo	redoStack := OrderedCollection new.! !!AvMapEditorMorph methodsFor: 'private-undo/redo' stamp: 'jon 11/12/2004 13:55'!clearUndo	undoStack := OrderedCollection new.! !!AvMapEditorMorph methodsFor: 'private-undo/redo' stamp: 'jon 11/12/2004 14:28'!hasRedo	^redoStack notEmpty! !!AvMapEditorMorph methodsFor: 'private-undo/redo' stamp: 'jon 11/12/2004 14:28'!hasUndo	^undoStack notEmpty! !!AvMapEditorMorph methodsFor: 'private-undo/redo' stamp: 'jon 11/12/2004 21:30'!nextRedoLabel	^self hasRedo		ifTrue: ['Redo ', redoStack last name]		ifFalse: ['Nothing to Redo'].! !!AvMapEditorMorph methodsFor: 'private-undo/redo' stamp: 'jon 11/12/2004 21:30'!nextUndoLabel	^self hasUndo		ifTrue: ['Undo ', undoStack last name]		ifFalse: ['Nothing to Undo'].! !!AvMapEditorMorph methodsFor: 'private-undo/redo' stamp: 'jon 11/12/2004 15:04'!redo	| command |	self hasRedo		ifFalse: [^self].	command := redoStack removeLast.	undoStack add: command.	command redo.	self		changed;		triggerEvent: #undoChanged.! !!AvMapEditorMorph methodsFor: 'private-undo/redo' stamp: 'jon 11/12/2004 15:04'!undo	| command |	self hasUndo		ifFalse: [^self].	command := undoStack removeLast.	redoStack add: command.	command undo.	self		changed;		triggerEvent: #undoChanged.! !!AvMapEditorMorph methodsFor: 'private-objects' stamp: 'jon 11/13/2004 13:32'!addAllObjects: aCollection	objects addAll: aCollection.	self noSelection; addToSelection: aCollection.	self changed.	self triggerEvent: #objectsChanged.! !!AvMapEditorMorph methodsFor: 'private-objects' stamp: 'jon 11/13/2004 11:13'!addObject: anObject	self addAllObjects: (Array with: anObject).! !!AvMapEditorMorph methodsFor: 'private-objects' stamp: 'jon 11/13/2004 15:47'!removeAllObjects: aCollection	objects removeAll: aCollection.	self removeFromSelection: aCollection.	self changed.	self triggerEvent: #objectsChanged.! !!AvMapEditorMorph methodsFor: 'private-objects' stamp: 'jon 11/13/2004 11:13'!removeObject: anObject	self removeAllObjects: (Array with: anObject).! !!AvMapEditorMorph methodsFor: 'private' stamp: 'jon 11/12/2004 12:05'!limitScrollOffset	| scrollLimit |	scrollLimit := (mapForm extent * zoomFactor) - self extent.	scrollOffset := (scrollOffset max: 0 @ 0) min: scrollLimit.! !!AvMapEditorMorph methodsFor: 'private' stamp: 'jon 11/12/2004 13:47'!objectUnder: worldPoint	| mapPoint closeObjects min |	mapPoint := self translateWorldToMapBlock value: worldPoint.	closeObjects := objects select: [:each | (each distanceTo: mapPoint) < (2.0 / zoomFactor)].	closeObjects isEmpty		ifTrue: [^nil].	closeObjects size = 1		ifTrue: [^closeObjects first].	min := closeObjects first.	closeObjects do: [:each |		(each distanceTo: mapPoint) < (min distanceTo: mapPoint)			ifTrue: [min := each]].	^min! !!AvMapEditorMorph methodsFor: 'private' stamp: 'Jon 11/28/2004 17:49'!readObjectsFromCourse: courseName	| objectMap |	((FileDirectory on: FileDirectory default pathName, '\courses') fileExists: courseName, '.obj')		ifTrue: [			| file |			file := FileStream readOnlyFileNamed: 'courses\', courseName, '.obj'.			objectMap := file fileInObjectAndCode.			file close]		ifFalse: [objectMap := Dictionary new].	objects := objectMap values.	self noSelection! !!AvMapEditorMorph methodsFor: 'private' stamp: 'jon 11/12/2004 15:20'!translateMapToWorld: aPoint	^self translateMapToWorldBlock value: aPoint! !!AvMapEditorMorph methodsFor: 'private' stamp: 'jon 11/12/2004 10:22'!translateMapToWorldBlock	^[:mapPoint |		| scaleFactor mapHeight scrolledFormPosition |		scaleFactor := self mapPixelsPerMeter * zoomFactor.		mapHeight := zoomFactor * mapForm height.		scrolledFormPosition := mapPoint * scaleFactor.		scrolledFormPosition := scrolledFormPosition x @ (mapHeight - scrolledFormPosition y).		scrolledFormPosition - scrollOffset + bounds origin]! !!AvMapEditorMorph methodsFor: 'private' stamp: 'jon 11/12/2004 15:19'!translateWorldToMap: aPoint	^self translateWorldToMapBlock value: aPoint! !!AvMapEditorMorph methodsFor: 'private' stamp: 'jon 11/12/2004 10:23'!translateWorldToMapBlock	^[:formPosition |		| scaleFactor scrolledFormPosition mapHeight |		scrolledFormPosition := formPosition + scrollOffset - bounds origin.		mapHeight := zoomFactor * mapForm height.		scrolledFormPosition := scrolledFormPosition x @ (mapHeight - scrolledFormPosition y).		scaleFactor := self mapPixelsPerMeter * zoomFactor.		scrolledFormPosition / scaleFactor]! !Object subclass: #AvMissionEditor	instanceVariableNames: 'mapMorph window status mission buttons textEditFields navigatorMorph selectedGoal missionMapName showGps'	classVariableNames: 'ConeColor'	poolDictionaries: ''	category: 'Av-UI'!!AvMissionEditor methodsFor: 'initializing' stamp: 'Jon 12/14/2004 12:40'!initialize	buttons := Dictionary new.	textEditFields := Dictionary new.	selectedGoal := 1.	mission := AvGoalBasedMission new		name: '';		yourself.	missionMapName := 'blankMap'.	self status: 'ready'.	self showLocal.	super initialize.! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/16/2004 17:42'!areaNames	^(mission map mapEntries		select: [:each | each isArea]) collect: [:each | each name]! !!AvMissionEditor methodsFor: 'accessing' stamp: 'Jon 12/27/2005 21:48'!availableGoalRuleNames	^#('required' 'atomic')! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/13/2004 08:42'!availableMapNames	^(FileDirectory on: FileDirectory default pathName, '\maps') fileNames		collect: [:each | each readStream upTo: $.]! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/21/2004 22:50'!availableNavigatorNames	^(AvNavigator allSubclasses collect: [:each | each descriptiveName]) asSortedCollection asArray, #('none')! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/21/2004 22:53'!goals	^mission goals! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/21/2004 22:34'!goalsForList	^Array with: (AvGoalWrapper with: self topGoal)! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/15/2004 23:40'!locationNames	^(mission map mapEntries		select: [:each | each isLocation]) collect: [:each | each name]! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/15/2004 13:05'!mapObjectNamed: aString	^mission map mapEntries		detect: [:each | each name = aString]		ifNone: [nil].! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/13/2004 16:18'!missionMapName	^mission map surfaceMapName! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/12/2004 21:17'!missionName	^mission name! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/15/2004 13:01'!pathAndLocationNames	^(mission map mapEntries		select: [:each | each isPath | each isLocation]) collect: [:each | each name]! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/15/2004 12:55'!pathNames	^(mission map mapEntries		select: [:each | each isPath]) collect: [:each | each name]! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/12/2004 16:40'!status	^status! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/12/2004 16:40'!status: aString	status := aString! !!AvMissionEditor methodsFor: 'accessing' stamp: 'jon 11/21/2004 22:55'!topGoal	^AvGoal new		name: 'Mission';		subGoals: self goals;		yourself! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/12/2004 15:14'!buttonMorphOn: button label: label	^(PluggableButtonMorph on: button)		useRoundedCorners;		hResizing: #spaceFill;		borderWidth: 2;		borderRaised;		feedbackColor: Color darkGray;		label: label;		color: Color veryLightGray;		yourself! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/12/2004 19:59'!buttonMorphOnSelector: selector iconName: filename balloonText: balloonText	^buttons		at: selector		put: ((self			iconButtonMorphFromFileName: filename			sending: selector)				setBalloonText: balloonText;				yourself).! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/12/2004 15:57'!buttonMorphOnSelector: selector label: label	^buttons		at: selector		put: (self			buttonMorphOn: (Button newOff onAction: [self perform: selector]; yourself)			label: label).! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/13/2004 16:13'!dropDownMorphFor: items chooseSelector: chooseSelector	^self dropDownMorphFor: items default: items first getSelector: nil chooseSelector: chooseSelector! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/13/2004 16:30'!dropDownMorphFor: items default: defaultItem getSelector: getSelector chooseSelector: chooseSelector	^DropDownChoiceMorph new		initialize;		contents: defaultItem;		items: items; 		target: self; 		getItemsSelector: getSelector;		actionSelector: chooseSelector;		maxExtent: items;		border: #useBorder;		yourself! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/12/2004 18:08'!iconButtonMorphFromFileName: filename sending: selector	^IconicButton new		labelGraphic: (Form fromFileNamed: filename);		target: self;		actionSelector: selector;		color: Color lightGray lighter;		borderRaised;		yourself! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/12/2004 21:09'!labelButtonPairMorphWith: label buttonLabel: buttonLabel selector: selector	^AlignmentMorph new		listDirection: #leftToRght;		color: Color white;		borderWidth: 0;		addMorphBack: (StringMorph new contents: label);		addMorphBack: (self buttonMorphOnSelector: selector label: buttonLabel);		yourself! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/13/2004 16:15'!labelDropDownButtonTripleMorphWith: label items: items default: defaultItem selector: chooseSelector buttonLabel: buttonLabel selector: buttonSelector	^AlignmentMorph new		listDirection: #leftToRght;		color: Color white;		borderWidth: 0;		addMorphBack: (StringMorph new contents: label);		addMorphBack: (self dropDownMorphFor: items default: defaultItem getSelector: nil chooseSelector: chooseSelector);		addMorphBack: (self newHorizontalSpacer: 10);		addMorphBack: (self buttonMorphOnSelector: buttonSelector label: buttonLabel);		yourself! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/16/2004 22:31'!labelDropDownPairMorphWith: label items: items default: defaultItem selector: chooseSelector	^AlignmentMorph new		listDirection: #leftToRght;		color: Color transparent;		borderWidth: 0;		addMorphBack: (StringMorph new contents: label);		addMorphBack: (self dropDownMorphFor: items default: defaultItem getSelector: nil chooseSelector: chooseSelector);		yourself! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/13/2004 07:56'!labelDropDownPairMorphWith: label items: items selector: chooseSelector	^self		labelDropDownPairMorphWith: label 		items: items 		default: items first		selector: chooseSelector! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/13/2004 08:50'!labelEditorPairMorphWith: label named: editFieldName	^self		labelEditorPairMorphWith: label 		named: editFieldName 		withContents: ''! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/16/2004 12:29'!labelEditorPairMorphWith: label named: editFieldName withContents: contents	| textEdit panel |	panel := AlignmentMorph new		listDirection: #leftToRght;		color: Color white;		borderWidth: 0;		addMorphBack: (StringMorph new contents: label);		addMorphBack: (textEdit := TextMorph new			extent: 200 @ 23;			autoFit: false;			borderWidth: 1;			setBorderStyle: #complexAltFramed;			contents: contents;			wrapFlag: true;			yourself);		yourself.	textEditFields at: editFieldName put: textEdit.	^panel! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/13/2004 08:00'!newHorizontalSpacer: space	^Morph new		color: Color transparent;		width: space;		height: 1;		yourself! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/12/2004 15:15'!newVerticalSpacer: space	^Morph new		color: Color transparent;		height: space;		width: 1;		yourself! !!AvMissionEditor methodsFor: 'morph creation-support' stamp: 'jon 11/16/2004 10:22'!radioButtonFor: target with: selector using: quad	| row stringMorph |	row := AlignmentMorph newRow beTransparent.	row		addMorphBack: (UpdatingThreePhaseButtonMorph radioButton			target: target;			setBalloonText: quad fourth;			actionSelector: selector;			getSelector: quad third;			arguments: (Array with: quad first);			yourself);		addTransparentSpacerOfSize: (4 @ 0);		addMorphBack: (stringMorph := StringMorph contents: quad second asString).	stringMorph setBalloonText: quad fourth.	^row! !!AvMissionEditor methodsFor: 'morph creation-navigators' stamp: 'jon 11/17/2004 18:10'!addCloseQuartersNavigatorMorphsTo: panelMorph for: aCloseQuartersNavigator	| area name all stringField dropDown |	area := aCloseQuartersNavigator allowableArea.	(area notNil and: [area isDeleted])		ifTrue: [area := nil].	name := area isNil		ifTrue: [nil]		ifFalse: [area name].	all := self areaNames.	(all includes: name)		ifFalse: [name := '<none>'].	panelMorph		addMorphBack: (StringMorph new contents: 'Select Area for maneuvering:  ');		addMorphBack: (self newVerticalSpacer: 5);		addMorphBack: (AlignmentMorph newRow beTransparent			addMorphBack: (self newHorizontalSpacer: 20);			addMorphBack: (AlignmentMorph newColumn beTransparent				cellPositioning: #topLeft;				addMorphBack: (stringField := StringMorph new emphasis: 1; contents: name);				addMorphBack: (self newVerticalSpacer: 5);				addMorphBack: ((self buttonMorphOnSelector: #setCloseQuartersNavigatorAreaFromSelection label: 'From Selection')					hResizing: #shrinkWrap;					yourself)));		addMorphBack: (self newVerticalSpacer: 15);		addMorphBack: (StringMorph contents: 'Set the heading for finishing:');		addMorphBack: (AlignmentMorph newRow beTransparent			addMorphBack: (self newHorizontalSpacer: 20);			addMorphBack: ((self					iconButtonMorphFromFileName: 'icons\setMapHeading.bmp'					sending: #setCloseQuartersNavigatorFinalHeading)				setBalloonText: 'Set final heading';				yourself);			addMorphBack: (self newHorizontalSpacer: 10);			addMorphBack: ((UpdatingStringMorph on: self selector: #closeQuartersNavigatorFinalHeadingString)				stepTime: 100;				hResizing: #spaceFill;				useStringFormat;				color: Color black;				yourself));		addMorphBack: (self newVerticalSpacer: 15);		addMorphBack: (AlignmentMorph new			listDirection: #leftToRght;			color: Color transparent;			borderWidth: 0;			addMorphBack: (StringMorph new contents: 'Line up to:  ' );			addMorphBack: (dropDown := self				dropDownMorphFor: #('doesn''t matter' 'ramp going up' 'ramp going down') 				default: aCloseQuartersNavigator lineUpString				getSelector: nil				chooseSelector: #selectCloseQuartersNavigatorLineUp:);			yourself);		addMorphBack: (self newVerticalSpacer: 150).	mapMorph		setSelection: area;		changed.	textEditFields		at: #closeQuartersNavigatorArea put: stringField;		at: #closeQuartersNavigatorLineUp put: dropDown.! !!AvMissionEditor methodsFor: 'morph creation-navigators' stamp: 'jon 11/17/2004 18:11'!addRampNavigatorMorphsTo: panelMorph for: aRampNavigator	| bottom bottomName top topName all bottomField topField |	bottom := aRampNavigator bottomLocation.	(bottom notNil and: [bottom isDeleted])		ifTrue: [bottom := nil].	bottomName := bottom isNil		ifTrue: [nil]		ifFalse: [bottom name].	all := self locationNames.	(all includes: bottomName)		ifFalse: [bottomName := '<none>'].	top := aRampNavigator topLocation.	(top notNil and: [top isDeleted])		ifTrue: [top := nil].	topName := top isNil		ifTrue: [nil]		ifFalse: [top name].	(all includes: topName)		ifFalse: [topName := '<none>'].	panelMorph		addMorphBack: (StringMorph contents: 'Select Top of Ramp Location:  ');		addMorphBack: (AlignmentMorph newRow beTransparent			addMorphBack: (self newHorizontalSpacer: 20);			addMorphBack: (AlignmentMorph newColumn beTransparent				cellPositioning: #topLeft;				addMorphBack: (topField := StringMorph new emphasis: 1; contents: topName);				addMorphBack: (self newVerticalSpacer: 5);				addMorphBack: ((self buttonMorphOnSelector: #setRampNavigatorTopFromSelection label: 'From Selection')					hResizing: #shrinkWrap;					yourself)));		addMorphBack: (self newVerticalSpacer: 10);		addMorphBack: (StringMorph contents: 'Select Bottom of Ramp Location:  ');		addMorphBack: (AlignmentMorph newRow beTransparent			addMorphBack: (self newHorizontalSpacer: 20);			addMorphBack: (AlignmentMorph newColumn beTransparent				cellPositioning: #topLeft;				addMorphBack: (bottomField := StringMorph new emphasis: 1; contents: bottomName);				addMorphBack: (self newVerticalSpacer: 5);				addMorphBack: ((self buttonMorphOnSelector: #setRampNavigatorBottomFromSelection label: 'From Selection')					hResizing: #shrinkWrap;					yourself)));		addMorphBack: (self newVerticalSpacer: 10);		addMorphBack: (StringMorph contents: 'Choose Ramp Direction  ');		addMorphBack: (AlignmentMorph newRow beTransparent			addMorphBack: (self newHorizontalSpacer: 20);			addMorphBack: (AlignmentMorph newColumn beTransparent				cellPositioning: #topLeft;				addMorphBack: (self					radioButtonFor: aRampNavigator					with: #direction:					using: #(upRamp 'up ramp' isUpRamp 'navigate up the ramp'));				addMorphBack: (self					radioButtonFor: aRampNavigator					with: #direction:					using: #(downRamp 'down ramp' isDownRamp 'navigate down the ramp')))).	(aRampNavigator topLocation notNil and: [aRampNavigator bottomLocation notNil])		ifTrue: [			mapMorph				setSelection: top;				addToSelection: (Array with: bottom);				changed].	textEditFields		at: #rampNavigatorTopLocation put: topField;		at: #rampNavigatorBottomLocation put: bottomField.! !!AvMissionEditor methodsFor: 'morph creation-navigators' stamp: 'jon 11/15/2004 13:23'!addShutdownNavigatorMorphsTo: panelMorph for: aShutdownNavigator! !!AvMissionEditor methodsFor: 'morph creation-navigators' stamp: 'Jon 1/6/2006 09:07'!addStartupNavigatorMorphsTo: panelMorph for: aStartupNavigator	| location name all stringField |	location := aStartupNavigator startLocation.	(location notNil and: [location isDeleted])		ifTrue: [location := nil].	name := location isNil		ifTrue: [nil]		ifFalse: [location name].	all := self locationNames.	(all includes: name)		ifFalse: [name := '<none>'].	panelMorph		addMorphBack: (StringMorph new contents: 'Select Start Location:  ');		addMorphBack: (self newVerticalSpacer: 5);		addMorphBack: (AlignmentMorph newRow beTransparent			addMorphBack: (self newHorizontalSpacer: 20);			addMorphBack: (AlignmentMorph newColumn beTransparent				cellPositioning: #topLeft;				addMorphBack: (stringField := StringMorph new emphasis: 1; contents: name);				addMorphBack: (self newVerticalSpacer: 5);				addMorphBack: ((self buttonMorphOnSelector: #setStartupNavigatorLocationFromSelection label: 'From Selection')					hResizing: #shrinkWrap;					yourself))).						mapMorph		setSelection: location;		changed.	textEditFields at: #startupNavigatorLocation put: stringField! !!AvMissionEditor methodsFor: 'morph creation-navigators' stamp: 'Jon 11/26/2004 11:06'!addVisualNavigatorMorphsTo: panelMorph for: aVisualNavigator	| location name all stringField dropDown button |	location := aVisualNavigator targetLocation.	(location notNil and: [location isDeleted])		ifTrue: [location := nil].	name := location isNil		ifTrue: [nil]		ifFalse: [location name].	all := self locationNames.	(all includes: name)		ifFalse: [name := '<none>'].	panelMorph		addMorphBack: (StringMorph new contents: 'Select location of target:  ');		addMorphBack: (self newVerticalSpacer: 5);		addMorphBack: (AlignmentMorph newRow beTransparent			addMorphBack: (self newHorizontalSpacer: 20);			addMorphBack: (AlignmentMorph newColumn beTransparent				cellPositioning: #topLeft;				addMorphBack: (stringField := StringMorph new emphasis: 1; contents: name);				addMorphBack: (self newVerticalSpacer: 5);				addMorphBack: ((self buttonMorphOnSelector: #setVisualNavigatorTargetFromSelection label: 'From Selection')					hResizing: #shrinkWrap;					yourself)));		addMorphBack: (self newVerticalSpacer: 5);		addMorphBack: (StringMorph contents: 'Mode:');		addMorphBack: (AlignmentMorph newRow beTransparent			addMorphBack: (self newHorizontalSpacer: 20);			addMorphBack: (AlignmentMorph newColumn beTransparent				cellPositioning: #topLeft;				addMorphBack: (self					radioButtonFor: aVisualNavigator					with: #mode:					using: #(search 'search for target' isModeSearch 'search for the target object using the turrent camera'));				addMorphBack: (self					radioButtonFor: aVisualNavigator					with: #mode:					using: #(guide 'guide towards target' isModeGuide 'navigate towards the target until the robot touchs it'))));		addMorphBack: (self newVerticalSpacer: 5);		addMorphBack: (AlignmentMorph new			listDirection: #leftToRght;			color: Color transparent;			borderWidth: 0;			addMorphBack: (StringMorph new contents: 'Target Type:  ' );			addMorphBack: (dropDown := self				dropDownMorphFor: #('cone' 'ramp bottom' 'ramp top') 				default: aVisualNavigator typeString				getSelector: nil				chooseSelector: #setVisualNavigatorTargetType:);			yourself);		addMorphBack: (AlignmentMorph newRow beTransparent			addMorphBack: (StringMorph contents: 'Target Color:  ');			addMorphBack: ((button := self					iconButtonMorphFromFileName: 'icons\setColorIcon.bmp'					sending: #setVisualNavigatorTargetColor)				setBalloonText: 'Set target color';				yourself);			addMorphBack: (self newHorizontalSpacer: 10);			addMorphBack: ((UpdatingStringMorph on: self selector: #visualNavigatorConeColorString)				stepTime: 100;				hResizing: #spaceFill;				useStringFormat;				color: Color black;				yourself);			yourself);		addMorphBack: (self newVerticalSpacer: 200);		yourself.	location notNil		ifTrue: [			mapMorph				setSelection: location;				changed].	textEditFields		at: #visualNavigatorTargetLocation put: stringField;		at: #visualNavigatorTargetType put: dropDown.	buttons		at: #visualNavigatorTargetColor put: button.	self setVisualNavigatorTargetColor: aVisualNavigator color.! !!AvMissionEditor methodsFor: 'morph creation-navigators' stamp: 'jon 11/17/2004 18:13'!addWaypointNavigatorMorphsTo: panelMorph for: aWaypointNavigator	| location name all stringField |	location := aWaypointNavigator destinationLocation.	(location notNil and: [location isDeleted])		ifTrue: [location := nil].	name := location isNil		ifTrue: [nil]		ifFalse: [location name].	all := self pathAndLocationNames.	(all includes: name)		ifFalse: [name := '<none>'].	panelMorph		addMorphBack: (StringMorph new contents: 'Select Path or destination Location:  ');		addMorphBack: (self newVerticalSpacer: 5);		addMorphBack: (AlignmentMorph newRow beTransparent			addMorphBack: (self newHorizontalSpacer: 20);			addMorphBack: (AlignmentMorph newColumn beTransparent				cellPositioning: #topLeft;				addMorphBack: (stringField := StringMorph new emphasis: 1; contents: name);				addMorphBack: (self newVerticalSpacer: 5);				addMorphBack: ((self buttonMorphOnSelector: #setWaypointNavigatorPathFromSelection label: 'From Selection')					hResizing: #shrinkWrap;					yourself))).	mapMorph		setSelection: location;		changed.	textEditFields at: #waypointNavigatorLocation put: stringField.! !!AvMissionEditor methodsFor: 'morph creation' stamp: 'jon 11/21/2004 08:22'!addGoalMorph	^AlignmentMorph new		listDirection: #leftToRght;		color: Color white;		borderWidth: 0;		addMorphBack: (StringMorph new contents: 'Goals:  ');		addMorphBack: (self buttonMorphOnSelector: #addGoal label: 'Add new Goal');		addMorphBack: (self newHorizontalSpacer: 10);		addMorphBack: (self buttonMorphOnSelector: #addGoalSet label: 'Add new Goal Set');		yourself! !!AvMissionEditor methodsFor: 'morph creation' stamp: 'Jon 12/27/2005 22:00'!addNavigatorPanelFor: aNavigator	navigatorMorph isNil		ifFalse: [navigatorMorph delete].	navigatorMorph := AlignmentMorph new		listDirection: #topToBottom;		color: Color white;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		cellPositioning: #topLeft;		yourself.	aNavigator notNil		ifTrue: [aNavigator addNavigatorMorphsTo: navigatorMorph for: self].	window		addMorph: navigatorMorph		fullFrame: (LayoutFrame 			fractions: (0@0 corner: 1@1) 			offsets: (480@285 corner: -5@-5)).! !!AvMissionEditor methodsFor: 'morph creation' stamp: 'Jon 1/18/2006 22:40'!buttonsMorph	| panelMorph |	panelMorph := AlignmentMorph new		listDirection: #topToBottom;		color: Color white;		vResizing: #spaceFill;		yourself.	^panelMorph		addMorphBack: (self			buttonMorphOnSelector: #newMission			iconName: 'icons\newIcon.bmp'			balloonText: 'Create a new Mission');		addMorphBack: (self newVerticalSpacer: 2);		addMorphBack: (self			buttonMorphOnSelector: #openMission			iconName: 'icons\openIcon.bmp'			balloonText: 'Open an existing Mission');		addMorphBack: (self newVerticalSpacer: 2);		addMorphBack: (self			buttonMorphOnSelector: #saveMission			iconName: 'icons\saveIcon.bmp'			balloonText: 'Save the current Mission');		addMorphBack: (self newVerticalSpacer: 10);		addMorphBack: (self			buttonMorphOnSelector: #undo			iconName: 'icons\undoIcon.bmp'			balloonText: 'Undo the last action');		addMorphBack: (self newVerticalSpacer: 2);		addMorphBack: (self			buttonMorphOnSelector: #redo			iconName: 'icons\redoIcon.bmp'			balloonText: 'Redo the last undo');		addMorphBack: (self newVerticalSpacer: 10);		addMorphBack: (self			buttonMorphOnSelector: #deleteSelection			iconName: 'icons\deleteIcon.bmp'			balloonText: 'Delete the current selection');		addMorphBack: (self newVerticalSpacer: 5);		addMorphBack: (StringMorph new contents: 'Zoom:');		addMorphBack: self zoomMorph;		addMorphBack: (self newVerticalSpacer: 5);		addMorphBack: (self			buttonMorphOnSelector: #addLocation			iconName: 'icons\addLocationIcon.bmp'			balloonText: 'Add a new location');		addMorphBack: (self newVerticalSpacer: 2);		addMorphBack: (self			buttonMorphOnSelector: #addGPSLocation			iconName: 'icons\addGPSLocationIcon.bmp'			balloonText: 'Add a new GPS location');		addMorphBack: (self newVerticalSpacer: 2);		addMorphBack: (self			buttonMorphOnSelector: #addPath			iconName: 'icons\addPathIcon.bmp'			balloonText: 'Add a new path');		addMorphBack: (self newVerticalSpacer: 2);		addMorphBack: (self			buttonMorphOnSelector: #addArea			iconName: 'icons\addAreaIcon.bmp'			balloonText: 'Add a new area');		addMorphBack: (self newVerticalSpacer: 2);		addMorphBack: (AlignmentMorph newRow beTransparent			addMorphBack: (UpdatingThreePhaseButtonMorph checkBox				target: self;				setBalloonText: 'Toggle a 10m grid overlay';				actionSelector: #toggleGridOverlay;				getSelector: #showingGridOverlay);			addMorphBack: (self newHorizontalSpacer: 5);			addMorphBack: (StringMorph contents: 'Grid'));		addMorphBack: (self newVerticalSpacer: 2);		addMorphBack: (self			buttonMorphOnSelector: #runMission			iconName: 'icons\runMissionIcon.bmp'			balloonText: 'Run the mission on the embedded system');		addMorphBack: (self newVerticalSpacer: 2);		addMorphBack: (self			buttonMorphOnSelector: #copyMission			iconName: 'icons\copyMissionIcon.bmp'			balloonText: 'Copy the mission to the embedded system');		addMorphBack: (self newVerticalSpacer: 10);		addMorphBack: (self			buttonMorphOnSelector: #debugMenu			iconName: 'icons\exploreIcon.bmp'			balloonText: 'Debug Menu');		yourself.! !!AvMissionEditor methodsFor: 'morph creation' stamp: 'Jon 1/18/2006 22:39'!createView	| buttonsPanel |	(window := SystemWindowWithButton labelled: 'Mission Editor')		color: Color white;		allowReframeHandles: false;		model: self.	window		addMorph: (mapMorph := self mapEditorMorph)		fullFrame: (LayoutFrame 			fractions: (0@0 corner: 0@0) 			offsets: (5@5 extent: 400 @ 464)).	window		addMorph: (buttonsPanel := self buttonsMorph)		fullFrame: (LayoutFrame 			fractions: (0@0 corner: 0@1) 			offsets: (410@5 corner: 475@-48)).	window		addMorph: self statusMorph		fullFrame: (LayoutFrame 			fractions: (0@1 corner: 0@1) 			offsets: (5@-45 corner: 475@-5)).	window		addMorph: self missionMorph		fullFrame: (LayoutFrame 			fractions: (0@0 corner: 1@0) 			offsets: (480@5 corner: -5@280)).	window openInWorldExtent: 925 @ 560.	buttonsPanel extent: 65 @ (window height - 53).	mapMorph		when: #undoChanged send: #undoChanged to: self;		when: #selectionChanged send: #selectionChanged to: self;		when: #objectsChanged send: #objectsChanged to: self;		when: #drag send: #handleDrag to: self.	self undoChanged.! !!AvMissionEditor methodsFor: 'morph creation' stamp: 'jon 11/21/2004 22:43'!goalListMorph	^(SimpleHierarchicalListMorph		on: self		list: #goalsForList		selected: #selectedGoal		changeSelected: #selectedGoal:		menu: #goalMenu:		keystroke: nil)			hResizing: #spaceFill;			yourself.! !!AvMissionEditor methodsFor: 'morph creation' stamp: 'Jon 12/27/2005 21:48'!goalRuleMorph	| panel dropDown |	panel := AlignmentMorph new		listDirection: #leftToRght;		color: Color white;		borderWidth: 0;		addMorphBack: (StringMorph new contents: 'Execution Rule:  ');		addMorphBack: (dropDown := self			dropDownMorphFor: self availableGoalRuleNames 			default: 'required' 			getSelector: nil 			chooseSelector: #setGoalRuleName:);		yourself.	textEditFields at: #goalRuleName put: dropDown.	^panel! !!AvMissionEditor methodsFor: 'morph creation' stamp: 'jon 11/13/2004 08:45'!mapEditorMorph	^AvMapEditorMorph new		mapForm: (Form fromFileNamed: 'maps\blankMap.bmp');		extent: 400 @ 424;		mapPixelsPerMeter: 4;		yourself! !!AvMissionEditor methodsFor: 'morph creation' stamp: 'jon 11/16/2004 21:19'!mapNameMorph	| panel items mapNameDropDown |	panel := AlignmentMorph new		listDirection: #leftToRght;		color: Color white;		borderWidth: 0;		addMorphBack: (StringMorph new contents: 'Map:  ');		addMorphBack: (mapNameDropDown := self			dropDownMorphFor: (items := self availableMapNames)			default: items first			getSelector: nil			chooseSelector: #setMissionMapName:);		addMorphBack: (self newHorizontalSpacer: 10);		addMorphBack: ((self iconButtonMorphFromFileName: 'icons\importPDA.bmp' sending: #importCourseObjects)			setBalloonText: 'Import Course from PDA';			yourself);				addMorphBack: (self newHorizontalSpacer: 10);		addMorphBack: ((self iconButtonMorphFromFileName: 'icons\setMapHeading.bmp' sending: #setMapHeading)			setBalloonText: 'Set Map Offset Heading';			yourself);		addMorphBack: (self newHorizontalSpacer: 10);		addMorphBack: ((UpdatingStringMorph on: self selector: #offsetHeadingString)			stepTime: 100;			setBalloonText: 'Map Offset Heading';			useStringFormat;			color: Color black;			contents: 'not set';			yourself);		yourself.	textEditFields at: #mapName put: mapNameDropDown.	^panel! !!AvMissionEditor methodsFor: 'morph creation' stamp: 'Jon 12/27/2005 21:51'!missionMorph	| panelMorph |	panelMorph := AlignmentMorph new		listDirection: #topToBottom;		color: Color transparent;		vResizing: #shrinkWrap;		yourself.	^panelMorph 		addMorphBack: self missionNameMorph;		addMorphBack: self mapNameMorph;		addMorphBack: self addGoalMorph;		addMorphBack: self goalListMorph;		addMorphBack: self goalRuleMorph;		addMorphBack: self navigatorNameMorph;		yourself.! !!AvMissionEditor methodsFor: 'morph creation' stamp: 'jon 11/13/2004 09:05'!missionNameMorph	^self labelEditorPairMorphWith: 'Mission Name:  ' named: #missionNameField withContents: self missionName! !!AvMissionEditor methodsFor: 'morph creation' stamp: 'jon 11/13/2004 21:50'!navigatorNameMorph	| panel dropDown |	panel := AlignmentMorph new		listDirection: #leftToRght;		color: Color white;		borderWidth: 0;		addMorphBack: (StringMorph new contents: 'Navigator:  ');		addMorphBack: (dropDown := self			dropDownMorphFor: self availableNavigatorNames 			default: 'Waypoint Navigator' 			getSelector: nil 			chooseSelector: #setNavigatorName:);		yourself.	textEditFields at: #navigatorName put: dropDown.	^panel! !!AvMissionEditor methodsFor: 'morph creation' stamp: 'Jon 12/14/2004 12:33'!statusMorph	^AlignmentMorph new		listDirection: #topToBottom;		color: Color white;		addMorphBack: ((UpdatingStringMorph on: self selector: #status)			stepTime: 100;			hResizing: #spaceFill;			useStringFormat;			color: Color black;			yourself);		addMorphBack: ((UpdatingStringMorph on: self selector: #cursorCoordinateString)			stepTime: 250;			hResizing: #spaceFill;			useStringFormat;			color: Color black;			yourself);		yourself! !!AvMissionEditor methodsFor: 'morph creation' stamp: 'jon 11/12/2004 19:51'!zoomMorph	^self		dropDownMorphFor: #('1x' '2x' '4x' '8x')		chooseSelector: #setZoomTo:! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 11/28/2004 18:36'!addArea	| areaType addAreaSelector |	areaType := PopUpMenu		withCaption: 'Choose Area Type' 		chooseFrom: #('Rectangular' 'Polygonal' 'Exclusion Area').	areaType = 0		ifTrue: [^self].	addAreaSelector := #(addRectangularArea addPolygonalArea addExclusionArea)		at: areaType.	self perform: addAreaSelector! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 2/9/2006 09:55'!addGPSLocation	| latitude longitude coordinate name location command distance |	mission hasMapEntryForSwCorner		ifFalse: [^self inform: 'You must have a GPS locationnamed ''Anchor'' at the map originto add other GPS coordinates...'].	latitude := FillInTheBlankMorph request: 'Enter GPS Latitude:' initialAnswer: '00.0000'.	(latitude isNil or: [latitude withBlanksTrimmed isEmpty])		ifTrue: [^self].	longitude := FillInTheBlankMorph request: 'Enter GPS Longitude:' initialAnswer: '00.0000'.	(longitude isNil or: [longitude withBlanksTrimmed isEmpty])		ifTrue: [^self].	coordinate := AvGpsCoordinate latitude: latitude asNumber longitude: longitude asNumber.	(distance := coordinate distanceTo: mission mapEntryForSwCorner gpsCoordinate) > 200		ifTrue: [			(self confirm: 'That waypoint is ', distance rounded asStringWithCommas, ' meters from the SW corner... Are you sure?')				ifFalse: [^self]].	name := FillInTheBlankMorph request: 'Enter GPS Location Name:' initialAnswer: 'GPS Location'.	(name isNil or: [name withBlanksTrimmed isEmpty])		ifTrue: [^self].	location := AvLocation new		name: name;		gpsCoordinate: coordinate;		computePositionFromOrigin: mission mapEntryForSwCorner;		yourself.	mapMorph addObject: location.	self status: 'added ', name, ' at ', location gpsCoordinate printString.	command := AvEditorCommand new		name: 'add location';		undoBlock: [mapMorph removeObject: location];		redoBlock: [mapMorph addObject: location];		yourself.	mapMorph addCommand: command.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 1/15/2006 14:18'!addGoal	| goalName goal |	goalName := FillInTheBlankMorph request: 'Enter Name of Goal' initialAnswer: 'Goal'.	goalName isEmpty		ifTrue: [^self].	mission addGoal: (goal := AvGoal new		name: goalName;		navigator: (AvWaypointNavigator newFor: mission);		owner: mission;		yourself).	self status: 'Added goal ', goalName.	selectedGoal := goal.	self changed: #goals; changed: #selectedGoal.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 1/27/2006 12:27'!addGoalSet	| goalSet addGoalSetSelector |	mapMorph hasSelection		ifFalse: [			(PopUpMenu confirm: 'You should select an object to add a goal set... Proceed without selecting?')				ifFalse: [^self status: 'Add new Goal Set operation cancelled...']].	goalSet := PopUpMenu		withCaption: 'Choose Goal Set Pattern' 		chooseFrom: #('Navigate to a cone' 'Navigate to a ramp cone').	goalSet = 0		ifTrue: [^self].	addGoalSetSelector := #(addNavigateToConeGoalSet addNavigateToRampConeGoalSet)		at: goalSet.	self perform: addGoalSetSelector! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 11/28/2004 19:49'!addLocation	| mapBox worldToMapTransform point command location |	self status: 'Click on map to add location'.	10 timesRepeat: [		(Delay forMilliseconds: 10) wait.		mapMorph world doOneCycle].	mapBox := mapMorph bounds.	worldToMapTransform := mapMorph translateWorldToMapBlock.	Cursor crossHair showWhile: [		point := Sensor waitButton].	(mapBox containsPoint: point)		ifTrue: [			| name |			self status: 'Enter name of new location'.			(name := self promptForName: 'Location') notNil				ifTrue: [					| position |					position := (worldToMapTransform value: point) rounded.					location := AvLocation new						name: name;						position: (AvPosition fromPoint: position);						yourself.					mapMorph addObject: location.					self status: 'added ', name, ' at ', position printString]				ifFalse: [self status: 'add location cancelled']]		ifFalse: [self status: 'add location cancelled'].	command := AvEditorCommand new		name: 'add location';		undoBlock: [mapMorph removeObject: location];		redoBlock: [mapMorph addObject: location];		yourself.	mapMorph addCommand: command.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/21/2004 08:30'!addPath	| mapBox worldToMapTransform point command path name |	self status: 'Click on map to start path'.	10 timesRepeat: [		(Delay forMilliseconds: 10) wait.		mapMorph world doOneCycle].	mapBox := mapMorph bounds.	worldToMapTransform := mapMorph translateWorldToMapBlock.	Cursor crossHair showWhile: [		path := AvPath new name: 'Unnamed'; yourself.		mapMorph addObject: path.		[mapBox containsPoint: (point := Sensor waitButton)] whileTrue: [			| position |			position := (worldToMapTransform value: point) rounded.			path addPoint: (AvPosition fromPoint: position).			self status: 'click on map to extend path, anywhere else to finish'.			mapMorph changed.			10 timesRepeat: [				(Delay forMilliseconds: 10) wait.				mapMorph world doOneCycle].			Sensor waitNoButton].		path size = 1			ifTrue: [				mapMorph removeObject: path.				^self status: 'A path must have at least two points'].		path isEmpty			ifTrue: [				mapMorph removeObject: path.				^self status: 'add path cancelled']].	self status: 'Enter name of new path'.	(name := self promptForName: 'Path') isNil		ifTrue: [			mapMorph removeObject: path.			^self status: 'add path cancelled'].	self status: 'Added path ', name.	path name: name.	command := AvEditorCommand new		name: 'add path';		undoBlock: [mapMorph removeObject: path];		redoBlock: [mapMorph addObject: path];		yourself.	mapMorph addCommand: command.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 1/20/2006 09:59'!copyMission	mission isNil		ifTrue: [^self inform: 'Please load a mission first before copying...'].	Cursor execute showWhile: [		| result |		result := OSProcess command: 'c:\huv\gumstix\pscp -p -l root -pw gumstix "missions\', mission name,			'.obj" 192.168.4.2:/mnt/mmc/av/missions/'.		result succeeded			ifTrue: [self status: 'Mission copy successful...']			ifFalse: [self status: 'Mission copy failed: ', result exitStatus printString]].! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 2/9/2006 09:53'!debugMenu	MenuMorph new		addStayUpItem;		addTitle: 'Mission Debug Menu';		add: 'Export Selected Map Objects' target: self action: #exportMapObjects;		addLine;		add: 'Set cone multiplier' target: self action: #setConeMultiplier;		add: 'Set cone difficulty' target: self action: #setConeDifficulty;		add: 'Set map Anchor point' target: self action: #setMapAnchorPoint;		addLine;		add: 'Insert point on Path/Area' target: self action: #insertPointOnPath;		add: 'Delete point from Path/Area' target: self action: #deletePointOnPath;		addLine;		add: 'Check Mission Goals' target: self action: #checkGoals;		add: 'Cone Cost Analysis' target: self action: #coneCostAnalysis;		addLine;		add: 'Compute Distance Between Two Points' target: self action: #computeDistanceBetweenTwoPoints;		add: 'Compute Bearing Between Two Points' target: self action: #computeBearingBetweenTwoPoints;		add: 'Compute Bounding Box of Area' target: self action: #computeBoundingBoxOfArea;		add: 'Compute Length of Path' target: self action: #computeLengthOfPath;		add: 'Add Property' target: self action: #addProperty;		add: 'Open Compass' target: self action: #openCompass;		addLine;		add: 'Set Visual Navigator Cone Color' target: self action: #setVisualNavigatorConeColor;		add: 'Apply Visual Navigator Cone Color' target: self action: #applyVisualNavigatorConeColor;		addLine;		add: 'Toggle Gps/Local Cursor' target: self action: #toggleLocalGpsCursor;		addLine;		add: 'Set Date on Gumstix' target: self action: #setRemoteDate;		addLine;		add: 'Inspect/Explore' subMenu: (MenuMorph new			addTitle: 'Inspect/Explore';			addStayUpItem;			add: 'Inspect Mission Editor' target: self action: #inspect;			add: 'Explore Mission Editor' target: self action: #explore;			addLine;			add: 'Inspect Mission' target: self action: #inspectMission;			add: 'Explore Mission' target: self action: #exploreMission;			addLine;			add: 'Inspect Selected Map Object' target: self action: #inspectSelectedMapObject;			add: 'Explore Selected Map Object' target: self action: #exploreSelectedMapObject;			addLine;			add: 'Inspect Selected Goal' target: self action: #inspectSelectedGoal;			add: 'Explore Selected Goal' target: self action: #exploreSelectedGoal;			yourself);		invokeModal! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/17/2004 18:04'!deleteSelection	| name |	name := mapMorph selectionDescription.	mapMorph		deleteSelectionWhenUndo: [:objects | objects do: [:each | each markNotDeleted]]		whenRedo: [:objects | objects do: [:each | each markDeleted]].	self status: 'Deleted ', name.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 11/28/2004 17:49'!importCourseObjects	| courseNames courseName file objects |	courseNames := (FileDirectory on: FileDirectory default pathName, '\courses') fileNames.	courseName := (PopUpMenu labelArray: courseNames)		startUpWithCaption: 'Choose a course to import:'.	courseName isNil | (courseName = 0)		ifTrue: [^self status: 'import cancelled'].	courseName := courseNames at: courseName.	file := FileStream readOnlyFileNamed: 'courses\', courseName.	objects := file fileInObjectAndCode.	file close.	(objects isKindOf: Dictionary)		ifTrue: [objects := objects values asOrderedCollection].	mission map mapEntries: objects.	mapMorph objects: objects.	mapMorph changed.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 12/1/2004 22:16'!newMission	mission := AvGoalBasedMission new name: ''.	self readMapNamed: 'blankMap'.	self updateNewMission.	self status: 'New Mission'.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 1/12/2006 11:28'!openMission	| missionFileNames missionNames missionIndex missionFileName |	missionFileNames := (FileDirectory on: FileDirectory default pathName, '\missions') fileNames.	missionNames := missionFileNames collect: [:each | each readStream upTo: $.].	missionNames isEmpty		ifTrue: [^self status: 'No saved missions...'].	missionIndex := (PopUpMenu labelArray: missionNames lines: #())		startUpWithCaption: 'Choose a mission to load:'.	missionIndex = 0		ifTrue: [^self status: 'Load cancelled'].	missionFileName := missionFileNames at: missionIndex.	mission := AvMission fromFilename: 'missions\', missionFileName.	self updateNewMission.	self status: 'Now editing mission: ', mission name! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/13/2004 11:44'!redo	| text |	text := mapMorph nextRedoLabel.	mapMorph redo.	self status: text.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 1/27/2006 19:45'!runMission	mission isNil		ifTrue: [^self inform: 'Please load a mission first before trying to run it...'].	Cursor execute showWhile: [		| result vehicleName |		vehicleName := self pickVehicleName.		vehicleName isNil			ifTrue: [^self status: 'Vehicle not chosen...'].		(FileStream forceNewFileNamed: 'mission.txt')			nextPutAll: vehicleName;			nextPutAll: String lf, mission name, '.obj';			close.		result := OSProcess command: 'c:\huv\gumstix\pscp -p -l root -pw gumstix mission.txt 192.168.4.2:/mnt/mmc/av/'.		result succeeded			ifTrue: [				result := OSProcess command: 'c:\huv\gumstix\plink -l root -pw gumstix 192.168.4.2 /mnt/mmc/av/avRemote'.				result succeeded					ifTrue: [self status: 'Mission running...']					ifFalse: [self status: 'Image launch failed: ', result exitStatus printString]]			ifFalse: [self status: 'Mission file copy failed: ', result exitStatus printString]].! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 1/18/2006 16:42'!saveMission	| file |	Cursor execute showWhile: [		mission name: (self textFieldContentsFor: #missionNameField) contents asString.		(FileDirectory on: FileDirectory default pathName, '\missions') 			deleteFileNamed: mission name, '.obj'			ifAbsent: [].		self			removeDeletedObjects;			fixupGoalOwners.		file := SmartRefStream newFileNamed: 'missions\', mission name, '.obj'.		file nextPut: mission.		file close.		mapMorph clearUndo; clearRedo.		self			undoChanged;			status: 'Mission ', mission name, ' saved...'].! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/16/2004 22:47'!selectCloseQuartersNavigatorLineUp: aString	self selectedGoal navigator lineUpFrom: aString.	(self textFieldFor: #closeQuartersNavigatorLineUp) contents: aString.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 12/27/2005 21:54'!selectedGoal: goalWrapper	selectedGoal := goalWrapper isNil		ifTrue: [nil]		ifFalse: [goalWrapper goal].	self changed: #selectedGoal.	selectedGoal isNil		ifTrue: [self setNavigatorName: '']		ifFalse: [			self				setNavigatorName: selectedGoal navigatorDescriptiveName;				setGoalRuleName: selectedGoal executionRule asString].! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/16/2004 17:45'!setCloseQuartersNavigatorAreaFromSelection	| selection |	selection := mapMorph selectedObjects.	selection size = 1		ifFalse: [^self inform: 'Please only select one area to use this button...'].	selection := selection first.	selection isArea		ifTrue: [			self selectedGoal navigator allowableArea: selection.			(self textFieldFor: #closeQuartersNavigatorArea) contents: selection name]		ifFalse: [self inform: 'Please select an area to use this button...'].! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/16/2004 20:12'!setCloseQuartersNavigatorFinalHeading	| compass heading |	heading := self selectedGoal navigator finalHeading.	heading isNil		ifTrue: [heading := 0.0].	self status: 'Choose the final heading for this goal, press the center to close.'.	(compass := AvCompassMorph new)		extent: 125 @ 125;		heading: heading;		openInHand.	compass when: #gotHeading send: #closeQuartersNavigatorFinalHeading: to: self.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 12/28/2005 07:32'!setGoalRuleName: aString 	self selectedGoal isNil		ifTrue: [			self status: 'Select a goal before choosing a rule...'.			self addNavigatorPanelFor: nil.			^(self textFieldFor: #goalRuleName)				contents: '';				extent: 76 @ 21].	(self textFieldFor: #goalRuleName)		contents: aString;		extent: 76 @ 21.	self selectedGoal setExecutionRuleFrom: aString! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/16/2004 17:36'!setMapHeading	| compass heading |	heading := mission map offsetHeading.	heading isNil		ifTrue: [heading := 0.0].	self status: 'Choose the map offset heading, press the center to close.'.	(compass := AvCompassMorph new)		extent: 125 @ 125;		heading: heading;		openInHand.	compass when: #gotHeading send: #offsetHeading: to: self.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/13/2004 09:00'!setMissionMapName: aString 	self readMapNamed: aString.	mapMorph changed.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 1/27/2006 12:33'!setNavigatorName: aString 	self selectedGoal isNil		ifTrue: [			aString isEmpty				ifFalse: [self status: 'Select a goal before choosing a navigator...'].			self addNavigatorPanelFor: nil.			^(self textFieldFor: #navigatorName)				contents: '';				extent: 200 @ 21].	(self textFieldFor: #navigatorName)		contents: aString;		extent: 200 @ 21.	self selectedGoal setNavigatorFrom: aString for: mission.	self addNavigatorPanelFor: self selectedGoal navigator.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/16/2004 17:46'!setRampNavigatorBottomFromSelection	| selection |	selection := mapMorph selectedObjects.	selection size = 1		ifFalse: [^self inform: 'Please only select one location to use this button...'].	selection := selection first.	selection isLocation		ifTrue: [			self selectedGoal navigator bottomLocation: selection.			(self textFieldFor: #rampNavigatorBottomLocation) contents: selection name]		ifFalse: [self inform: 'Please select a location to use this button...'].! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/16/2004 17:46'!setRampNavigatorTopFromSelection	| selection |	selection := mapMorph selectedObjects.	selection size = 1		ifFalse: [^self inform: 'Please only select one location to use this button...'].	selection := selection first.	selection isLocation		ifTrue: [			self selectedGoal navigator topLocation: selection.			(self textFieldFor: #rampNavigatorTopLocation) contents: selection name]		ifFalse: [self inform: 'Please select a location to use this button...'].! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 1/6/2006 09:07'!setStartupNavigatorLocationFromSelection	| selection |	selection := mapMorph selectedObjects.	selection size = 1		ifFalse: [^self inform: 'Please only select one location to use this button...'].	selection := selection first.	selection isLocation		ifTrue: [			self selectedGoal navigator startLocation: selection.			(self textFieldFor: #startupNavigatorLocation) contents: selection name]		ifFalse: [self inform: 'Please select a location to use this button...'].! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/17/2004 14:45'!setVisualNavigatorTargetColor	ColorPickerMorph new		choseModalityFromPreference;		sourceHand: window activeHand;		target: self;		selector: #setVisualNavigatorTargetColor:;		originalColor: self selectedGoal navigator color;		putUpFor: window near: window fullBoundsInWorld! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/17/2004 14:49'!setVisualNavigatorTargetColor: aColor	| form |	aColor isNil		ifTrue: [^self].	self selectedGoal navigator color: aColor.	form := Form fromFileNamed: 'icons\setColorIcon.bmp'.	form		fillColor: aColor;		border: form boundingBox width: 1.	(buttons at: #visualNavigatorTargetColor)		labelGraphic: form;		changed.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/16/2004 22:56'!setVisualNavigatorTargetFromSelection	| selection |	selection := mapMorph selectedObjects.	selection size = 1		ifFalse: [^self inform: 'Please only select one location to use this button...'].	selection := selection first.	selection isLocation		ifTrue: [			self selectedGoal navigator targetLocation: selection.			(self textFieldFor: #visualNavigatorTargetLocation) contents: selection name]		ifFalse: [self inform: 'Please select a location to use this button...'].! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/17/2004 13:39'!setVisualNavigatorTargetType: aString	self selectedGoal navigator typeFrom: aString.	(self textFieldFor: #visualNavigatorTargetType) contents: aString.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'Jon 11/28/2004 10:01'!setWaypointNavigatorPathFromSelection	| selection |	selection := mapMorph selectedObjects.	selection size = 1		ifFalse: [^self inform: 'Please only select one path or one location to use this button...'].	selection := selection first.	selection isPath | selection isLocation		ifTrue: [			self selectedGoal navigator destinationLocation: selection.			selection isLocation				ifTrue: [self buildWaypointPathFor: self selectedGoal navigator].			(self textFieldFor: #waypointNavigatorLocation) contents: selection name]		ifFalse: [self inform: 'Please select a path or location to use this button...'].! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/16/2004 12:20'!showingGridOverlay	^mapMorph showingGridOverlay.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/16/2004 12:21'!toggleGridOverlay	mapMorph showingGridOverlay		ifTrue: [mapMorph gridOverlaySize: 0]		ifFalse: [mapMorph gridOverlaySize: 10].	mapMorph changed.! !!AvMissionEditor methodsFor: 'ui handling' stamp: 'jon 11/13/2004 11:44'!undo	| text |	text := mapMorph nextUndoLabel.	mapMorph undo.	self status: text.! !!AvMissionEditor methodsFor: 'event handling' stamp: 'jon 11/13/2004 17:00'!handleDrag	self status: mapMorph selectionDescription! !!AvMissionEditor methodsFor: 'event handling' stamp: 'jon 11/13/2004 15:46'!objectsChanged	mission map mapEntries: mapMorph objects copy.! !!AvMissionEditor methodsFor: 'event handling' stamp: 'jon 11/12/2004 16:45'!selectionChanged	self status: 'Selection: ', mapMorph selectionDescription.! !!AvMissionEditor methodsFor: 'event handling' stamp: 'jon 11/12/2004 21:30'!undoChanged	(buttons at: #undo) setBalloonText: mapMorph nextUndoLabel.	(buttons at: #redo) setBalloonText: mapMorph nextRedoLabel.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'Jon 12/14/2004 13:14'!addProperty	| selection propertyName value |	selection := mapMorph selectedObjects.	selection isEmpty		ifTrue: [^self inform: 'Nothing selected...'].	selection size = 1		ifFalse: [^self inform: 'You can only add a property to one object...'].	propertyName := PopUpMenu		withCaption: 'Choose Property Name' 		chooseFrom: #('multiplier' 'difficulty' 'exclusionZone' 'other').	propertyName = 0		ifTrue: [^self status: 'Add property cancelled'].	propertyName := {#multiplier. #difficulty. #exclusionZone. nil}		at: propertyName.	propertyName isNil		ifTrue: [			propertyName := FillInTheBlankMorph request: 'Enter property name'.			propertyName isEmpty				ifTrue: [^self status: 'Add property cancelled']].	propertyName := propertyName asSymbol.	value := FillInTheBlankMorph request: 'Enter property value' initialAnswer: '#someSmalltalkExpression'.	value isEmpty		ifTrue: [^self status: 'Add property cancelled'].	value := [Compiler evaluate: value] on: Error do: [:exception |		self inform: 'error in property value: ', exception messageText.		^self status: 'Add property cancelled'].	selection first addPropertyNamed: propertyName withValue: value.	self status: 'Added property: ', propertyName, ' value: ', value printString.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/21/2004 23:16'!applyVisualNavigatorConeColor	mission allGoals do: [:eachGoal |		(eachGoal navigator notNil and: [eachGoal navigator isVisualNavigator and: [eachGoal navigator type == #cone]])			ifTrue: [eachGoal navigator color: ConeColor]].	self status: 'Visual navigator cone color set...'! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'Jon 1/6/2006 09:12'!checkGoals	"Check all the goals to make sure everything they need has been set."	| bad stream |	mission hasStartGoal		ifFalse: [^self inform: 'Start goal missing...'].	mission hasShutdownGoal		ifFalse: [^self inform: 'Shutdown goal missing...'].	bad := OrderedCollection new.	mission allGoals do: [:each |		each hasAllRequiredValues			ifFalse: [bad add: each]].	bad isEmpty		ifTrue: [^self inform: 'All goals set...'].	stream := WriteStream on: (String new: 100).	stream nextPutAll: 'Goals with missing attributes:'; cr.	bad do: [:each |		stream cr; nextPutAll: each name].	self inform: stream contents! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/21/2004 14:51'!computeBearingBetweenTwoPoints	| mapBox firstPoint secondPoint bearing |	self status: 'Click on map for first point...'.	10 timesRepeat: [		(Delay forMilliseconds: 10) wait.		mapMorph world doOneCycle].	mapBox := mapMorph bounds.	Cursor crossHair showWhile: [firstPoint := Sensor waitButton. Sensor waitNoButton].	(mapBox containsPoint: firstPoint)		ifFalse: [^self status: 'Cancelled compute bearing...'].	self status: 'Click on map for second point...'.	10 timesRepeat: [		(Delay forMilliseconds: 10) wait.		mapMorph world doOneCycle].	Cursor crossHair showWhile: [secondPoint := Sensor waitButton].	(mapBox containsPoint: secondPoint)		ifFalse: [^self status: 'Cancelled compute bearing...'].	bearing := ((mapMorph translateWorldToMap: firstPoint) bearingToPoint: (mapMorph translateWorldToMap: secondPoint)).	bearing := (180 - bearing) \\ 360.	self status: 'Bearing between those two points is: ', (bearing roundTo: 0.1) printString, ' degrees'.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/17/2004 12:15'!computeBoundingBoxOfArea	| selection extent |	selection := mapMorph selectedObjects.	selection size = 1		ifFalse: [^self inform: 'Please only select one area to compute bounding box of...'].	selection := selection first.	selection isArea		ifTrue: [			extent := (Rectangle encompassing: (selection points collect: [:each | each mapPoint])) extent.			extent := (extent x roundTo: 0.01) @ (extent y roundTo: 0.01).			self status: selection name, ' encompasses ', extent x printString, ' x ', extent y printString, ' meters']		ifFalse: [self inform: 'Please select an area to use this button...'].! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/17/2004 11:56'!computeDistanceBetweenTwoPoints	| mapBox firstPoint secondPoint distance |	self status: 'Click on map for first point...'.	10 timesRepeat: [		(Delay forMilliseconds: 10) wait.		mapMorph world doOneCycle].	mapBox := mapMorph bounds.	Cursor crossHair showWhile: [firstPoint := Sensor waitButton. Sensor waitNoButton].	(mapBox containsPoint: firstPoint)		ifFalse: [^self status: 'Cancelled compute distance...'].	self status: 'Click on map for second point...'.	10 timesRepeat: [		(Delay forMilliseconds: 10) wait.		mapMorph world doOneCycle].	Cursor crossHair showWhile: [secondPoint := Sensor waitButton].	(mapBox containsPoint: secondPoint)		ifFalse: [^self status: 'Cancelled compute distance...'].	distance := (mapMorph translateWorldToMap: firstPoint) dist: (mapMorph translateWorldToMap: secondPoint).	self status: 'Distance between those two points is: ', (distance roundTo: 0.01) printString, ' meters'.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'Jon 10/27/2007 18:21'!computeLengthOfPath	| selection length |	selection := mapMorph selectedObjects.	selection isEmpty		ifTrue: [^self inform: 'Please select one or more paths to compute length of...'].	(selection reject: [:each | each isPath]) notEmpty		ifTrue: [^self inform: 'Please select only paths to compute length...'].	length := selection		inject: 0		into: [:sum :each | sum + each length].	self status: 'Path(s) are total of ', (length roundTo: 0.01) printString, ' meters in length'! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'Jon 1/27/2006 12:41'!coneCostAnalysis	| start finish bonusCones combinations estimatedTimes stream badCone |	start := self mapObjectNamed: 'Start'.	finish := self mapObjectNamed: 'Finish Cone'.	bonusCones := ((mission map mapEntries select: [:each |		each isLocation and: [each name includesSubString: 'Bonus Cone']])			asSortedCollection: [:a :b | a name <= b name]) asArray.	(badCone := self checkBonusConesForProperties: bonusCones) isNil		ifFalse: [			mapMorph setSelection: badCone; changed.			^self status: 'Cone Cost Analysis cancelled - missing property in ', badCone name].	combinations := self allCombinationsFor: bonusCones size.	estimatedTimes := ((combinations collect: [:each |		| cones |		cones := each collect: [:eachIndex | bonusCones at: eachIndex].		Array with: each with: (self computeEstimatedCostFor: start to: finish using: cones)])			asSortedCollection: [:a :b | a last <= b last]) asArray.	stream := WriteStream on: (String new: 1000).	stream		cr; nextPutAll: 'Cone Cost Analysis'.	bonusCones do: [:each |		stream			cr; cr; nextPutAll: each name;			cr; tab; nextPutAll: 'Multiplier: ', (each propertyNamed: #multiplier) printString;			cr; tab; nextPutAll: 'Difficulty: ', (each propertyNamed: #difficulty) printString].	stream cr.	estimatedTimes do: [:eachPair |			stream cr; nextPutAll: 'Cones: '.			eachPair first isEmpty				ifTrue: [stream nextPutAll: 'none']				ifFalse: [stream nextPutAll: eachPair first printString].			stream				nextPutAll: ' - ';				nextPutAll: (eachPair last roundTo: 0.01) printString].	Workspace new		contents: stream contents;		openLabel: 'Cone Cost Analysis'.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/21/2004 15:05'!deletePointOnPath	| object point editorCommand |	self status: 'Click on path/area segment to remove point from'.	10 timesRepeat: [		(Delay forMilliseconds: 10) wait.		mapMorph world doOneCycle].	Cursor crossHair showWhile: [		Sensor waitButton].	object := mapMorph objectUnder: (point := Sensor cursorPoint).	object isNil		ifTrue: [^self status: 'Delete Point Cancelled.'].	object isPath | object isArea		ifFalse: [^self status: 'Cancelled - you must click on a path/area segment.'].	(editorCommand := object deletePointAt: point using: mapMorph translateWorldToMapBlock) isNil		ifTrue: [self status: 'Delete Point Cancelled.']		ifFalse: [			mapMorph				addCommand: editorCommand;				setSelection: object.			self status: 'Deleted point from ', object name.			mapMorph changed].! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/17/2004 11:36'!exploreMission	mission explore.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/17/2004 11:40'!exploreSelectedGoal	self selectedGoal isNil		ifTrue: [^self inform: 'No goal selected...'].	self selectedGoal explore.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/17/2004 11:38'!exploreSelectedMapObject	| selection |	selection := mapMorph selectedObjects.	selection isEmpty		ifTrue: [^self inform: 'Nothing selected...'].	selection size = 1		ifTrue: [selection first explore]		ifFalse: [selection copy explore].! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'Jon 11/28/2004 12:11'!exportMapObjects	| selection filename directory file |	selection := mapMorph selectedObjects.	selection isEmpty	ifTrue: [^self inform: 'Please select one or more objects to export...'].	filename := FillInTheBlankMorph request: 'Enter filename to export to:' initialAnswer: 'missionObjects'.	(filename isNil or: [filename withBlanksTrimmed isEmpty])		ifTrue: [^self status: 'Export cancelled...'].	filename := filename withBlanksTrimmed.	directory := FileList2 modalFolderSelector.	directory isNil		ifTrue: [^self status: 'Export cancelled...'].	(directory fileExists: filename)		ifTrue: [			(self confirm: 'Overwrite existing file ', filename, '?')				ifFalse: [^self status: 'Export cancelled...']].	directory deleteFileNamed: filename ifAbsent: [].	file := SmartRefStream newFileNamed: directory fullName, '\', filename, '.obj'.	file nextPut: selection.	file close.	self status: selection size printString, ' selected objects written to ', filename.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/21/2004 15:05'!insertPointOnPath	| object point editorCommand |	self status: 'Click on path/area segment to add a point to'.	10 timesRepeat: [		(Delay forMilliseconds: 10) wait.		mapMorph world doOneCycle].	Cursor crossHair showWhile: [		Sensor waitButton].	object := mapMorph objectUnder: (point := Sensor cursorPoint).	object isNil		ifTrue: [^self status: 'Insert Point Cancelled.'].	object isPath | object isArea		ifFalse: [^self status: 'Cancelled - you must click on a path/area segment.'].	(editorCommand := object insertPointAt: point using: mapMorph translateWorldToMapBlock) isNil		ifTrue: [self status: 'Insert Point Cancelled.']		ifFalse: [			mapMorph				addCommand: editorCommand;				setSelection: object.			self status: 'Inserted point on ', object name.			mapMorph changed].! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/17/2004 11:36'!inspectMission	mission inspect.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/17/2004 11:40'!inspectSelectedGoal	self selectedGoal isNil		ifTrue: [^self inform: 'No goal selected...'].	self selectedGoal inspect.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/17/2004 11:39'!inspectSelectedMapObject	| selection |	selection := mapMorph selectedObjects.	selection isEmpty		ifTrue: [^self inform: 'Nothing selected...'].	selection size = 1		ifTrue: [selection first inspect]		ifFalse: [selection copy inspect].! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/21/2004 14:44'!openCompass	AvCompassMorph new		extent: 125 @ 125;		heading: 0;		openInHand.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'Jon 1/27/2006 12:53'!setConeDifficulty	| selection cone value initialValue |	selection := mapMorph selectedObjects.	selection isEmpty		ifTrue: [^self status: 'Nothing selected...'].	(selection size = 1 and: [selection first isPointMapObject])		ifFalse: [^self status: 'Must have exactly one object selected...'].	cone := selection first.	initialValue := (cone hasPropertyNamed: #difficulty)		ifTrue: [(cone propertyNamed: #difficulty) printString]		ifFalse: ['0'].	value := FillInTheBlank 		request: 'Enter the cone difficulty (# of seconds extra to touch cone)'		initialAnswer: initialValue.	(value isNil or: [value withBlanksTrimmed isEmpty])		ifTrue: [^self status: 'Set Cone Multiplier cancelled...'].	value := value withBlanksTrimmed asNumber.	selection first addPropertyNamed: #difficulty withValue: value.	self status: 'Set difficulty to: ', value printString.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'Jon 1/27/2006 12:51'!setConeMultiplier	| selection cone value initialValue |	selection := mapMorph selectedObjects.	selection isEmpty		ifTrue: [^self status: 'Nothing selected...'].	(selection size = 1 and: [selection first isPointMapObject])		ifFalse: [^self status: 'Must have exactly one object selected...'].	cone := selection first.	initialValue := (cone hasPropertyNamed: #multiplier)		ifTrue: [(cone propertyNamed: #multiplier) printString]		ifFalse: ['1.0'].	value := FillInTheBlank 		request: 'Enter the cone multiplier (between 0.0 and 1.0)'		initialAnswer: initialValue.	(value isNil or: [value withBlanksTrimmed isEmpty])		ifTrue: [^self status: 'Set Cone Multiplier cancelled...'].	value := value withBlanksTrimmed asNumber.	(value between: 0.0 and: 1.0)		ifFalse: [^self status: 'Please enter a value between 0.0 and 1.0...'].	selection first addPropertyNamed: #multiplier withValue: value.	self status: 'Set multiplier value: ', value printString.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'Jon 2/9/2006 09:59'!setMapAnchorPoint	| latitude longitude coordinate location command |	(mapMorph objects		detect: [:each | each name = 'Anchor']		ifNone: [nil]) notNil			ifTrue: [^self inform: 'Anchor location already exists...Please delete it before adding another Anchor location.'].	latitude := FillInTheBlankMorph request: 'Enter GPS Latitude:' initialAnswer: '00.0000'.	(latitude isNil or: [latitude withBlanksTrimmed isEmpty])		ifTrue: [^self].	longitude := FillInTheBlankMorph request: 'Enter GPS Longitude:' initialAnswer: '00.0000'.	(longitude isNil or: [longitude withBlanksTrimmed isEmpty])		ifTrue: [^self].	coordinate := AvGpsCoordinate latitude: latitude asNumber longitude: longitude asNumber.	location := AvLocation new		name: 'Anchor';		position: (AvPosition fromPoint: 0.0 @ 0.0);		gpsCoordinate: coordinate;		yourself.	mapMorph addObject: location.	self status: 'added Anchor point...'.	command := AvEditorCommand new		name: 'add anchor location';		undoBlock: [mapMorph removeObject: location];		redoBlock: [mapMorph addObject: location];		yourself.	mapMorph addCommand: command.! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'Jon 1/20/2006 10:37'!setRemoteDate	| result |	result := OSProcess command: 'c:\huv\gumstix\plink -l root -pw gumstix 192.168.4.2 /bin/busybox rdate -s pc'.	result succeeded		ifTrue: [self inform: 'Remote Date set...']		ifFalse: [self inform: 'Failed setting the remote date: ', result exitStatus printString].! !!AvMissionEditor methodsFor: 'debug menu' stamp: 'jon 11/17/2004 15:37'!setVisualNavigatorConeColor	ColorPickerMorph new		choseModalityFromPreference;		sourceHand: window activeHand;		target: self;		selector: #setConeColor:;		originalColor: ConeColor;		putUpFor: window near: window fullBoundsInWorld! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 11/28/2004 18:37'!addExclusionArea	| box mapBox worldToMapTransform command area name |	self status: 'Click and drag box for exclusion area'.	10 timesRepeat: [		(Delay forMilliseconds: 10) wait.		mapMorph world doOneCycle].	mapBox := mapMorph bounds.	worldToMapTransform := mapMorph translateWorldToMapBlock.	box := Rectangle fromUser.	(mapBox containsRect: box)		ifFalse: [^self status: 'add exclusion area cancelled'].	self status: 'Enter name of new area'.	(name := self promptForName: 'Exclusion Area') isNil		ifTrue: [^self status: 'add exclusion area cancelled'].	area := AvArea new name: name; yourself.	mapMorph addObject: area.	box corners do: [:each |		area addPoint: (AvPosition fromPoint: (worldToMapTransform value: each))].	area addPropertyNamed: #exclusionZone withValue: true.	self status: 'Added exclusion area ', name.	command := AvEditorCommand new		name: 'add area';		undoBlock: [mapMorph removeObject: area];		redoBlock: [mapMorph addObject: area];		yourself.	mapMorph addCommand: command.! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/21/2004 23:05'!addNavigateToConeGoalSet	| coneName goalSet |	coneName := (mapMorph selectedObjects size = 1 and: [mapMorph selectedObjects first isLocation])		ifTrue: [mapMorph selectedObjects first name]		ifFalse: ['Cone'].	mission addGoal: (goalSet := (AvGoal new name: 'Navigate to ', coneName; navigator: nil; yourself)).	{{'Navigate to ', coneName . AvWaypointNavigator} .		{'Find ', coneName . AvVisualNavigator} .		{'Touch ', coneName . AvVisualNavigator} .		{'Turn Around' . AvCloseQuartersNavigator}} do: [:eachPair |			goalSet addGoal: (AvGoal new name: eachPair first; navigator: eachPair last new; yourself)].	self status: 'Added Navigate to Cone goal set '.	selectedGoal := goalSet.	self changed: #goalsForList; changed: #selectedGoal.! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/21/2004 23:06'!addNavigateToRampConeGoalSet	| coneName goalSet |	coneName := (mapMorph selectedObjects size = 1 and: [mapMorph selectedObjects first isLocation])		ifTrue: [mapMorph selectedObjects first name]		ifFalse: ['Cone'].	mission addGoal: (goalSet := (AvGoal new name: 'Navigate to Ramp/', coneName; navigator: nil; yourself)).	{{'Navigate to base of ramp' . AvWaypointNavigator} .		{'Line up with ramp' . AvCloseQuartersNavigator} .		{'Go up ramp' . AvRampNavigator} .		{'Navigate to ', coneName . AvWaypointNavigator} .		{'Find ', coneName . AvVisualNavigator} .		{'Touch ', coneName . AvVisualNavigator} .		{'Turn Around' . AvCloseQuartersNavigator} .		{'Navigate to top of ramp' . AvWaypointNavigator} .		{'Line up with ramp' . AvCloseQuartersNavigator} .		{'Go down ramp' . AvRampNavigator}} do: [:eachPair |			goalSet addGoal: (AvGoal new name: eachPair first; navigator: eachPair last new; yourself)].	self status: 'Added navigate to ramp cone goal set '.	selectedGoal := goalSet.	self changed: #goalsForList; changed: #selectedGoal.! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/21/2004 08:38'!addPolygonalArea	| mapBox worldToMapTransform point command area name |	self status: 'Click on map to start area'.	10 timesRepeat: [		(Delay forMilliseconds: 10) wait.		mapMorph world doOneCycle].	mapBox := mapMorph bounds.	worldToMapTransform := mapMorph translateWorldToMapBlock.	Cursor crossHair showWhile: [		area := AvArea new name: 'Unnamed'; yourself.		mapMorph addObject: area.		[mapBox containsPoint: (point := Sensor waitButton)] whileTrue: [			| position |			position := (worldToMapTransform value: point) rounded.			area addPoint: (AvPosition fromPoint: position).			self status: 'click on map to extend area, anywhere else to finish'.			mapMorph changed.			10 timesRepeat: [				(Delay forMilliseconds: 10) wait.				mapMorph world doOneCycle].			Sensor waitNoButton].		area hasAtLeastThreePoints			ifFalse: [				mapMorph removeObject: area.				^self status: 'An area must have at least three points'].		area isEmpty			ifTrue: [				mapMorph removeObject: area.				^self status: 'add area cancelled']].	self status: 'Enter name of new area'.	(name := self promptForName: 'Area') isNil		ifTrue: [			mapMorph removeObject: area.			^self status: 'add area cancelled'].	self status: 'Added area ', name.	area name: name.	command := AvEditorCommand new		name: 'add area';		undoBlock: [mapMorph removeObject: area];		redoBlock: [mapMorph addObject: area];		yourself.	mapMorph addCommand: command.! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/21/2004 08:40'!addRectangularArea	| box mapBox worldToMapTransform command area name |	self status: 'Click and drag box for area'.	10 timesRepeat: [		(Delay forMilliseconds: 10) wait.		mapMorph world doOneCycle].	mapBox := mapMorph bounds.	worldToMapTransform := mapMorph translateWorldToMapBlock.	box := Rectangle fromUser.	(mapBox containsRect: box)		ifFalse: [^self status: 'add area cancelled'].	self status: 'Enter name of new area'.	(name := self promptForName: 'Area') isNil		ifTrue: [^self status: 'add area cancelled'].	area := AvArea new name: name; yourself.	mapMorph addObject: area.	box corners do: [:each |		area addPoint: (AvPosition fromPoint: (worldToMapTransform value: each))].	self status: 'Added area ', name.	command := AvEditorCommand new		name: 'add area';		undoBlock: [mapMorph removeObject: area];		redoBlock: [mapMorph addObject: area];		yourself.	mapMorph addCommand: command.! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/21/2004 11:06'!allCombinationsFor: coneCount	| combinations slotCount |	combinations := OrderedCollection new.	slotCount := coneCount.	(1 to: slotCount) do: [:eachCombinationSize |		(1 to: slotCount) combinations: eachCombinationSize atATimeDo: [:eachCombination |			eachCombination permutationsDo: [:each | combinations add: each copy]]].	combinations add: #().	^combinations.! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 11/28/2004 10:04'!buildWaypointPathFor: navigator	navigator waypoints isNil		ifTrue: [self status: 'Unable to replan path to destination location...']		ifFalse: [			| path |			path := AvPath new name: 'Waypoint path to ', navigator destinationLocation name; yourself.			navigator waypoints do: [:each |				path addPoint: each].			mapMorph addObject: path; changed].! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 1/27/2006 12:37'!checkBonusConesForProperties: cones	cones do: [:each |		(each hasPropertyNamed: #multiplier)			ifFalse: [^each].		(each hasPropertyNamed: #difficulty)			ifFalse: [^each]].	^nil! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/16/2004 20:16'!closeQuartersNavigatorFinalHeading	^self selectedGoal navigator finalHeading! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/16/2004 20:14'!closeQuartersNavigatorFinalHeading: heading	self selectedGoal navigator finalHeading: heading.	self status: 'Close quarters navigator final heading set to ', heading printString, ''.! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/16/2004 20:20'!closeQuartersNavigatorFinalHeadingString	| heading |	heading := self selectedGoal navigator finalHeading.	^heading isNil		ifTrue: ['not set']		ifFalse: [heading printString, ''].! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/20/2004 22:05'!computeEstimatedCostFor: start to: finish using: cones	| multipliers leg multiplier difficulty speed |	cones isEmpty		ifTrue: [^start position distanceTo: finish position].	"Speed is measured in metres per second."	speed := 1.	multipliers := cones collect: [:each | each propertyNamed: #multiplier].	difficulty := cones collect: [:each | each propertyNamed: #difficulty].	leg := (start position distanceTo: cones first position) * speed.	1 to: cones size - 1 do: [:eachIndex |		leg := leg + (((cones at: eachIndex) position distanceTo: (cones at: eachIndex + 1) position) * speed)].	leg := leg + ((cones last position distanceTo: finish position) * speed).	leg := difficulty inject: leg into: [:sum :each | sum + each].	multiplier := multipliers inject: 1 into: [:sum :each | sum * each].	^leg * multiplier.! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 12/14/2004 12:41'!cursorCoordinateString	^showGps		ifTrue: [self cursorGpsString]		ifFalse: [self cursorLocalString]! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 11/26/2004 15:36'!cursorGpsString	| mapPoint cursorPoint |	mission hasMapEntryForSwCorner		ifFalse: [^'no Anchor GPS coordinate on map...'].	cursorPoint := Sensor cursorPoint.	(mapMorph bounds containsPoint: cursorPoint)		ifFalse: [^'Cursor: off map...'].	mapPoint := mapMorph translateWorldToMap: cursorPoint.	^'Cursor: ', (mission mapEntryForSwCorner gpsCoordinate offsetByMeters: mapPoint) simplePrintString! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 12/14/2004 12:39'!cursorLocalString	| mapPoint cursorPoint x y |	cursorPoint := Sensor cursorPoint.	(mapMorph bounds containsPoint: cursorPoint)		ifFalse: [^'Cursor: off map...'].	mapPoint := mapMorph translateWorldToMap: cursorPoint.	x := (mapPoint x roundTo: 0.01).	x := (x = (mapPoint x roundTo: 0.1))		ifTrue: [x printString, '0']		ifFalse: [x printString].	y := (mapPoint y roundTo: 0.01).	y := (y = (mapPoint y roundTo: 0.1))		ifTrue: [y printString, '0']		ifFalse: [y printString].	^'Cursor: ', x, ' @ ', y! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 1/27/2006 12:32'!deleteGoal	(self confirm: '  Delete Goal ', selectedGoal name, '?  ')		ifFalse: [^self].	selectedGoal hasSubGoals		ifTrue: [			| subSize |			subSize := selectedGoal allSubGoals size.			(self confirm: '  Goal ', selectedGoal name, ' has ', subSize printString, ' sub-goals. Delete it anyway?  ')				ifFalse: [^self]].	mission removeGoal: selectedGoal.	selectedGoal := mission goals isEmpty		ifTrue: [nil]		ifFalse: [mission goals last].	self setNavigatorName: (selectedGoal isNil		ifTrue: ['']		ifFalse: [selectedGoal navigatorDescriptiveName]).	self changed: #goalsForList; changed: #selectedGoal.! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 1/18/2006 16:45'!fixupGoalOwners	"Go through all the goals, and ensure that all their owners are set."	mission allGoals do: [:each |		each owner: (mission parentGoalFor: each)].! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/13/2004 21:23'!goalMenu: aMenu	^aMenu		addStayUpItem;		addTitle: 'Goal Menu';		addList: #(			('rename goal' renameGoal 'rename the selected goal')			('delete goal' deleteGoal 'delete the selected goal')			-			('insert new goal before' insertNewGoal 'insert a new goal before the selected one'))! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/13/2004 21:32'!insertNewGoal	| goal newName |	goal := self selectedGoal.	newName := FillInTheBlankMorph request: 'Enter name of goal to insert:' initialAnswer: 'Goal'.	(newName isNil or: [newName withBlanksTrimmed isEmpty])		ifTrue: [^self].	mission goals add: (AvGoal new name: newName) before: goal.	self changed: #goals! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/16/2004 17:18'!offsetHeading: heading	mission map offsetHeading: heading.	self status: 'Map offset heading changed to ', heading printString, ''.! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/16/2004 20:47'!offsetHeadingString	| heading |	heading := mission map offsetHeading.	^heading isNil		ifTrue: ['not set']		ifFalse: [heading printString, ''].! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/13/2004 21:22'!perform: selector orSendTo: otherTarget	self perform: selector! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 1/27/2006 19:40'!pickVehicleName	| fileNames vehicleNames selection |	fileNames := (FileDirectory on: FileDirectory default pathName, '\devices') fileNames.	vehicleNames := fileNames reject: [:eachName |		(FileStream readOnlyFileNamed: 'devices\', eachName) contentsOfEntireFile includesSubString: 'ProductInformation'].	selection := PopUpMenu withCaption: 'Choose Vehicle' chooseFrom: vehicleNames.	^selection = 0		ifTrue: [nil]		ifFalse: [vehicleNames at: selection].! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/16/2004 11:56'!promptForName: key	| name |	name := FillInTheBlankMorph request: 'Enter name of new ', key, ':' initialAnswer: key.	^(name isNil or: [name withBlanksTrimmed isEmpty])		ifTrue: [nil]		ifFalse: [name withBlanksTrimmed].! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/15/2004 19:51'!readMapNamed: mapName	| mapForm |	mapMorph		mapForm: (mapForm := Form fromFileNamed: 'maps\', mapName, '.bmp');		extent: 400 @ 424;		mapPixelsPerMeter: 4;		resetZoom.	mission map		surfaceMap: mapForm;		surfaceMapName: mapName.! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/21/2004 23:17'!removeDeletedObjects	"Map objects that are deleted are still referenced from goals, but marked as 'deleted'.	Here we set them to nil."	mission allGoals do: [:each | each removeDeletedObjects].! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/21/2004 23:17'!renameGoal	| newName |	newName := FillInTheBlankMorph request: 'Enter new goal name:' initialAnswer: selectedGoal.	(newName isNil or: [newName withBlanksTrimmed isEmpty])		ifTrue: [^self].	selectedGoal name: newName.	self changed: #goalsForList! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/21/2004 22:42'!selectedGoal	^selectedGoal! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/15/2004 23:33'!setBottomOfRampLocation: aString 	| object |	object := self mapObjectNamed: aString.	mapMorph		setSelection: object;		changed.	self selectedGoal navigator bottomLocation: object.! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/17/2004 15:38'!setConeColor: aColor	ConeColor := aColor! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/15/2004 23:33'!setTopOfRampLocation: aString 	| object |	object := self mapObjectNamed: aString.	mapMorph		setSelection: object;		changed.	self selectedGoal navigator topLocation: object.! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/12/2004 19:52'!setZoomTo: zoomString	mapMorph zoomTo: (zoomString copyWithout: $x) asNumber.	self status: 'Zoomed to ', mapMorph zoomFactor printString, 'x'.! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 12/14/2004 12:40'!showGps	showGps := true.! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 12/14/2004 12:40'!showLocal	showGps := false.! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/13/2004 15:56'!textFieldContentsFor: fieldName	^(textEditFields at: fieldName) contents asString! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/13/2004 16:22'!textFieldFor: fieldName	^textEditFields at: fieldName! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 12/14/2004 12:42'!toggleLocalGpsCursor	showGps := showGps not.! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 11/28/2004 17:50'!updateNewMission	self changed: #goalsForList.	(self textFieldFor: #mapName)		contents: mission map surfaceMapName;		extent: 200 @ 19.	(self textFieldFor: #missionNameField)		contents: mission name;		wrapFlag: true.	selectedGoal := 1.	mapMorph		objects: mission map mapEntries copy;		mapForm: mission map surfaceMap;		noSelection;		clearUndo;		clearRedo;		resetZoom;		changed.	self addNavigatorPanelFor: nil.! !!AvMissionEditor methodsFor: 'private' stamp: 'Jon 11/26/2004 11:05'!visualNavigatorConeColorString	^self selectedGoal navigator color printString! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/12/2004 16:41'!zoomIn	mapMorph zoomIn.	self status: 'Zoomed to ', mapMorph zoomFactor printString, 'x'.! !!AvMissionEditor methodsFor: 'private' stamp: 'jon 11/12/2004 16:41'!zoomOut	mapMorph zoomOut.	self status: 'Zoomed to ', mapMorph zoomFactor printString, 'x'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvMissionEditor class	instanceVariableNames: ''!!AvMissionEditor class methodsFor: 'instance scheduling' stamp: 'jon 11/12/2004 12:26'!open	^self new createView! !Morph subclass: #AvPlannerMorph	instanceVariableNames: 'planner boxes startPoint endPoint'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-UI'!!AvPlannerMorph methodsFor: 'initializing' stamp: 'jon 10/28/2004 12:40'!initialize	boxes := OrderedCollection new.	planner := AvWaypointPlanner new.	^super initialize.! !!AvPlannerMorph methodsFor: 'accessing' stamp: 'jon 10/14/2004 12:04'!boxes	"Answer the value of boxes"	^ boxes! !!AvPlannerMorph methodsFor: 'accessing' stamp: 'jon 10/14/2004 12:04'!boxes: anObject	"Set the value of boxes"	boxes _ anObject! !!AvPlannerMorph methodsFor: 'accessing' stamp: 'jon 10/14/2004 12:28'!displayEndPoint	^self displayTranslate: self endPoint! !!AvPlannerMorph methodsFor: 'accessing' stamp: 'jon 10/14/2004 12:28'!displayStartPoint	^self displayTranslate: self startPoint! !!AvPlannerMorph methodsFor: 'accessing' stamp: 'jon 10/14/2004 12:28'!displayTranslate: aPoint	^aPoint + self bounds origin! !!AvPlannerMorph methodsFor: 'accessing' stamp: 'jon 10/14/2004 12:04'!endPoint	"Answer the value of endPoint"	^ endPoint! !!AvPlannerMorph methodsFor: 'accessing' stamp: 'jon 10/14/2004 12:04'!endPoint: anObject	"Set the value of endPoint"	endPoint _ anObject! !!AvPlannerMorph methodsFor: 'accessing' stamp: 'jon 10/14/2004 12:04'!planner	"Answer the value of planner"	^ planner! !!AvPlannerMorph methodsFor: 'accessing' stamp: 'jon 10/14/2004 12:04'!planner: anObject	"Set the value of planner"	planner _ anObject! !!AvPlannerMorph methodsFor: 'accessing' stamp: 'jon 10/14/2004 12:04'!startPoint	"Answer the value of startPoint"	^ startPoint! !!AvPlannerMorph methodsFor: 'accessing' stamp: 'jon 10/14/2004 12:04'!startPoint: anObject	"Set the value of startPoint"	startPoint _ anObject! !!AvPlannerMorph methodsFor: 'drawing' stamp: 'Jon 11/29/2004 12:47'!drawOn: canvas	| translateBlock |	canvas		fillRectangle: self bounds color: Color white;		frameRectangle: self bounds color: Color black.	translateBlock := [:point | point + self bounds origin].	self boxes doWithIndex: [:each :index |		each drawOn: canvas translateBy: translateBlock selected: #().		canvas drawString: index printString in: ((0@0 extent: 20@20) align: 10@10 with: each boundingBox center)].	startPoint notNil		ifTrue: [canvas fillOval: (Rectangle center: self displayStartPoint extent: 5@5) color: Color green].	endPoint notNil		ifTrue: [canvas fillOval: (Rectangle center: self displayEndPoint extent: 5@5) color: Color red].	planner path notNil		ifTrue: [			(planner path copyFrom: 1 to: planner path size - 1) doWithIndex: [:each :index |				canvas					line: (self displayTranslate: each)					to: (self displayTranslate: (planner path at: index + 1))					width: 2					color: Color black.				index ~= 1					ifTrue: [canvas fillOval: (Rectangle center: (self displayTranslate: each) extent: 5@5) color: Color blue]]].! !!AvPlannerMorph methodsFor: 'event handling' stamp: 'Jon 11/29/2004 12:43'!addBox	| box area |	box := Rectangle fromUser.	(self bounds containsRect: box)		ifFalse: [^self].	box hasPositiveExtent		ifFalse: [^self].	area := AvArea new		name: 'Box ', (self boxes size + 1) printString;		yourself.	box := box translateBy: self bounds origin negated.	box corners do: [:each |		area addPoint: (AvPosition fromPoint: each)].	self boxes add: area.	self replan; changed! !!AvPlannerMorph methodsFor: 'event handling' stamp: 'jon 10/14/2004 12:40'!explorePlanner	planner explore! !!AvPlannerMorph methodsFor: 'event handling' stamp: 'jon 10/14/2004 12:17'!handlesMouseDown: event	^ true! !!AvPlannerMorph methodsFor: 'event handling' stamp: 'jon 10/14/2004 12:40'!mouseDown: event	| selection |	selection := (PopUpMenu		labelArray: #('set start point' 'set end point' 'add box' 'remove box' 'explore planner')		lines: #(2 4)) startUp.	selection = 0		ifTrue: [^self].	self perform: (#(setStartPoint setEndPoint addBox removeBox explorePlanner) at: selection)! !!AvPlannerMorph methodsFor: 'event handling' stamp: 'Jon 11/29/2004 12:43'!removeBox	| point translatedPoint |	point := Point fromUser.	(self bounds containsPoint: point)		ifFalse: [^self].	translatedPoint := point - self bounds origin.	self boxes: (self boxes reject: [:each | each boundingBox containsPoint: translatedPoint]).	self replan; changed! !!AvPlannerMorph methodsFor: 'event handling' stamp: 'jon 10/14/2004 12:17'!setEndPoint	| point |	point := Point fromUser.	(self bounds containsPoint: point)		ifFalse: [^self].	endPoint := point - self bounds origin.	self replan; changed! !!AvPlannerMorph methodsFor: 'event handling' stamp: 'jon 10/14/2004 12:13'!setStartPoint	| point |	point := Point fromUser.	(self bounds containsPoint: point)		ifFalse: [^self].	startPoint := point - self bounds origin.	self replan; changed! !!AvPlannerMorph methodsFor: 'private' stamp: 'jon 10/14/2004 12:15'!replan	startPoint isNil | endPoint isNil		ifTrue: [^self].	planner		startLocation: self startPoint;		endLocation: self endPoint;		map: self boxes;		boundingBox: (0 @ 0 extent: self bounds extent);		replan! !Morph subclass: #AvSimulatedClodBusterVehicleMorph	instanceVariableNames: 'orientation pitch roll heading'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-UI'!!AvSimulatedClodBusterVehicleMorph methodsFor: 'drawing' stamp: 'jon 10/21/2004 17:20'!drawOn: aCanvas	self drawSideViewOn: aCanvas! !!AvSimulatedClodBusterVehicleMorph methodsFor: 'drawing' stamp: 'jon 10/21/2004 21:11'!drawSideViewOn: aCanvas	| center pitchRadians transformationBlock frontCenter backCenter chassis turrentTube turrent scale tireBox |	aCanvas		fillOval: self bounds		color: Color white		borderWidth: 1		borderColor: Color black.	center := self center.	pitchRadians := pitch isNil		ifTrue: [0]		ifFalse: [pitch degreesToRadians].	scale := self extent.	transformationBlock := [:eachPoint |		eachPoint * scale + self bounds origin rotateBy: pitchRadians about: center].	frontCenter := transformationBlock value: 0.25 @ 0.6.	backCenter := transformationBlock value: 0.75 @ 0.6.	chassis := {0.15 @ 0.55 . 0.85 @ 0.55 . 0.8 @ 0.35 . 0.7 @ 0.35 . 0.65 @ 0.4 . 0.35 @ 0.4 . 0.3 @ 0.35 . 0.2 @ 0.35}		collect: [:each | transformationBlock value: each].	turrentTube := {0.225 @ 0.35 . 0.275 @ 0.35 . 0.275 @ 0.2 . 0.225 @ 0.2}		collect: [:each | transformationBlock value: each].	tireBox := (-0.15 @ -0.15 extent: 0.3 @ 0.3) scaleBy: scale.	turrent := (-0.05 @ -0.05 extent: 0.1 @ 0.1) scaleBy: scale.	aCanvas		drawPolygon: chassis color: Color darkGray borderWidth: 1 borderColor: Color black;		drawPolygon: turrentTube color: Color darkGray borderWidth: 1 borderColor: Color black.	aCanvas		fillOval: (turrent align: 0 @ 0 with: (transformationBlock value: 0.25 @ 0.2))			color: Color lightGray			borderWidth: 1			borderColor: Color black;		fillOval: (tireBox align: 0 @ 0 with: frontCenter) color: Color black;		fillOval: ((tireBox scaleBy: 0.4) align: 0 @ 0 with: frontCenter) color: Color lightGray;		fillOval: (tireBox align: 0 @ 0 with: backCenter) color: Color black;		fillOval: ((tireBox scaleBy: 0.4) align: 0 @ 0 with: backCenter) color: Color lightGray.! !Object subclass: #AvPDAButton	instanceVariableNames: 'selector owner boundingBox'	classVariableNames: ''	poolDictionaries: ''	category: 'Av-PDA'!!AvPDAButton methodsFor: 'api' stamp: 'jon 10/24/2004 14:46'!boundingBox	^boundingBox! !!AvPDAButton methodsFor: 'api' stamp: 'jon 10/24/2004 14:41'!boundingBox: aRectangle	boundingBox := aRectangle! !!AvPDAButton methodsFor: 'api' stamp: 'jon 11/9/2004 13:19'!handlePressAt: mousePoint	Display reverse: self boundingBox.	(self boundingBox containsPoint: Sensor waitNoButton)		ifTrue: [			Display reverse: self boundingBox.			owner perform: selector]		ifFalse: [Display reverse: self boundingBox].! !!AvPDAButton methodsFor: 'api' stamp: 'jon 11/9/2004 12:00'!owner	^owner! !!AvPDAButton methodsFor: 'api' stamp: 'jon 11/9/2004 11:59'!owner: anObject	owner := anObject! !!AvPDAButton methodsFor: 'api' stamp: 'jon 11/9/2004 12:17'!selector: aSymbol	selector := aSymbol! !Object subclass: #AvPDACoursePreparationEditor	instanceVariableNames: 'form maskForm mapForm zoomedMapForm zoomFactor scrollOffset objects gpsSensor buttons status selectedObject running currentCourse anchorGpsCoordinate'	classVariableNames: 'MapForms'	poolDictionaries: ''	category: 'Av-PDA'!!AvPDACoursePreparationEditor methodsFor: 'initializing' stamp: 'jon 11/13/2004 22:26'!initialize	zoomFactor := 1.	scrollOffset := 0 @ 0.	status := 'ready'.	currentCourse := 'RoboMagellan 1'.	self		buildGpsSensor;		readForms;		buildButtons.	objects := Dictionary new.! !!AvPDACoursePreparationEditor methodsFor: 'private-drawing' stamp: 'jon 11/11/2004 12:31'!displayForm	form display! !!AvPDACoursePreparationEditor methodsFor: 'private-drawing' stamp: 'jon 11/10/2004 14:31'!displayMapForm	self		drawMapForm;		drawObjects;		displayForm! !!AvPDACoursePreparationEditor methodsFor: 'private-drawing' stamp: 'jon 11/10/2004 13:06'!drawButtons"	buttons do: [:each |		form border: each boundingBox width: 2 fillColor: Color red]."! !!AvPDACoursePreparationEditor methodsFor: 'private-drawing' stamp: 'jon 11/10/2004 16:24'!drawForm	form := Form extent: maskForm extent depth: 32.	maskForm displayOn: form.	self 		drawMapForm;		drawObjects;		drawButtons;		drawGPSCoordinate;		drawStatus.	self displayForm! !!AvPDACoursePreparationEditor methodsFor: 'private-drawing' stamp: 'jon 11/10/2004 21:21'!drawGPSCoordinate	| latitudeString longitudeString |	(Smalltalk includesKey: #AvGpsSensor)		ifFalse: [^self].	latitudeString := self gpsCoordinate latitudeString collect: [:each |		each = '' first			ifTrue: [Character value: 174]			ifFalse: [each]].	longitudeString := self gpsCoordinate longitudeString collect: [:each |		each = '' first			ifTrue: [Character value: 174]			ifFalse: [each]].	self		drawText: 'LAT:' at: 40 @ 225;		drawText: 'LONG:' at: 40 @ 241;		drawText: latitudeString at: 75 @ 225;		drawText: longitudeString at: 75 @ 241.	self		drawText: 'accuracy:' at: 140 @ 225;		drawText: (self gpsCoordinate uncertainty roundTo: 0.1) printString, ' M' at: 150 @ 241! !!AvPDACoursePreparationEditor methodsFor: 'private-drawing' stamp: 'jon 11/11/2004 12:22'!drawMapForm	| zoomBox |	zoomFactor = 1		ifTrue: [^mapForm displayOn: form at: 1 @ 1].	zoomBox := scrollOffset // (zoomFactor // 2) extent: mapForm extent // (zoomFactor // 2).	(zoomedMapForm magnify: zoomBox by: zoomFactor // 2 smoothing: 2)		displayOn: form		at: 1 @ 1! !!AvPDACoursePreparationEditor methodsFor: 'private-drawing' stamp: 'jon 11/12/2004 10:00'!drawObjects	| clipBox translationBlock |	clipBox := 1 @ 1 extent: mapForm extent.	translationBlock := [:mapPoint | self formLocationFor: mapPoint].	objects do: [:each |		each drawOnForm: form translateBy: translationBlock clipTo: clipBox selected: each == selectedObject].! !!AvPDACoursePreparationEditor methodsFor: 'private-drawing' stamp: 'jon 10/24/2004 23:57'!drawPanAreas	zoomFactor = 1		ifTrue: [^self].	self panBoxes do: [:each |		form fill: each fillColor: Color red]! !!AvPDACoursePreparationEditor methodsFor: 'private-drawing' stamp: 'jon 11/9/2004 12:40'!drawStatus	form fill: (5 @ 264 extent: 230 @ 18) fillColor: Color white.	self		drawText: 'Status:   ', self status		at: 10 @ 267! !!AvPDACoursePreparationEditor methodsFor: 'private-drawing' stamp: 'jon 11/10/2004 20:46'!drawText: aString at: aPoint	aString asDisplayText		textStyle: (TextStyle named: 'Lucy');		displayOn: form at: aPoint		clippingBox: form boundingBox		rule: Form paint		fillColor: nil! !!AvPDACoursePreparationEditor methodsFor: 'private-drawing' stamp: 'jon 11/9/2004 13:17'!form	^form! !!AvPDACoursePreparationEditor methodsFor: 'private-drawing' stamp: 'jon 10/24/2004 13:49'!openImageMorph	ImageMorph new		image: form;		openInWorld! !!AvPDACoursePreparationEditor methodsFor: 'private-drawing' stamp: 'jon 10/25/2004 00:04'!panBoxes	| box innerBox |	box := 1 @ 1 extent: mapForm extent.	innerBox := box insetBy: 5.	^Dictionary new		at: #north put: ((box topCenter corner: innerBox topCenter) expandBy: 5 @ 0);		at: #south put: ((innerBox bottomCenter corner: box bottomCenter) expandBy: 5 @ 0);		at: #east put: ((innerBox rightCenter corner: box rightCenter) expandBy: 0 @ 5);		at: #west put: ((box leftCenter corner: innerBox leftCenter) expandBy: 0 @ 5);		at: #northWest put: (1 @ 1 extent: 7 @ 7);		at: #northEast put: (box topRight - (7 @ 0) extent: 7 @ 7);		at: #southWest put: (box bottomLeft - (0 @ 7) extent: 7 @ 7);		at: #southEast put: (box bottomRight - (7 @ 7) extent: 7 @ 7);		yourself! !!AvPDACoursePreparationEditor methodsFor: 'private-ui handling' stamp: 'jon 11/21/2004 09:32'!runUI	| delay |	delay := Delay forMilliseconds: 50.	running := true.	Cursor normal showWhile: [		[running] whileTrue: [			| mousePoint |			self processEvent.			mousePoint := Sensor waitButton.			(self handleMouseClick: mousePoint)				ifFalse: [].			delay wait.			running := running and: [form boundingBox containsPoint: mousePoint]].		self updateStatus: 'done, exiting']! !!AvPDACoursePreparationEditor methodsFor: 'private-button handling' stamp: 'jon 11/21/2004 09:40'!addGpsLocation	(gpsSensor notNil and: [gpsSensor isConnected])		ifFalse: [^self updateStatus: 'GPS not connected'].	self anchorLocation isNil		ifTrue: [^self updateStatus: 'Must have an ''Anchor'' location...'].	! !!AvPDACoursePreparationEditor methodsFor: 'private-button handling' stamp: 'jon 11/21/2004 09:32'!addLocation	| mapBox point |	self updateStatus: 'Click on map to add location'.	mapBox := 1 @ 1 extent: mapForm extent.	Cursor crossHair showWhile: [		self processEvent.		(mapBox containsPoint: (point := Sensor waitButton))			ifTrue: [				| position name location |				position := (self mapPositionFor: point) rounded.				self addObject: (location := AvLocation new					name: (name := self newLocationName);					position: (AvPosition fromPoint: position);					yourself).				selectedObject := location.				self					status: 'added ', name, ' at ', position printString;					drawForm]			ifFalse: [self updateStatus: 'add location cancelled']].! !!AvPDACoursePreparationEditor methodsFor: 'private-button handling' stamp: 'jon 11/21/2004 09:31'!addTrack	| mapBox point path |	Cursor crossHair showWhile: [		self updateStatus: 'click for start of path'.		mapBox := 1 @ 1 extent: mapForm extent.		path := AvPath new name: self newPathName; yourself.		self addObject: path.		self processEvent.		[mapBox containsPoint: (point := Sensor waitButton)] whileTrue: [			| position |			position := (self mapPositionFor: point) rounded.			path addPoint: (AvPosition fromPoint: position).			self				status: 'click to extend path';				drawForm.			self processEvent.			Sensor waitNoButton.			self processEvent].		path isEmpty			ifTrue: [				self removeObject: path.				^self status: 'add path cancelled'; drawForm].		self updateStatus: 'path added'].! !!AvPDACoursePreparationEditor methodsFor: 'private-button handling' stamp: 'jon 11/10/2004 22:10'!deleteObject	| name |	selectedObject isNil		ifTrue: [^self updateStatus: 'must select something first'].	self removeObject: selectedObject.	name := selectedObject name.	selectedObject := nil.	self		updateStatus: 'deleted ', name;		drawForm.! !!AvPDACoursePreparationEditor methodsFor: 'private-button handling' stamp: 'jon 11/10/2004 16:11'!exit	running := false! !!AvPDACoursePreparationEditor methodsFor: 'private-button handling' stamp: 'jon 11/21/2004 09:56'!gpsMenu	| index selector |	index := PopUpMenu withCaption: 'GPS' chooseFrom: #('Restart GPS' 'Add @ Current Position').	index = 0		ifTrue: [^self].	selector := #(restartGPS addGpsLocation) at: index.	self perform: selector! !!AvPDACoursePreparationEditor methodsFor: 'private-button handling' stamp: 'jon 11/11/2004 15:59'!open	| courseMap course center courseNames courseName |	center := 40 @ 80.	courseMap := self readCourses.	courseNames := courseMap keys asSortedCollection asArray.	course := (PopUpMenu labelArray: courseNames)		startUpWithCaption: 'Choose a course:' at: center.	course isNil | (course = 0)		ifTrue: [^self status: 'load cancelled'; drawForm].	courseName := courseNames at: course.	self		status: 'reading ', courseName, '... please wait';		drawForm;		readCourseNamed: courseName from: courseMap;		status: 'opened ', courseName;		drawForm.! !!AvPDACoursePreparationEditor methodsFor: 'private-button handling' stamp: 'jon 11/21/2004 09:32'!pan	| originalMousePoint originalScrollOffset delay |	zoomFactor = 1		ifTrue: [^self].	self updateStatus: 'press and hold to pan'.	Cursor webLink showWhile: [		self processEvent.		Sensor waitNoButton; waitButton.		[(1 @ 1 extent: mapForm extent) containsPoint: Sensor cursorPoint] whileTrue: [			originalMousePoint := Sensor cursorPoint.			originalScrollOffset := scrollOffset.			delay := Delay forMilliseconds: 50.			[Sensor anyButtonPressed] whileTrue: [				| offset |				self processEvent.				offset := Sensor cursorPoint - originalMousePoint.				offset := offset negated.				scrollOffset := originalScrollOffset + offset.				self limitScrollOffset.				self displayMapForm.				delay wait].			self processEvent.			Sensor waitButton]].	self updateStatus: 'done pan'.! !!AvPDACoursePreparationEditor methodsFor: 'private-button handling' stamp: 'jon 11/10/2004 13:44'!restartGPS	self updateStatus: 'restarting GPS, please wait...'.	(Delay forMilliseconds: 2000) wait.	self updateStatus: 'GPS Restarted'! !!AvPDACoursePreparationEditor methodsFor: 'private-button handling' stamp: 'jon 11/11/2004 13:11'!save	self		saveCurrentCourse;		status: 'saved ', currentCourse;		drawForm.! !!AvPDACoursePreparationEditor methodsFor: 'private-button handling' stamp: 'jon 11/11/2004 12:29'!zoomIn	| center |	zoomFactor = 8		ifTrue: [^self].	zoomFactor := zoomFactor * 2.	"Try and center the view on the selected object, if there is one."	center := selectedObject isNil		ifTrue: [(mapForm extent // 2) * zoomFactor]		ifFalse: [			scrollOffset := 0 @ 0.			self formLocationFor: selectedObject centerPoint].	scrollOffset := center - (mapForm extent // 2).	self limitScrollOffset.	self		status: 'zoomed to ', zoomFactor printString, 'x';		drawForm! !!AvPDACoursePreparationEditor methodsFor: 'private-button handling' stamp: 'jon 11/11/2004 15:40'!zoomOut	| center |	zoomFactor = 1		ifTrue: [^self].	zoomFactor := zoomFactor // 2.	zoomFactor = 1		ifTrue: [scrollOffset := 0 @ 0]		ifFalse: [			center := selectedObject isNil				ifTrue: [(scrollOffset + (mapForm extent // 2)) // 2]				ifFalse: [					scrollOffset := 0 @ 0.					self formLocationFor: selectedObject centerPoint].			scrollOffset := center - (mapForm extent // 2).			self limitScrollOffset].	self		status: 'zoomed to ', zoomFactor printString, 'x';		drawForm! !!AvPDACoursePreparationEditor methodsFor: 'private-direct manipulation' stamp: 'jon 11/21/2004 09:33'!directPan	| originalMousePoint originalScrollOffset delay |	zoomFactor = 1		ifTrue: [^self].	Cursor webLink showWhile: [		originalMousePoint := Sensor cursorPoint.		originalScrollOffset := scrollOffset.		delay := Delay forMilliseconds: 50.		self processEvent.		[Sensor anyButtonPressed] whileTrue: [			| offset |			self processEvent.			offset := Sensor cursorPoint - originalMousePoint.			offset := offset negated.			scrollOffset := originalScrollOffset + offset.			self limitScrollOffset.			self displayMapForm.			delay wait]].! !!AvPDACoursePreparationEditor methodsFor: 'private-direct manipulation' stamp: 'jon 11/11/2004 15:55'!handleDragFrom: mousePoint	"If we click on the background, where there aren't any objects, switch to pan mode."	selectedObject isNil		ifTrue: [^self directPan].	"Otherwise, let the object handle the drag..."	selectedObject		handleDragFrom: mousePoint		using: [:screenPoint | self mapPositionFor: screenPoint]		displayingWith: [self displayMapForm]		useSlopArea: true! !!AvPDACoursePreparationEditor methodsFor: 'private-direct manipulation' stamp: 'jon 11/11/2004 15:57'!handleMouseClick: mousePoint	| button |	"If they clicked in the map area, handle it there."	((1 @ 1 extent: mapForm extent) containsPoint: mousePoint)		ifTrue: [			self				selectObjectAt: mousePoint;				handleDragFrom: mousePoint.			^true].	"Otherwise, see if they pressed a button."	button := buttons		detect: [:each | (each boundingBox containsPoint: mousePoint)]		ifNone: [^false].	button handlePressAt: mousePoint.	^true! !!AvPDACoursePreparationEditor methodsFor: 'private-direct manipulation' stamp: 'jon 11/10/2004 13:43'!selectObjectAt: formPoint	| mapPosition |	mapPosition := (self mapPositionFor: formPoint) rounded.	selectedObject := self objectNear: mapPosition.	selectedObject isNil		ifTrue: [self status: 'ready']		ifFalse: [self status: 'selected ', selectedObject name].	self drawForm! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/21/2004 09:56'!addAnchorLocation	(objects includesKey: 'Anchor')		ifTrue: [self removeObjectNamed: 'Anchor'].	self addObject: (AvLocation new		name: 'Anchor';		position: (AvPosition fromPoint: 0 @ 0);		gpsCoordinate: anchorGpsCoordinate;		yourself).! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/10/2004 22:09'!addObject: anObject	objects at: anObject name put: anObject! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/21/2004 09:40'!anchorLocation	^objects		detect: [:each | (each name asLowercase = 'anchor') and: [each gpsCoordinate notNil]]		ifNone: [nil].! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/21/2004 09:27'!buildButtons	buttons := OrderedCollection new		add: (AvPDAButton new			selector: #open;			boundingBox: (202 @ 9 extent: 37 @ 20));		add: (AvPDAButton new			selector: #save;			boundingBox: (202 @ 30 extent: 37 @ 20));		add: (AvPDAButton new			selector: #deleteObject;			boundingBox: (202 @ 59 extent: 37 @ 20));		add: (AvPDAButton new			selector: #addLocation;			boundingBox: (202 @ 88 extent: 37 @ 23));		add: (AvPDAButton new			selector: #addTrack;			boundingBox: (202 @ 112 extent: 37 @ 24));		add: (AvPDAButton new			selector: #zoomIn;			boundingBox: (202 @ 145 extent: 18 @ 22));		add: (AvPDAButton new			selector: #zoomOut;			boundingBox: (221 @ 145 extent: 18 @ 22));		add: (AvPDAButton new			selector: #pan;			boundingBox: (202@168 extent: 37 @ 21));		add: (AvPDAButton new			selector: #gpsMenu;			boundingBox: (202 @ 198 extent: 37 @ 25));		add: (AvPDAButton new			selector: #exit;			boundingBox: (202 @ 232 extent: 37 @ 14));		yourself.	buttons do: [:each | each owner: self].! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/10/2004 20:33'!buildGpsSensor"	| device interface |""	device := AvDevice fromFilename: 'GekoPDADevice.txt'.""	interface := (AvSerialPortInterface readOnlyOn: device)."	(Smalltalk includesKey: #AvGpsSensor)		ifFalse: [^self].	gpsSensor := AvGpsSensor new		name: 'gps';		yourself.! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 10/24/2004 14:59'!font	^StrikeFont familyName: 'Lucy' size: 9! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/11/2004 10:24'!formLocationFor: mapPoint	| scaleFactor mapHeight scrolledFormPosition formPosition |	scaleFactor := 2 * zoomFactor.	mapHeight := zoomFactor * mapForm height.	scrolledFormPosition := mapPoint * scaleFactor.	scrolledFormPosition := scrolledFormPosition x @ (mapHeight - scrolledFormPosition y).	formPosition := scrolledFormPosition - scrollOffset + (1 @ 1).	^formPosition! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 10/24/2004 22:39'!gpsCoordinate	^gpsSensor gpsCoordinate isNil		ifTrue: [AvGpsCoordinate latitude: 43.12345 longitude: 80.12345 uncertainty: 27.3]		ifFalse: [gpsSensor gpsCoordinate]! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/11/2004 11:09'!limitScrollOffset	| scrollLimit |	scrollLimit := (mapForm extent * zoomFactor) - mapForm extent.	scrollOffset := (scrollOffset max: 0 @ 0) min: scrollLimit.! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/11/2004 12:23'!loadDefaultObjects	AvLocation locations do: [:eachLocation |		objects at: eachLocation name put: eachLocation].! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/11/2004 10:19'!mapPositionFor: formPosition	| scaleFactor mapPosition scrolledFormPosition mapHeight |	scrolledFormPosition := formPosition + scrollOffset - (1 @ 1).	mapHeight := zoomFactor * mapForm height.	scrolledFormPosition := scrolledFormPosition x @ (mapHeight - scrolledFormPosition y).	scaleFactor := 2 * zoomFactor.	mapPosition := scrolledFormPosition / scaleFactor.	^mapPosition! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/11/2004 05:54'!newLocationName	| names numbers |	names := objects keys select: [:each | each includesSubString: 'Unnamed'].	numbers := names collect: [:each | (each subStrings: ' ') last asNumber].	^numbers isEmpty		ifTrue: ['Unnamed Location 1']		ifFalse: ['Unnamed Location ', (numbers asSortedCollection last + 1) printString]! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/12/2004 08:44'!newPathName	| names numbers |	names := objects keys select: [:each | each includesSubString: 'Unnamed'].	numbers := names collect: [:each | (each subStrings: ' ') last asNumber].	^numbers isEmpty		ifTrue: ['Unnamed Path 1']		ifFalse: ['Unnamed Path ', (numbers asSortedCollection last + 1) printString]! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/10/2004 13:14'!objectNear: mapPoint	| closeObjects min |	closeObjects := objects values asArray select: [:each | (each distanceTo: mapPoint) <= 2].	closeObjects isEmpty		ifTrue: [^nil].	closeObjects size = 1		ifTrue: [^closeObjects first].	min := closeObjects first.	closeObjects do: [:each |		(each distanceTo: mapPoint) < (min distanceTo: mapPoint)			ifTrue: [min := each]].	^min! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/21/2004 09:31'!processEvent	Sensor processEvent: Sensor createMouseEvent.! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'Jon 11/28/2004 17:49'!readCourseNamed: courseName from: courseMap	| file |	currentCourse := courseName.	mapForm := (MapForms at: currentCourse) first.	zoomedMapForm := (MapForms at: currentCourse) second.	anchorGpsCoordinate := (MapForms at: currentCourse) last.	((FileDirectory on: FileDirectory default pathName, '\courses') fileExists: courseName, '.obj')		ifTrue: [			file := FileStream readOnlyFileNamed: 'courses\', courseName, '.obj'.			objects := file fileInObjectAndCode.			file close]		ifFalse: [objects := Dictionary new].	self addAnchorLocation.	selectedObject := nil.! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/11/2004 12:50'!readCourses	| courseMap file |	courseMap := Dictionary new.	file := FileStream readOnlyFileNamed: 'courses\courses.txt'.	[file atEnd] whileFalse: [		| line |		line := file nextLine withBlanksTrimmed subStrings: (String with: Character tab).		line notEmpty			ifTrue: [courseMap at: line first put: (Array with: line second with: line third)]].	file close.	^courseMap! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/21/2004 09:53'!readForms	MapForms isNil		ifTrue: [self class readForms].	maskForm := MapForms at: 'maskForm'.	mapForm := (MapForms at: currentCourse) first.	zoomedMapForm :=  (MapForms at: currentCourse) second.	anchorGpsCoordinate := (MapForms at: currentCourse) last.! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/11/2004 20:28'!removeObject: anObject	^self removeObjectNamed: anObject name! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/11/2004 20:27'!removeObjectNamed: aString	^objects removeKey: aString! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/11/2004 20:27'!renameObjectFrom: oldName to: newName	| object |	object := self removeObjectNamed: oldName.	object name: newName.	self addObject: object! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'Jon 11/28/2004 12:11'!saveCurrentCourse	| file |	(FileDirectory on: FileDirectory default pathName, '\courses') 		deleteFileNamed: currentCourse, '.obj'		ifAbsent: [].	file := SmartRefStream newFileNamed: 'courses\', currentCourse, '.obj'.	file nextPut: objects.	file close.! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/9/2004 12:22'!status	^status! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/9/2004 12:22'!status: aString	status := aString! !!AvPDACoursePreparationEditor methodsFor: 'private' stamp: 'jon 11/9/2004 12:24'!updateStatus: aString	status := aString.	self drawStatus; displayForm! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AvPDACoursePreparationEditor class	instanceVariableNames: ''!!AvPDACoursePreparationEditor class methodsFor: 'instance creation' stamp: 'jon 11/10/2004 20:32'!new	^self basicNew		initialize;		yourself! !!AvPDACoursePreparationEditor class methodsFor: 'accessing' stamp: 'jon 11/21/2004 10:07'!readForms	"AvPDACoursePreparationEditor readForms"	MapForms := Dictionary new		at: 'maskForm' put: (Form fromFileNamed: 'courses\PDA-UI-Mask.bmp');		at: 'RoboMagellan 1' put: (Array			with: (Form fromFileNamed: 'courses\roboMagellan1.bmp')			with: (Form fromFileNamed: 'courses\roboMagellan1-2x.bmp')			with: (AvGpsCoordinate latitude: 47.620075 longitude: 122.351889));		at: 'RoboMagellan 2' put: (Array			with: (Form fromFileNamed: 'courses\roboMagellan2.bmp')			with: (Form fromFileNamed: 'courses\roboMagellan2-2x.bmp')			with: (AvGpsCoordinate latitude: 47.619113 longitude: 122.350410));		at: 'RoboMagellan 3' put: (Array			with: (Form fromFileNamed: 'courses\roboMagellan3.bmp')			with: (Form fromFileNamed: 'courses\roboMagellan3-2x.bmp')			with: (AvGpsCoordinate latitude: 47.622284 longitude: 122.352660));		yourself.! !!AvPDACoursePreparationEditor class methodsFor: 'utilities' stamp: 'jon 11/13/2004 22:17'!fileoutPDA	"AvPDACoursePreparationEditor fileoutPDA"	| file |	file := FileStream newFileNamed: '..\headlessWork\AvPDA.st'.	SystemOrganization		fileOutCategory: 'Av-Mission' on: file;		fileOutCategory: 'Av-Navigation' on: file;		fileOutCategory: 'Av-Tracker/Map' on: file;		fileOutCategory: 'Av-Support' on: file;		fileOutCategory: 'Av-PDA' on: file.	ImageReadWriter fileOutOn: file.	BMPReadWriter fileOutOn: file.	file close! !